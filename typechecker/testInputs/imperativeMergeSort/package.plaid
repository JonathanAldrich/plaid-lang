package testInputs.imperativeMergeSort;

state List {
	method void add(immutable Integer >> immutable Integer i)[unique List >> unique List];
	method unique List split()[unique List >> unique List];
}

state Cons case of List {
	var unique List next;
	val immutable Integer data;
	
	method void add(immutable Integer >> immutable Integer i)[unique Cons >> unique Cons] {
		val unique List addTo = this!next; //unpack this
		addTo.add(i);
		this.next = addTo; //repack this
	}
	
	method unique List split()[unique Cons >> unique Cons] {
		match (this.next) {
			case Cons {
				val unique List odd = this!next; //unpack this
				this.next = odd.split(); //pack this
				odd; //odd is unique List
			}
			case Nil {
				new Nil; // keep the single element and return a new Nil list
			}
		}
	}
	
}

state Nil case of List {
	method void add(immutable Integer >> immutable Integer i)[unique Nil >> unique Cons] {
		this <- Cons {
			val unique List next = new Nil;
			val immutable Integer data = i;
		}
	}
	
	method unique List split()[unique Nil >> unique Nil] {
		new Nil;
	}
}

val (unique List >> none List) -> unique List mergeSort = 
	fn (unique List >> none List list) => {
		match (list) {
			case Nil {
				list
			}
			case Cons {
				match (list.next) {
					case Nil {
						list
					}
					case Cons {
						val unique List half = list.split();
						val unique List sorted1 = mergeSort(list);
						val unique List sorted2 = mergeSort(half);
						merge(sorted1, sorted2);
					}
				}
			}
		}
		
	};

val (unique List >> none List, unique List >> none List) -> unique List merge = 
	fn (unique List >> none List l, unique List >> none List r) => {
		match (l) {
			case Cons {
				match (r) {
					case Cons {
						match (l.data <= r.data) {
							case True {
								val unique List rest = l!next; //unpack l
								val unique List toAppend = merge(rest,r);
								l.next = toAppend; //pack l
								l
							}
							case False {
								val unique List rest = r!next; //unpack r
								val unique List toAppend = merge(l,rest);
								r.next = toAppend; //pack r
								r
							}
						}
					}
					case Nil {
						l
					}
				}
			}
			case Nil {
				r
			}
		}
	};
	
val (immutable List >> immutable List) -> void printList = 
	fn (immutable List >> immutable List list) => { 
		match(list) {
			case Nil { }
			case Cons { 
				java.lang.System.out.print("" + list.data + " ");
				printList(list.next);
			}
		}
	};	
	
method void main() [void >> void] {
	val unique List testList = 
		new Cons {
			val immutable Integer data = 4;
			var unique List next = new Cons {
				val immutable Integer data = 8;
				var unique List next = new Cons {
					val immutable Integer data = 1;
					var unique List next = new Cons {
						val immutable Integer data = 2;
						var unique List next = new Cons {
							val immutable Integer data = 5;
							var unique List next = new Cons {
								val immutable Integer data = 0;
								var unique List next = new Nil;
							};
						};	
					};
				};
			};
		};
	printList(testList);
	val unique List sortedList = mergeSort(testList);
	java.lang.System.out.println("");
	printList(sortedList);
}