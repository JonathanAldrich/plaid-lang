package testInputs.randomTests;

//
//state Nil { }
//
//method unique Nil main()[void >> void] {
//	new Nil;
//}
//
//state A {
//	method void compute()[ immutable A ] {
//		unit
//	}
//	
//	method void computeWrong() [immutable A >> immutable A] {
//		unit
//	}
//	
//	method void computeArg(immutable A x) [immutable A] {
//		unit
//	}
//	
//	method unique A generate() [unique A >> unique A] {
//		this.aNotherFactory();
//	}
//	
//	val () -> unique A aNotherFactory = fn () => new A;
//	
//	val unique A instance = new A;
//	
//	val (immutable Integer >> immutable Integer) -> immutable Integer addFive = fn (immutable Integer >> immutable Integer x) => x + 5;
//	
//	method immutable Integer ten()[immutable A] {
//		this.addFive(5);
//	}
//}
//
//val void x = unit;
//
//val (immutable A) -> void test =  fn (immutable A x) => unit;
//
//val () -> unique A aFactory = fn () => new A;
//
//val (immutable A) -> void bar = fn (immutable A x) => x.compute();
//
//val (immutable A) -> void barWrong = fn (immutable A x) => x.computeWrong();
//
//val (unique A) -> void doubleA = fn (unique A x) => x.computeArg(x); 
//
//val (immutable A) -> unique A arg = fn (immutable A x) => {
//	val unique A a = new A;
//	a.computeArg(x);
//	a.instance.aNotherFactory();
//};
//
//val () -> immutable Integer test = fn () => 5 + 4;

state A {
	val unique B b;
	method void callA()[unique A] { unit }
}

state B { }

val (unique A >> none A) -> none A test = fn (unique A >> none A x) => {
	val unique A take = x;
	x;
};

method void main()[void >> void] {
	val unique A a = new A { val unique B b = new B; };
	a!b;
	a.b = new B;
	test(a);
	unit;
}

