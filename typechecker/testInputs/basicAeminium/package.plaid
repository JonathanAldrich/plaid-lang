package testInputs.basicAeminium;

state A {
	method void compute()[ immutable A ] {
		unit
	}
	
	method void computeWrong() [immutable A >> immutable A] {
		unit
	}
	
	method void computeArg(immutable A x) [immutable A] {
		unit
	}
	
	method unique A generate() [unique A >> unique A] {
		this.aNotherFactory();
	}
	
	val () -> unique A aNotherFactory = fn () => new A;
	
	val unique A instance = new A;
	
	val (immutable Integer >> immutable Integer) -> immutable Integer addFive = fn (immutable Integer >> immutable Integer x) => x + 5;
	
	method immutable Integer ten()[immutable A] {
		this.addFive(5);
	}
}

val void x = unit;

val (immutable A) -> void test =  fn (immutable A x) => unit;

val () -> unique A aFactory = fn () => new A;

val (immutable A) -> void bar = fn (immutable A x) => x.compute();

val (immutable A) -> void barWrong = fn (immutable A x) => x.computeWrong();

val (unique A) -> void doubleA = fn (unique A x) => x.computeArg(x); 

val (immutable A) -> unique A arg = fn (immutable A x) => {
	val unique A a = new A;
	a.computeArg(x);
	a.instance.aNotherFactory();
};

val () -> immutable Integer test = fn () => 5 + 4;

//val (unique A) -> void foo  = fn (unique A x) => {
//   read(x);
//   read(x);
//};

//method main() {
//	aFactory();
//	doubleA(new A);
//}
