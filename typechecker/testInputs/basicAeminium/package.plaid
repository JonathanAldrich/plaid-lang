package testInputs.basicAeminium;

state A {
	method void compute()[ immutable A ] {
		unit
	}
	
	method void computeWrong() [immutable A >> immutable A] {
		unit
	}
	
	method void computeArg(immutable A x) [unique A] {
		unit
	}
}

val void x = unit;

val (immutable A) -> void test =  fn (immutable A x) => unit;

val () -> unique A aFactory = fn () => new A;

val (immutable A) -> void bar = fn (immutable A x) => x.compute();

val (immutable A) -> void barWrong = fn (immutable A x) => x.computeWrong();

val (immutable A) -> void arg = fn (immutable A x) => {
	val a = new A;
	a.computeArg(x);
};

//val (unique A) -> void foo  = fn (unique A x) => {
//   read(x);
//   read(x);
//};

//method main() {
//	foo(new A);
//}
