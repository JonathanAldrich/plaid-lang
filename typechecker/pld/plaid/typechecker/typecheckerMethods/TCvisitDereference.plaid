package plaid.typechecker.typecheckerMethods;

import plaid.typechecker.context.*;
import plaid.ast.types.*;
import plaid.ast.*;

state TCvisitDereference {

	override val /*StateTable*/ stateTable; // need to know about nominal types during typechecking
	override val /*Context*/ context; //need to keep track of variables and types
	override var /*Option PermType*/ typedAs;

	override method visitDereference(node) {
		java.lang.System.out.println("Checking Deref");
		match (node.left) {
			case ID {
				ifElse(this.context.containsKey(node.left)) {
					val /*PermType*/ leftType = this.context.remove(node.left);
					match (leftType.type) {
						case NominalType {
							val /*Option stateType*/ members = this.stateTable.get(leftType.type.typeName);
							match (members) {
								case Some {
									val /*Option DeclType*/ declType = members.value.declaredTypeOf(node.right);
									match (declType) {
										case Some {
											match (declType.value) {
												case FieldType {
													val /*FieldType*/ fType = declType.value.permType;
													val /*Permission*/ readPerm = fieldReadPermission(leftType.perm, fType.perm);
													typedAs = createSome(new PermType {
														val /*Permission*/ perm = readPerm;
														val /*Type*/ type = fType.type;
														val /*boolean*/ borrowed = false;  //TODO: borrowing in the context of a deref
													});
													
													//add type to let binding node
													node.type <- PermType {
														val perm = typedAs.value.perm;
														val type = typedAs.value.type;
														val borrowed = typedAs.value.borrowed;
													};
													node.left.type <- PermType { //type of left object
														val perm = leftType.perm;
														val type = leftType.type;
														val borrowed = leftType.borrowed;
													};
													node.right.type <- FieldType { //type of right deref in left object
														val /*ID*/ name = declType.value.name.copy();
														val /*PermType*/ permType = declType.value.permType;
														val /*Boolean*/ isImmutable = declType.value.isImmutable	;
													};
													
													
													this.context.put(node.left,leftType); //non-destructive means put the left object back as is
												}
												default {
													val msg = node.right.name + " not a field in " + leftType.type.typeName.name;
													typeError(node, msg, true);
													java.lang.System.out.println("TYPECHECK FAILED: " + msg);
													typedAs = NONE;
												}
											}									
										} 
										default {
											val msg = "field " + node.right.name + " not declared in type " + leftType.type.typeName.name;
											typeError(node, msg, true);
											java.lang.System.out.println("TYPECHECK FAILED: " + msg);
											typedAs = NONE;
										}
									}
								}
								case None {
									val msg = "Type " + leftType.type.typeName.name + " not defined";
									typeError(node, msg, true);
									java.lang.System.out.println("TYPECHECK FAILED: " + msg);
									typedAs = NONE;
								}
							}
						}
						default {
							val msg = "Deref target has unsupported object type";
							typeError(node, msg, true);
							java.lang.System.out.println("TYPECHECK FAILED: " + msg);
							typedAs = NONE;
						}
					}
				} {
					val msg = node.left.name + " not found in the context";
					typeError(node, msg, true);
					java.lang.System.out.println("TYPECHECK FAILED: " + msg);
					typedAs = NONE;
				}
			}
			default {
				val msg = "Deref Not in let normal form";
				typeError(node, msg, true);
				java.lang.System.out.println("TYPECHECK FAILED: " + msg);
				typedAs = NONE;
			
			}
		}
	}

}