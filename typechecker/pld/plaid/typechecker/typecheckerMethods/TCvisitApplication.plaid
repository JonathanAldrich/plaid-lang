package plaid.typechecker.typecheckerMethods;

import plaid.typechecker.context.*;
import plaid.ast.types.*;
import plaid.ast.*;

state TCvisitApplication {

	//override val /*StateTable*/ stateTable; // need to know about nominal types during typechecking
	//override val /*Context*/ context; //need to keep track of variables and types
	//override var /*Option PermType*/ typedAs;

	override method visitApplication(node) {
			//steps:
		//1) get type of function from context
		//2) verify that arg's type in context allows application (if arg needed)
		//	a) add split and join nodes
		//3) update context based on signature
		
		match (node.f) {
			case ID { 
				val /*ID*/ theFunction = node.f;
				ifElse ( this.context.containsKey(theFunction)) {
					val /*PermType*/ functionType = this.context.get(theFunction); //  just get the function type without removing it TODO: need multi set?
					match ( functionType.type ) {
						case LambdaType {
							
							//applications go through a smaller transformation than method calls because no receiver is bound
							//Overall:
							// MethodCall becomes:
							//
							// [Split(args)] in
							// let temp = MethodCall in
							// [Join(args)] in
							// temp
							//
							// We start with the let binding, surround it with
							// the split/join for the args if needed,
							// and then transition the original method call
							// to the split for the receiver and set the body
							// of the let (or join if there are args) to the
							// receiver split
							
							//need to add split/joins for argument if needed //TODO: environment
							//pull out type for receiver
							val lType = functionType.type;
													
							//arg handling if needed						
							var /*boolean*/ argOk = true;
							ifElse (lType.hasArg()) { //surround callBody with split/join for args
								//check arguments
								val /*List<ID>*/ arguments = node.arguments.map(fn (a) => a.copy()); //list of argument IDs - use later as handle for adding types
								val /*List<ChangeType>*/ argTypes = lType.argTypes;
								
								var /*boolean*/ argsOk = arguments.length() == argTypes.length();
								ifElse (argsOk) {
									
									//zip up IDs and their typing information
									val /*List<ID,ChangeType>*/ argIDtypes = arguments.zip(argTypes);
									
									//first check the initial types are available
									val /*List<Pair<PermType,PermType>>*/ startAndResidues = argIDtypes.map(fn (p) => {
										val argID = p.fst;
										ifElse(this.context.containsKey(argID)) {
											val /*PermType*/ aTypeStart = this.context.remove(argID);
											val /*PermType*/ aTypeNeeded = p.snd.input;
											
											//try to pull out necessary type
											val /*Option PermType*/ aTypeResidue = aTypeStart.split(aTypeNeeded, this.stateTable);
											
											match (aTypeResidue) {
												case Some{ //split succeeded
													//this.context.put(argID, aTypeResidue.value); //pass around in pairs instead
													makePair(aTypeStart,aTypeResidue.value);
												}
												case None {
													val msg = "Could not split needed permission for arg " + argID.name; //TODO: this could be a typechecker argID - do a better job of error reporting
													typeError(node, msg, true);
													java.lang.System.out.println("TYPECHECK FAILED: " + msg); 
													argsOk = false;
													this.typedAs = NONE;
													NONE
												}	
											}
										} {
											val msg = "no permission for ID " + argID.name + " in context";
											typeError(node, msg, true);
											java.lang.System.out.println("TYPECHECK FAILED: " + msg);
											argsOk = false;
											this.typedAs = NONE;
											NONE
										}
									
									});
									
									
									
									ifElse(argsOk) {
										//next check that we can use the output and residue to join back to the required type
										// structure of preCall:
										//	List<
										//		Pair
										//			f: Pair
										//				f: ID - arg name
										//				s: ChangeType - argument type annotations for the called method
										//					input: PermType - needed type for this arg
										//					output: PermType - output type for this arg
										//			s: Pair
										//				f: PermType - start type for this argument from context
										//				s: PermType - residue after splitting needed type from start type
										//  >
										// to access the different fields given an element of this list, a:
										//		ID = a.fst.fst;
										//  	startType = a.snd.fst;
										//		neededType = a.fst.snd.input;
										//		residueType = a.snd.snd;
										//		outputType = a.fst.snd.output;
										val /*List<Pair<Pair<ID,ChangeType>>,Pair<PermType,PermType>>>*/ preCall = argIDtypes.zip(startAndResidues);
										val /*list<PermType>*/ endTypes = preCall.map(fn (p) => {
											
											//collect arg information
											val /*ID*/ argID = p.fst.fst;
											val /*PermType*/ aTypeStart = p.snd.fst;
											val /*PermType*/ aTypeOutput = p.fst.snd.output;
											val /*PermType*/ aTypeResidue = p.snd.snd; //this.context.remove(argID); //guaranteed since already found it
											
											//attempt to join back the arg
											var /*Option PermType*/ aTypeEnd = NONE;
											ifElse (aTypeStart.borrowed) {
												//must be able to join residue and output to original type
												aTypeEnd = aTypeOutput.joinTo(aTypeResidue, aTypeStart); //joinTo returns Option Permtype
											} {
												aTypeEnd = createSome(aTypeOutput.join(aTypeResidue)); //join returns PermType
											};
											match (aTypeEnd) {
												case Some {
													this.context.put(argID,aTypeEnd.value); //put joined type into the context for use afterwards
													aTypeEnd.value;
												
												}
												case None {
													val msg = "Could not join back to borrowed Permission for arg " + argID.name;
													typeError(node, msg, true);
													java.lang.System.out.println("TYPECHECK FAILED: " + msg);
													argOk = false;
													this.typedAs = NONE;
													NONE;
												}
											}
										});
										
										ifElse(argsOk) { //args checkout fully  = success
											
											//success - now to construct split/join nodes to surround Application
											java.lang.System.out.println("Application typechecked!");		
													
											//0) typechecker return value
											val /*PermType*/ returnType = lType.returnType;
											this.typedAs = createSome(returnType); //return type is the actual type
	
											//1) create string of split and a string of join nodes for arguments
													
											//1a) zip up info gathered about arguments
											val /*List<Pair<Pair<PermType,PermType>,PermType>>*/ sre = startAndResidues.zip(endTypes);
											val /*List<Pair<Pair<ID,ChangeType>,Pair<Pair<PermType,PermType>,PermType>>>*/ argTypeInfo = argIDtypes.zip(sre);
											//strcuture of argTypeInfo is as follows:
											//	List<
											//		Pair
											//			f: Pair
											//				f: ID - arg name
											//				s: ChangeType - argument type annotations for the called method
											//					input: PermType - needed type for this arg
											//					output: PermType - output type for this arg
											//			s: Pair
											//				f: Pair
											//					f: PermType - start type for this argument from context
											//					s: PermType - residue after splitting needed type from start type
											//				s: PermType - end type after method call and joining
											//  >
											// to access the different fields given an element of this list, a:
											//		ID = a.fst.fst;
											//  	startType = a.snd.fst.fst;
											//		neededType = a.fst.snd.input;
											//		residueType = a.snd.fst.snd;
											//		outputType = a.fst.snd.output;
											//		endType = a.snd.snd; 
											var splitHead = new None;
											var splitTail = splitHead;
											var joinHead = new None;
											var joinTail = joinHead;
													
											//1b) create split/join nodes for arguments
											argTypeInfo.map(fn(argInfo) => {
												//create split
												splitTail <- Split {
													val /*ID*/ theVar = argInfo.fst.fst.copy();
													val /*PermType*/ initialType = argInfo.snd.fst.fst;
													val /*PermType*/ neededType = argInfo.fst.snd.input;
													val /*PermType*/ residue = argInfo.snd.fst.snd;
													val /*Expression*/ body = new None;
													override val /*PermType*/ type = returnType;
												};
												splitTail = splitTail.body;
														
												//create join
												joinHead = new Join {
													val /*ID*/ theVar = argInfo.fst.fst.copy();
													val /*PermType*/ toJoin1 = argInfo.snd.fst.snd;
													val /*PermType*/ toJoin2 = argInfo.fst.snd.output;
													val /*PermType*/ result = argInfo.snd.snd;
													val /*Expression*/ body = joinHead;
													override val /*PermType*/ type = returnType;
												};
														
												//add needed type to argument ID
												argInfo.fst.fst.type <- PermType {
													val perm = argInfo.fst.snd.input.perm;
													val type = argInfo.fst.snd.input.type;
													val borrowed = argInfo.fst.snd.input.borrowed;
												}
											}); 
													
											//2) create the letbinding of application at end of the list of splits
											// and have the body be the list of joins
													
											//2a) gather info and types for new method call node
											val t = this.generateID(node.token); //ID bound by let

											val fIDapp = node.f.copy(); //add type to ID node for function
											fIDapp.type <- PermType {
												val perm = functionType.perm;
												val type = lType;
												val borrowed = functionType.borrowed;
											};
											//already have a copy of the argument ids with types added
													
											//2b) transition splitTail to let binding
											splitTail <- UnannotatedLetBinding {
												val /*Option Token*/ token = node.token;
												val /*ID*/ x = t.copy();
												val /*Expression*/ exp = new Application { //will need to state change this later
													val /*Expression*/ f = fIDapp;
													val /*Expression*/ arguments = arguments;
													val /*Option Token*/ token = node.token;	
													override val /*PermType*/ type = returnType;
												};	
												val /*boolean*/ mutable = false;
												val /*Expression*/ body = joinHead;
												override val /*PermType*/ type = returnType;
											};
											
											//3) insert the chain into the AST by transitioning existing application node
													
											//3a) transition node to split from top of chain
											node <- Split {
												val /*ID*/ theVar = splitHead.theVar;
												val /*PermType*/ initialType = splitHead.initialType;
												val /*PermType*/ neededType = splitHead.neededType;
												val /*PermType*/ residue = splitHead.residue;
												val /*Expression*/ body = splitHead.body;
												override val /*PermType*/ type = splitHead.type;
											};
											
											//3b) transition joinTail to the bound variable for the application
											joinTail <- ID {
												val /*Token*/ token = t.token;
												val /*String*/ name = t.name;
												override val /*PermType*/ type = returnType;
											}
												
										} {
											//arg typechecking failed - error elsewhere
											//java.lang.System.out.println("TYPECHECK FAILED: failed Here?");
										}
									} {
										//arg typechecking failed - error elsewhere
										//java.lang.System.out.println("TYPECHECK FAILED: failed Here?");
									}
								} {
									val msg = "Application does not have the right nubmer of parameters";
									typeError(node, msg, true);
									java.lang.System.out.println("TYPECHECK FAILED: " + msg);
									this.typedAs = NONE;
								}
							} { //else just add function type to application's function ID node
								node.f.type <- PermType {
									val perm = functionType.perm;
									val type = lType;
									val borrowed = functionType.borrowed;
								};
								java.lang.System.out.println("Application typechecked!");
								this.typedAs = createSome(lType.returnType); //return type is the actual type
								node.type <- PermType {
									val perm = lType.returnType.perm;
									val type = lType.returnType.type;
									val borrowed = lType.returnType.borrowed;
								};
							};
						}	
						default {
							val msg = "variable " + theFunction.name + " does not have a function type";
							typeError(node, msg, true);
							java.lang.System.out.println("TYPECHECK FAILED: " + msg);
							this.typedAs = NONE;
						}
					}
				} {
					val msg = "function " + theFunction.name + " not in context";
					typeError(node, msg, true);
					java.lang.System.out.println("TYPECHECK FAILED: " + msg);
					//this.context.printContext();
					this.typedAs = NONE;
				}
			}
			default { 
				val msg = "Application not in let normal form";
				typeError(node, msg, true);
				java.lang.System.out.println("TYPECHECK FAILED: " + msg);
				this.typedAs = NONE;
			}
		}	
	}

}