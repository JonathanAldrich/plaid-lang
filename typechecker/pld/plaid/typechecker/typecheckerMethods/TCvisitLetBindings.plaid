package plaid.typechecker.typecheckerMethods;

import plaid.typechecker.context.*;
import plaid.ast.types.*;
import plaid.ast.*;

state TCvisitLetBindings {

	//override val /*StateTable*/ stateTable; // need to know about nominal types during typechecking
	//override val /*Context*/ context; //need to keep track of variables and types
	//override var /*Option PermType*/ typedAs;

	//TODO: need bidirectional type system
	override method visitLetBinding(node) {
		//java.lang.System.out.println("Checking Let");
		
		//typecheck the bound expression
		node.exp.accept(this);
		
		
		match (this.typedAs) {
			case Some {
				//update context with newly bound variable (careful of shadowing)
				val /*Option PermType */ oldIDPermType = this.context.getOption(node.x);
				this.context.put(node.x,this.typedAs.value);
				
				//type the body in the updated context
				node.body.accept(this);
				match(this.typedAs) {
					case Some {
						//restore context
						match (oldIDPermType) {
							case Some { this.context.put(node.x,oldIDPermType.value) }
							case None { this.context.remove(node.x) }
						};
						//add type to let binding node
						node.type <- PermType {
							val perm = this.typedAs.value.perm;
							val type = this.typedAs.value.type;
							val borrowed = this.typedAs.value.borrowed;
						};
					}
					case None {
						//typechecking failed elsewhere
						val msg = "let body did not typecheck";
						typeError(node, msg, false);
					}
				}
			}
			case None {
				val msg = "bound variable expression did not typecheck";
				typeError(node, msg, false);
				//typechecking failed elsewhere
			}
		}
	}
	
	//TODO: need bidirectional type system
	override method visitAnnotatedLetBinding(node) {
		//java.lang.System.out.println("Checking Annotated Let");
		//typecheck the bound expression
		node.exp.accept(this);
		
		match (this.typedAs) {
			case Some {
				//check that that actual type is a subtype of the annotated type //TODO: bidirectional instead
				//typedAs.value.subtypeOf(  
				
				//update context with newly bound variable (careful of shadowing)
				val /*Option PermType */ oldIDPermType = this.context.getOption(node.x);
				this.context.put(node.x,this.typedAs.value);
				
				//type the body in the updated context
				node.body.accept(this);
				match(this.typedAs) {
					case Some {
						//restore context
						match (oldIDPermType) {
							case Some { this.context.put(node.x,oldIDPermType.value) }
							case None { this.context.remove(node.x) }
						};
						//add type to let binding node
						node.type <- PermType {
							val perm = this.typedAs.value.perm;
							val type = this.typedAs.value.type;
							val borrowed = this.typedAs.value.borrowed;
						};
					}
					case None {
						val msg = "let body did not typecheck";
						typeError(node, msg, false);
						//typechecking failed elsewhere
					}
				}
			}
			case None {
				val msg = "bound variable expression did not typecheck";
				typeError(node, msg, false);
				//typechecking failed elsewhere
			}
		}
	}

}