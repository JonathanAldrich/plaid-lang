package plaid.typechecker.typecheckerMethods;

import plaid.typechecker.context.*;
import plaid.ast.types.*;
import plaid.ast.*;

state TCvisitID {
	
	//override val /*StateTable*/ stateTable; // need to know about nominal types during typechecking
	//override val /*Context*/ context; //need to keep track of variables and types
	//override var /*Option PermType*/ typedAs;

	override method visitID(node) {
		ifElse (this.context.containsKey(node)) {
			var /*PermType*/ idType = this.context.remove(node);
			var /*Option PermType*/ residue = NONE;
			match (this.synthesizeType) {
				case Some {
					residue = idType.splitPerm(this.synthesizeType.value, this.stateTable);
					match (residue) {
						case Some {
							//success
							idType = this.synthesizeType.value; //take the required type as the type
							if (node.isTemp) { residue = NONE } //if a temp var, drop residue on the floor
						}
						case None {
							val /*String*/ msg = "could not split " + node.name + " to required type";
							typeError(node,msg,true);
							java.lang.System.out.println("TYPECHECK FAILED: " + msg);
						}
					}
				}
				case None { 
					if (!(node.isTemp)) { //if this is not a temporary variable, put a residue back (temp variables will always be used only once)
						residue = createSome(idType.residue(this.stateTable));
					};
				}
			};
			
			//if there is a residue to put back in the context, do so
			match(residue) {
				case Some { //put residue back in the context
					this.context.put(node, residue.value);
				}
				case None {
					//do nothing - 
				}	
			};
			
			this.typedAs = createSome(idType);
			node.type <- PermType {
				val /*Permission*/ perm = idType.perm;
				val /*Type*/ type = idType.type;
				val /*boolean*/ borrowed = idType.borrowed;
			};
		} {
			val msg = node.name + " not found in the context";
			typeError(node, msg, true);
			java.lang.System.out.println("TYPECHECK FAILED: " + msg);
			this.typedAs = NONE;
		}	
		
	}
}