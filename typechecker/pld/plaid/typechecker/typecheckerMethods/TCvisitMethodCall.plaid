package plaid.typechecker.typecheckerMethods;

import plaid.typechecker.context.*;
import plaid.ast.types.*;
import plaid.ast.*;

state TCvisitMethodCall {
	
	//override val /*StateTable*/ stateTable; // need to know about nominal types during typechecking
	//override val /*Context*/ context; //need to keep track of variables and types
	//override var /*Option PermType*/ typedAs;
	
	override method visitMethodCall(node) {
		//steps:
		//1) find type of receiver in context (in let normal form, receiver will be an ID
		//2) find type of method on receiver
		//3) verify that receiver's type in context allows method call (initial type)
		//	a) add split and join nodes
		//4) verify that arg's type in context allows method call (if arg needed)
		//	a) add split and join nodes
		//5) update context
		
		match (node.receiver) {
			case ID { 
				val /*ID*/ theReceiver = node.receiver;
				ifElse ( this.context.containsKey(theReceiver)) {
					val /*PermType*/ tTypeStart = this.context.remove(theReceiver); //TODO: need multi set?
					match ( tTypeStart.type ) {
						case NominalType {
							val /*Option StateType*/stType = this.stateTable.get(tTypeStart.type.typeName);
							match(stType) {
								case Some {
									val /*Option DeclType*/ declType = stType.value.declaredTypeOf(node.methodName);
									match (declType) {
										case Some {
											match (declType.value) {
												case MethodType {
													ifElse (tTypeStart.type.unpacked) {
														val msg = "cannot call methods on unpacked objects";
														typeError(node, msg, true);
														java.lang.System.out.println("TYPECHECK FAILED: " + msg);
														this.typedAs = NONE;
													} {
														//method call goes through a bit of a transformation which we start building here
														//Overall:
														// MethodCall becomes:
														//
														// Split(receiver) in
														// [Split(args)] in
														// let temp = MethodCall in
														// [Join(args)] in
														// Join(receiver) in 
														// temp
														//
														// We start wit the let binding, surround it with
														// the split/join for the args if needed,
														// and then transition the original method call
														// to the split for the receiver and set the body
														// of the let (or join if there are args) to the
														// receiver split
														
														
	
														//pull out type for receiver
														val /*PermType*/ tTypeNeeded = declType.value.receiverType.input;
														val /*Option PermType*/ tTypeResidue = tTypeStart.splitPerm(tTypeNeeded, this.stateTable);
														//java.lang.System.out.println("start: " + tTypeStart.toString()); 
														//java.lang.System.out.println("needed: " + tTypeNeeded.toString()); 
														match (tTypeResidue) {
															case Some { 
																//java.lang.System.out.println("residue: " + tTypeResidue.value.toString()); 
																this.context.put(theReceiver, tTypeResidue.value); //put residue back in context in case needed for typing arg, if mulit set, need to be more careful
																
																//check arguments
																val /*List<ID>*/ arguments = node.arguments.map(fn (a) => a.copy()); //list of argument IDs - use later as handle for adding types
																val /*List<ChangeType>*/ argTypes = declType.value.argTypes;
																
																var /*boolean*/ argsOk = arguments.length() == argTypes.length();
																ifElse (argsOk) {
																	
																	//zip up IDs and their typing information
																	val /*List<ID,ChangeType>*/ argIDtypes = arguments.zip(argTypes);
																	
																	//first check the initial types are available
																	val /*List<Pair<PermType,PermType>>*/ startAndResidues = argIDtypes.map(fn (p) => {
																		val argID = p.fst;
																		ifElse(this.context.containsKey(argID)) {
																			val /*PermType*/ aTypeStart = this.context.remove(argID);
																			val /*PermType*/ aTypeNeeded = p.snd.input;
																			
																			//try to pull out necessary type
																			val /*Option PermType*/ aTypeResidue = aTypeStart.splitPerm(aTypeNeeded, this.stateTable);
																			
																			match (aTypeResidue) {
																				case Some{ //split succeeded
																					//this.context.put(argID, aTypeResidue.value); pass around in list instead
																					makePair(aTypeStart,aTypeResidue.value);
																				}
																				case None {
																					val msg = "Could not split needed permission for arg " + argID.name; //TODO: this could be a typechecker argID - do a better job of error reporting
																					typeError(node, msg, true);
																					java.lang.System.out.println("TYPECHECK FAILED: " + msg); 
																					argsOk = false;
																					this.typedAs = NONE;
																					NONE
																				}	
																			}
																		} {
																			val msg = "no permission for ID " + argID.name + " in context";
																			typeError(node, msg, true);
																			java.lang.System.out.println("TYPECHECK FAILED: " + msg);
																			argsOk = false;
																			this.typedAs = NONE;
																			NONE
																		}
																	
																	});
																	
																	ifElse(argsOk) {
																		//next check that we can use the output and residue to join back to the required type
																		//		Pair
																		//			f: Pair
																		//				f: ID - arg name
																		//				s: ChangeType - argument type annotations for the called method
																		//					input: PermType - needed type for this arg
																		//					output: PermType - output type for this arg
																		//			s: Pair
																		//				f: PermType - start type for this argument from context
																		//				s: PermType - residue after splitting needed type from start type
																		//  >
																		// to access the different fields given an element of this list, a:
																		//		ID = a.fst.fst;
																		//  	startType = a.snd.fst;
																		//		neededType = a.fst.snd.input;
																		//		residueType = a.snd.snd;
																		//		outputType = a.fst.snd.output;
																		val /*List<Pair<Pair<ID,ChangeType>>,Pair<PermType,PermType>>>*/ preCall = argIDtypes.zip(startAndResidues);
																		val /*list<PermType>*/ endTypes = preCall.map(fn (p) => {
																			
																			//collect arg information
																			val /*ID*/ argID = p.fst.fst;
																			val /*PermType*/ aTypeStart = p.snd.fst;
																			val /*PermType*/ aTypeOutput = p.fst.snd.output;
																			val /*PermType*/ aTypeResidue = p.snd.snd; //this.context.remove(argID); //guaranteed since already found it
																			
																			//attempt to join back the arg
																			var /*Option PermType*/ aTypeEnd = NONE;
																			ifElse (aTypeStart.borrowed) {
																				//must be able to join residue and output to original type
																				aTypeEnd = aTypeOutput.joinTo(aTypeResidue, aTypeStart, this.stateTable); //joinTo returns Option Permtype
																			} {
																				aTypeEnd = createSome(aTypeOutput.join(aTypeResidue, this.stateTable)); //join returns PermType
																			};
																			match (aTypeEnd) {
																				case Some {
																					this.context.put(argID,aTypeEnd.value); //put joined type into the context for use afterwards
																					aTypeEnd.value;
																					
																				}
																				case None {
																					val msg = "Could not join back to borrowed Permission for arg " + argID.name;
																					typeError(node, msg, true);
																					java.lang.System.out.println("TYPECHECK FAILED: " + msg);
																					argOk = false;
																					this.typedAs = NONE;
																					NONE;
																				}
																			}
																		});
																		
																		ifElse(argsOk) { //args checkout fully, try to join back the receiver
																			//join receiver
																			val /*PermType*/ tTypeOutput = declType.value.receiverType.output;
																			var /*Option PermType*/ tTypeEnd = unit;
																			ifElse (tTypeStart.borrowed) {
																				//must be able to join residue and output to original type
																				tTypeEnd = tTypeOutput.joinTo(tTypeResidue.value, tTypeStart, this.stateTable); //joinTo returns Option PermType
																			} {
																				//if not borrowed, just join the types
																				tTypeEnd = createSome(tTypeOutput.join(tTypeResidue.value, this.stateTable)); //join returns PermType
																			};
																			match (tTypeEnd) {
																				case Some {
																					//success - now to construct split/join nodes to surround method call
																					java.lang.System.out.println("MethodCall typechecked!");
																					
																					
																					//0) clean up context and typechecker return value
																					val /*PermType*/ returnType = declType.value.returnType;
																					this.typedAs = createSome(returnType); //return type is the actual type
																					this.context.remove(theReceiver); //update context with final type for the receiver
																					this.context.put(theReceiver,tTypeEnd.value);
																					
																					//1) create string of split and a string of join nodes for arguments
																					
																					//1a) zip up info gathered about arguments
																					val /*List<Pair<Pair<PermType,PermType>,PermType>>*/ sre = startAndResidues.zip(endTypes);
																					val /*List<Pair<Pair<ID,ChangeType>,Pair<Pair<PermType,PermType>,PermType>>>*/ argTypeInfo = argIDtypes.zip(sre);
																					//strcuture of argTypeInfo is as follows:
																					//	List<
																					//		Pair
																					//			f: Pair
																					//				f: ID - arg name
																					//				s: ChangeType - argument type annotations for the called method
																					//					input: PermType - needed type for this arg
																					//					output: PermType - output type for this arg
																					//			s: Pair
																					//				f: Pair
																					//					f: PermType - start type for this argument from context
																					//					s: PermType - residue after splitting needed type from start type
																					//				s: PermType - end type after method call and joining
																					//  >
																					// to access the different fields given an element of this list, a:
																					//		ID = a.fst.fst;
																					//  	startType = a.snd.fst.fst;
																					//		neededType = a.fst.snd.input;
																					//		residueType = a.snd.fst.snd;
																					//		outputType = a.fst.snd.output;
																					//		endType = a.snd.snd; 
																					var splitHead = new None;
																					var splitTail = splitHead;
																					var joinHead = new None;
																					var joinTail = joinHead;
																					
																					//1b) create split/join nodes for arguments
																					argTypeInfo.map(fn(argInfo) => {
																						//create split
																						splitTail <- Split {
																							val /*ID*/ theVar = argInfo.fst.fst.copy();
																							val /*PermType*/ initialType = argInfo.snd.fst.fst;
																							val /*PermType*/ neededType = argInfo.fst.snd.input;
																							val /*PermType*/ residue = argInfo.snd.fst.snd;
																							val /*Expression*/ body = new None;
																							override val /*PermType*/ type = returnType;
																						};
																						splitTail = splitTail.body;
																						
																						//create join
																						joinHead = new Join {
																							val /*ID*/ theVar = argInfo.fst.fst.copy();
																							val /*PermType*/ toJoin1 = argInfo.snd.fst.snd;
																							val /*PermType*/ toJoin2 = argInfo.fst.snd.output;
																							val /*PermType*/ result = argInfo.snd.snd;
																							val /*Expression*/ body = joinHead;
																							override val /*PermType*/ type = returnType;
																						};
																						
																						//add needed type to argument ID
																						argInfo.fst.fst.type <- PermType {
																							val perm = argInfo.fst.snd.input.perm;
																							val type = argInfo.fst.snd.input.type;
																							val borrowed = argInfo.fst.snd.input.borrowed;
																						}
																					}); 
																					
																					//2) create the letbinding of method call at end of the list of splits
																					// and have the body be the list of joins
																					
																					//2a) gather info and types for new method call node
																					val t = this.generateID(node.token); //ID bound by let
																					val mNameAndType = node.methodName.copy(); //method name with type
																					mNameAndType.type <- MethodType { //TODO: fix type of Expression.type or make IDs vs other nodes different?
																						val /*ID*/ name = declType.value.name.copy();
																						val /*PermType*/ returnType = declType.value.returnType; //TODO: need to deep copy?
																						val /*List<ChangeType>*/ argTypes = declType.value.argTypes;
																						val /*ChangeType*/ receiverType = declType.value.receiverType;
																						val /*Map<ID,ChangeType>*/ environmentTypes = declType.value.environmentTypes;
																					}; 
																					val receiverIDmc = theReceiver.copy(); //ID for the reveiver
																					receiverIDmc.type <- PermType { //add type to receiver node in method call node
																						val perm = tTypeNeeded.perm;
																						val type = tTypeNeeded.type;
																						val borrowed = tTypeNeeded.borrowed;
																					};
																					//already have a copy of the argument ids with types added
																					
																					//2b) transition splitTail to let binding
																					splitTail <- UnannotatedLetBinding {
																						val /*Option Token*/ token = node.token;
																						val /*ID*/ x = t.copy();
																						val /*Expression*/ exp = new MethodCall { //will need to state change this later
																							val /*Expression*/ receiver = receiverIDmc;
																							val /*ID*/ methodName = mNameAndType;
																							val /*List<Expression>*/ arguments = arguments;
																							val /*Option Token*/ token = node.token;	
																							override val /*PermType*/ type = returnType;
																						};	
																						val /*boolean*/ mutable = false;
																						val /*Expression*/ body = joinHead;
																						override val /*PermType*/ type = returnType;
																					};
																					
																					//3) finish by surrounding with split/join for receiver
																					
																					//3a) transition node to a split with the splitHead as the body
																					node <- Split {
																						val /*ID*/ theVar = theReceiver.copy();
																						val /*PermType*/ initialType = tTypeStart;
																						val /*PermType*/ neededType = tTypeNeeded;
																						val /*PermType*/ residue = tTypeResidue.value;
																						val /*Expression*/ body = splitHead;
																						override val /*PermType*/ type = returnType;
																					};
																					
																					//3b) put return type of method call on the variable bound to it for use as body
																					val /*ID*/ finalID = t.copy();
																					finalID.type <- PermType {
																						val perm = returnType.perm;
																						val type = returnType.type;
																						val borrowed = returnType.borrowed;
																					};
																					
																					//3c) transition joinTail to the final join with the bound variable as the body
																					joinTail <- Join {
																						val /*ID*/ theVar = theReceiver.copy();
																						val /*PermType*/ toJoin1 = tTypeResidue.value;
																						val /*PermType*/ toJoin2 = tTypeOutput;
																						val /*PermType*/ result = tTypeEnd.value;
																						val /*Expression*/ body = finalID;
																						override val /*PermType*/ type = returnType;
																					};
																				}
																				case None {
																					val msg = "could not regain borrowed permission";
																					typeError(node, msg, true);
																					java.lang.System.out.println("TYPECHECK FAILED: " + msg);
																					this.typedAs = NONE;
																				}
																			}
																		} {
																			//arg typechecking failed - error elsewhere
																			java.lang.System.out.println("TYPECHECK FAILED: failed Here?");
																		}
																	} {
																		//arg typechecking failed - error elsewhere
																		java.lang.System.out.println("TYPECHECK FAILED: failed Here?");
																	}
																} {
																	val msg = "methodCall does not have the right number of parameters";
																	typeError(node, msg, true);
																	java.lang.System.out.println("TYPECHECK FAILED: " + msg);
																	this.typedAs = NONE;
																}
															}
															case None { 
																val msg = "not enough permission to receiver to call method " + node.methodName.name;
																typeError(node, msg, true);
																java.lang.System.out.println("TYPECHECK FAILED: " + msg);
																this.typedAs = NONE;
															}												
														}
													}
												}
												case FieldType {
													//a field type must be a lambda, in which case, we need to turn it into an application node
													//java.lang.System.out.println("**MC -> App**");
													match (declType.value.permType.type) { // just care about the type itself
														case LambdaType { //need to turn this into a application node instead of a method call and typecheck that instead						
															val /*ID*/ functionID = this.generateID(node.token);
															node <- AnnotatedLetBinding {
																val /*Option Token*/ token = node.token;
																val /*ID*/ x = functionID;
																val /*Expression*/ exp = new Dereference { //receiver.methodName (since this is actually a field)
																	val /*Option Token*/ token = node.token;
																	val /*Expression*/ left = node.receiver;
																	val /*ID*/ right = node.methodName; 
																};
																val /*Expression*/ body = new Application {
																	val /*Option Token*/ token = node.token;
																	val /*Expression*/ f = functionID.copy();
																	val /*Expression*/ arguments = node.arguments;
																};
																val /*boolean*/ mutable = false;
																val /*PermType*/ annotation = declType.value.permType;
															};
															this.context.put(theReceiver, tTypeStart); //shouldn't have taken receiver out of context yet
															node.accept(this);
														}
														default {
															val msg = "method call refers to a field that is not a lambda";
															typeError(node, msg, true);
															java.lang.System.out.println("TYPECHECK FAILED: " + msg);
															this.typedAs = NONE;
														}
													}
												}
												default {
													val msg = "Unsupported decl type for method call";
													typeError(node, msg, true);
													java.lang.System.out.println("TYPECHECK FAILED: " + msg);
													this.typedAs = NONE;
												}
											}
										}
										case None {
											val msg = "Method " + node.methodName.name + 
																		" not defined in state " + stType.value.name.name;
											typeError(node, msg, true);
											java.lang.System.out.println("TYPECHECK FAILED: " + msg);
											this.typedAs = NONE;
										}
									}
								}
								case None {
									val msg = "State " + tTypeStart.type.typeName.name + "not defined";
									typeError(node, msg, true);
									java.lang.System.out.println("TYPECHECK FAILED: ");
									this.typedAs = NONE;
								}
							}
						}
						default {
							val msg = "unsupported receiver type";
							typeError(node, msg, true);
							java.lang.System.out.println("TYPECHECK FAILED: " + msg);
							this.typedAs = NONE;
						}
					}
				} {
					val msg = "No type for receiver " + node.receiver.name;
					typeError(node, msg, true);
					java.lang.System.out.println("TYPECHECK FAILED: " + msg);
					this.typedAs = NONE;
				}
			}
			default { 
				val msg = "Method Call not in let normal form";
				typeError(node, msg, true);
				java.lang.System.out.println("TYPECHECK FAILED: " + msg);
				this.typedAs = NONE;
			}
		}
	}
}