package plaid.typechecker.typecheckerMethods;

import plaid.typechecker.context.*;
import plaid.ast.types.*;
import plaid.ast.*;

state TCvisitMatch {
	
	override val /*StateTable*/ stateTable; // need to know about nominal types during typechecking
	override val /*Context*/ context; //need to keep track of variables and types
	override var /*Option PermType*/ typedAs;
	
	override method visitMatch(node) {
		//this.context.printContext();
		match (node.e) {
			case ID {
				ifElse ( context.containsKey(node.e) ) {
					val /*PermType*/ matchedPermType = context.remove(node.e);
					val /*NominalType*/ matchedType = matchedPermType.type;
					match (matchedType) {
						case NominalType {
							val /*Option StateType*/ matchedST = stateTable.get(matchedType.typeName);
							match (matchedST) {
								case Some {
									val /*List<Option Pair<PermType,Context>>*/ cases = node.caseList.map(fn (theCase) => { //create a list of Pain<Context, returnType>
										var /*Option Context*/ caseContext = NONE;
										//get new context - different for default case
										ifElse (theCase.defaultCase) {
											//for default, just add the original type for the matched ID back to the copied context
											val /*context*/ copiedContext = this.context.copy();
											copiedContext.put(node.e, matchedPermType);
											caseContext = createSome(copiedContext);
										} {
											// for non-defaults, first check that the case is valid
											val qID = new ID { val name = theCase.qi.value.toString(); };
											val /*Option StateType*/ caseST = stateTable.get(qID); //TODO: robust handling of QIs
											match (caseST) {
												case Some {
													ifElse (caseST.value.subtypeOf(matchedST.value, this.stateTable)) {
														val /*context*/ copiedContext = this.context.copy();
														val /*PermType*/ newEType = new PermType {
															val perm = matchedPermType.perm;
															val type = new NominalType { val typeName = qID.copy(); };
															val borrowed = matchedPermType.borrowed;
														}; 
														copiedContext.put(node.e, newEType);
														caseContext = createSome(copiedContext);
													} {
														val msg =  caseST.value.name.name + " not a subtype of " + matchedST.value.name.name;
														typeError(theCase, msg, true);
														java.lang.System.out.println("TYPECHECK FAILED: " + msg);
													}
												}
												case None {
													val msg =  "type " + theCase.qi.value.toString() + " not defined";
													typeError(theCase, msg, true);
													java.lang.System.out.println("TYPECHECK FAILED: " + msg);
												}
											}
										};
										
										var /*Option PermType*/ caseReturn = NONE;
										match (caseContext) { //if we got a context, then use it to typecheck the body of the case
											case Some {
												val caseChecker = typecheckerFactory(caseContext.value,this.stateTable);
												theCase.e.accept(caseChecker);
												match (caseChecker.typedAs) {
													case Some {
														caseReturn = createSome(caseChecker.typedAs.value);
													}
													case None {
														ifElse (theCase.defaultCase) 
															{ 
																val msg = "default case did not typecheck";
																typeError(theCase, msg, false);
																java.lang.System.out.println("TYPECHECK FAILED: " + msg);
															} { 
																val msg =  "case " + theCase.qi.value.toString() + " did not typecheck";
																typeError(theCase, msg, false);
																java.lang.System.out.println("TYPECHECK FAILED: " + msg);
															}
													}
												}
											}
											case None {
												//error printed elsewhere
											}
										};
										
										match (caseReturn) { //return a pair of context and return type wrapped up in an option if succeeded 
											case Some {
												//java.lang.System.out.println("context and return Type ok");
												caseContext.value.remove(node.e); //remove matched var - will be different
												theCase.type <- PermType { //update type of case statement
													val /*Permission*/ perm = caseReturn.value.perm;
													val /*Type*/ type = caseReturn.value.type;
													val /*boolean*/ borrowed = caseReturn.value.borrowed;
												};
												createSome(makePair(caseContext.value,caseReturn.value));
											}
											case None {
												NONE
											}
										};
									});
									
									//Need to harmonize the return types and contexts
									//for now everything has to be the same
									val /*Option Pair<context, PermType>*/ endInfo = cases.foldr(fn (/*Option Pair<Context,PermType>*/ i,/*Option Pair<Context,PermType>*/ z) => {
										match (z) {
											case Some {
												match (i) {
													case Some {
														//first check the contexts
														ifElse (z.value.fst == i.value.fst) {
															//check return types - take the most general of the two
															val /*PermType*/ retOne = z.value.snd;
															val /*PermType*/ retTwo = i.value.snd;
															
															ifElse (retOne.isSubPermTypeOf(retTwo, this.stateTable)) {
																i // i -> retTwo is the most general
															} {
																ifElse ( retTwo.isSubPermTypeOf(retOne, this.stateTable)) {
																	z // z -> retOne is the most general
																} {
																	val msg = "return types not compatible";
																	typeError(node, msg, true);
																	java.lang.System.out.println("TYPECHECK FAILED: " + msg);
																	NONE
																}	
															}
														} {
															val msg = "contexts not equal";
															typeError(node, msg, true);
															java.lang.System.out.println("TYPECHECK FAILED: " + msg);
															NONE
														}
													}
													case None { NONE }
												}
											}
											case None { NONE }
										}
									
									}, cases.head.value); //start for now with first value
									
									match (endInfo) {
										case Some {
											//this <- { override val context = endInfo.value.fst; }; //update context
											this.context.reset(); //Hackish context update
											this.context.addAll(endInfo.value.fst);
											this.context.put(node. e,matchedPermType); //restore type of matched variable
											this.typedAs = createSome(endInfo.value.snd); //set return type;
											java.lang.System.out.println("match typed");
											node.type <- PermType {
												val /*Permission*/ perm = endInfo.value.snd.perm;
												val /*Type*/ type = endInfo.value.snd.type;
												val /*Boolean*/ borrowed = endInfo.value.snd.borrowed;
											};
										}
										case None {
											val msg = "Case clauses not compatible";
											//typeError(node, msg, false);
											java.lang.System.out.println("TYPECHECK FAILED: " + msg);
											this.typedAs = NONE;
										}
									}
								}
								case None {
									val msg = "type " + matchedType.typeName + " not defined";
									typeError(node, msg, true);
									java.lang.System.out.println("TYPECHECK FAILED: " + msg);
									typedAs = NONE;
								}
							}
						}
						default {
							val msg = "much match on object with Nominal Type";
							typeError(node, msg, true);
							java.lang.System.out.println("TYPECHECK FAILED: " + msg);
							typedAs = NONE;
						}
					}
				} {
					val msg = node.e.name + " not in context";
					typeError(node, msg, true);
					java.lang.System.out.println("TYPECHECK FAILED: " + msg);
					typedAs = NONE;
				};
			}
			default {
				val msg = "Match not in let normal form";
				typeError(node, msg, true);
				java.lang.System.out.println("TYPECHECK FAILED: " + msg);
				typedAs = NONE;
			}
		}
	}
}