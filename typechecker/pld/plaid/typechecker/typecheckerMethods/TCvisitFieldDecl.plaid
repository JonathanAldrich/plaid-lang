package plaid.typechecker.typecheckerMethods;

import plaid.typechecker.context.*;
import plaid.ast.types.*;
import plaid.ast.*;

state TCvisitFieldDecl {
	
	//override val /*StateTable*/ stateTable; // need to know about nominal types during typechecking
	//override val /*Context*/ context; //need to keep track of variables and types
	//override var /*Option PermType*/ typedAs;
	
	override method visitFieldDecl(node) {
		java.lang.System.out.println("--typechecking field " + node.f.name);
		ifElse(node.abstractField) {
			this.typedAs = new Some { val value = node.fieldType; }; 
			java.lang.System.out.println("Abstract field " + node.f.name + " typechecked!");
		} {
			//for lambdas, allow recursive references
			match (node.e) {
				case Lambda {
					node.e.recursiveName = createSome(node.f.copy())
				}
				default { }
			};
			
			// field declarations should be typed in the incoming context
			val ftype = node.fieldType;
			val fST = this.stateTable;
			node.e.accept(this);
			
			match (this.typedAs) {
				case Some { 
					ifElse (this.typedAs.value.isSubPermTypeOf(ftype.permType, this.stateTable) ) { 
						this.typedAs = createSome(ftype); 
						java.lang.System.out.println("field " + node.f.name + " typechecked!");
					} { 
						val msg = "initializer type wrong";
						typeError(node,msg,true);
						this.typedAs = NONE; 
						java.lang.System.out.println("TYPECHECK FAILED: " + msg);
						
					};
				}
				case None {
					val msg = "typecheck of initializer failed";
					typeError(node,msg,false);
					this.typedAs = NONE;
					//java.lang.System.out.println("TYPECHECK FAILED: ");
				}	
			}
		}	
	}

}