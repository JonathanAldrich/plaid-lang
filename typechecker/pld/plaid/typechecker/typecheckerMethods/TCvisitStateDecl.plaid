package plaid.typechecker.typecheckerMethods;

import plaid.typechecker.context.*;
import plaid.ast.types.*;
import plaid.ast.*;

state TCvisitStateDecl {
	
	//override val /*StateTable*/ stateTable; // need to know about nominal types during typechecking
	//override val /*Context*/ context; //need to keep track of variables and types
	//override var /*Option PermType*/ typedAs;

	override method visitStateDecl(node) {
		//our initial implementation is going to ignore the typing of states
		//and assume that our state table captures them correctly
		//we will type check the declarations in the state, though
		node.stateDef.accept(this);
		match (node.caseOf) {
			case Some { //check that the subtyping relationship is nominally valid
				val /*Option StateType*/ st = this.stateTable.get(node.name);
				val /*ID*/ qID = new ID { val name = node.caseOf.value.toString(); }; //TODO: robust handling of QIs
				val /*Option StateType*/ superST = this.stateTable.get(qID);
				match (st) {
					case Some {
						match (superST) {
							case Some {
								ifElse (st.value.checkCaseOf(superST.value, this.stateTable)) {
									java.lang.System.out.println("success: " + st.value.name.name + " is a case of " + superST.value.name.name);
								} {
									val msg = "state " + node.name.name + " not a subtype of " + qID.name;
									typeError(node, msg, true);
									java.lang.System.out.println("TYPECHECK FAILED: " + msg);
								}
							}
							case None {
								val msg = qID.name + " not declared";
								typeError(node, msg, true);
								java.lang.System.out.println("TYPECHECK FAILED: " + msg);
							}
						}
					}
					case None {
						val msg = node.name.name + " not declared";
						typeError(node, msg, true);
						java.lang.System.out.println("TYPECHECK FAILED: " + msg);
					}
				}
			}
			case None {
				//nothing to do
			}
		}
	}
}