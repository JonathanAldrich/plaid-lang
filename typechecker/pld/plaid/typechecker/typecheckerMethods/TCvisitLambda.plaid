package plaid.typechecker.typecheckerMethods;

import plaid.typechecker.context.*;
import plaid.ast.types.*;
import plaid.ast.*;

state TCvisitLambda {
	
	//override val /*StateTable*/ stateTable; // need to know about nominal types during typechecking
	//override val /*Context*/ context; //need to keep track of variables and types
	//override var /*Option PermType*/ typedAs;
	
	override method visitLambda(node) {
	//similar to methods
		val lContext = this.context.copy(); //TODO: only take environment variables
		val ltype = node.lambdaType;
		
		val /*List<Pair<ID,ChangeType>>*/ argIDtypes = node.arguments.zip(ltype.argTypes); //zip to match IDs and types
		argIDtypes.map(fn (p) => lContext.put(p.fst, getContextType(p.snd)));
		
		
		//TODO: add environment variables
		
		//new typechecker for the lambda body
		val lST = this.stateTable;
		//lContext.printContext();
		val lambdaChecker = typecheckerFactory(lContext, lST);
		node.body.accept(lambdaChecker);
		
		//use return type to set actual return type of the lambda (no way to specify in syntax, so always dyn)
		var /*Boolean*/ retCheck = false;
		match (lambdaChecker.typedAs) {
			case Some {
				retCheck = true;
				ltype.returnType = lambdaChecker.typedAs.value; //TODO: state change not working?
			}
			case None {
				//java.lang.System.out.println("TYPECHECK FAILED: typecheck of body failed");
				val msg = "lambda body did not typecheck";
				typeError(node, msg, false);
			}
			default {
				java.lang.System.out.println(lambdaChecker.typedAs);
			}
		};
		
		//check that arg output types match - equivalent to typed in the context
		//resulted by the method typing, with receiver pulled out
		var /*Boolean*/ argCheck = argIDtypes.foldr(fn (p,v) => {
			p.fst.accept(lambdaChecker);
			match ( lambdaChecker.typedAs) {
				case Some {
					val /*Boolean*/ newArg = lambdaChecker.typedAs.value.isSubPermTypeOf(p.snd.output, this.stateTable);
					if (!newArg) { 
						val msg = "arg Output type wrong";
						typeError(node, msg, true);
						java.lang.System.out.println("TYPECHECK FAILED: " + msg);
					};
					ifElse (v) 
						{ newArg }
						{ false };
				}
				case None {
					//error elsewhere
					false;
				}
			}
		}, true);
		
		if(retCheck && argCheck) {
			this.typedAs = createSome(new PermType {
					val perm = new ImmutablePermission;
					val type = ltype;
					val borrowed = false;
				} 
			);
		}
	}
}