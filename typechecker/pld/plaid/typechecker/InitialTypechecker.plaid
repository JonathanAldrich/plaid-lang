package plaid.typechecker;

import plaid.ast.visitor.ASTVisitor;

//will not have the full set of features that will be implemented eventually

state InitialTypechecker case of ASTVisitor{
	
	val /*StateTable*/ stateTable; // need to know about nominal types during typechecking
	val /*Context*/ context; //need to keep track of variables and types
	var /*Option PermType*/ typedAs = new None;
	
	method visitCompilationUnit(node) {
		//Typechecking a compilation unit involves
		//verifying that each declaration is well formed
		//this includes states, fields, and (top level) methods (TODO: get rid of top level methods)
		node.decls.map(fn (decl) => decl.accept(this));
	}
	
	method visitStateDecl(node) {
		//our initial implementation is going to ignore the typing of states
		//and assume that our state table captures them correctly
	}
	
	method visitMethodDecl(node) {
		//for method Decls we need to verify that the body meets the specification
		//of the method type.  To do this, we create a new Typechecker instance with
		//a new context
		val mContext = new Context;
		val mtype = node.methodType;
		mContext.add(this.getContextType(mtype.receiverType)); //add receiver
		mtype.argTypes.map(fn (at) => mContext.add(this.getContextType(at))); //add args
		mtype.environmentTypes.map(); //TODO: complete method - careful of adding to context - need IDs
		
	}
	
	val getContextType = fn (/*ChangeType*/ ct) => {
		ifElse (ct.borrow) 
			{ new ContextBorrowType { val type = ct.input; } }
			{ new ContextHasType { val type = ct.input; } }
	};
}