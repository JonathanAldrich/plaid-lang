package plaid.typechecker;

import plaid.ast.visitor.LeafVisitor;
import plaid.typechecker.context.*;

//will not have the full set of features that will be implemented eventually

state InitialTypechecker case of LeafVisitor {
	
	val /*StateTable*/ stateTable; // need to know about nominal types during typechecking
	val /*Context*/ context; //need to keep track of variables and types
	var /*Option PermType*/ typedAs = new None;
	
	override method visitCompilationUnit(node) {
		//Typechecking a compilation unit involves
		//verifying that each declaration is well formed
		//this includes states, fields, and (top level) methods (TODO: get rid of top level methods)
		node.decls.map(fn (decl) => decl.accept(this));
	}
	
	override method visitStateDecl(node) {
		//our initial implementation is going to ignore the typing of states
		//and assume that our state table captures them correctly
		//we will type check the declarations in the state, though
		node.stateDef.accept(this);
	}
	
	override method visitFieldDecl(node) {
		// field declarations should be typed in an empty context
		//so type using a new empty context and then check
		//for consistency with the declared type
		java.lang.System.out.println("--typechecking field " + node.f.name);
		val ftype = node.fieldType;
		val fST = this.stateTable;
		ifElse (node.abstractField) 
			{ typedAs = new Some { val value = ftype; } } //abstact fields get declared type
			{
				val fieldChecker = new InitialTypechecker {
					val context = new Context;
					val stateTable = fST; //TODO: do we need to copy this - will it be updated (not now I don't think)
				};
			
				node.e.accept(fieldChecker); //typecheck the field initialization
				
				match (fieldChecker.typedAs) {
					case Some {
						ifElse (fieldChecker.typedAs.value == ftype.permType )
							{ 
								this.typedAs = new Some { val value = ftype; }; 
								java.lang.System.out.println("field " + node.f.name + " typechecked!");
							}
							{ 
								this.typedAs = new None; 
								java.lang.System.out.println("TYPECHECK FAILED: initializer type wrong");
							};
					}
					case None {
						//java.lang.System.out.println("TYPECHECK FAILED: typecheck of initializer failed");
					}	
				}
			};		
	}
	
	override method visitMethodDecl(node) {
		//for method Decls we need to verify that the body meets the specification
		//of the method type.  To do this, we create a new Typechecker instance with
		//a new context
		val mContext = new Context;
		val mtype = node.methodType;
		
		java.lang.System.out.println("--typechecking method " + node.name);
		
		//add receiver
		mContext.put(new ID { val name = "this"; }, getContextType(mtype.receiverType)); 
		
		//add arg if exists
		match (node.arg) {
			case Some {
				mContext.put(node.arg.value, getContextType(mtype.argTypes.head.value));
			}
			default { }
		};
		
		//TODO: add environment variables
		
		//new typechecker for the method body
		val mST = this.stateTable;
		val methodChecker = new InitialTypechecker { 
								val context = mContext;
								val stateTable = mST; //TODO: do we need to copy this - will it be updated (not now I don't think)
							};
		node.body.accept(methodChecker);
		//check that return type matches
		var /*Boolean*/ retCheck = false;
		match (methodChecker.typedAs) {
			case Some {
				retCheck = methodChecker.typedAs.value == mtype.returnType;
				if (!retCheck) { java.lang.System.out.println("return !=  body"); }
			}
			case None {
				//java.lang.System.out.println("TYPECHECK FAILED: typecheck of body failed");
			}
		};
		
		//check that receiver output type matches - equivalent to typed in the context
		//resulted by the method typing
		var /*Boolean*/ thisCheck = false;
		(new ID { val name = "this"; }).accept(methodChecker);
		match (methodChecker.typedAs) {
			case Some {
				thisCheck = methodChecker.typedAs.value == mtype.receiverType.output;
				if (!thisCheck) { java.lang.System.out.println("TYPECHECK FAILED: receiver output wrong"); }
			}
			case None {
				//java.lang.System.out.println("TYPECHECK FAILED: type check of receiver failed");
			}
		};
		
		//check that arg output type matches - equivalent to typed in the context
		//resulted by the method typing, with receiver pulled out
		var /*Boolean*/ argCheck = false;
		match(node.arg) {
			case Some {
				node.arg.value.accept(methodChecker);
				match(methodChecker.typedAs) {
					case Some {
						argCheck = methodChecker.typedAs.value == mtype.argTypes.head.value.output;
						if (!argCheck) { java.lang.System.out.println("TYPECHECK FAILED: arg Output type wrong"); }
					}
					case None {
						//java.lang.System.out.println("TYPECHECK FAILED: type check of arg output failed");
					}
				}
			}
			case None { argCheck = true; }
		};
		
		if(retCheck && thisCheck && argCheck) {
			typedAs = new Some { val value = mtype; };
			java.lang.System.out.println("Method " + node.name + " typechecked!");
		}
	}
	
	//****** Expressions *******
	
	override method visitLambda(node) {
	//similar to methods
		val lContext = new Context;
		val ltype = node.lambdaType;
		
		java.lang.System.out.println("typechecking lambda");
		
		//add arg if exists
		match (node.x) {
			case Some {
				lContext.put(node.x.value, getContextType(ltype.argTypes.head.value));
			}
			default { }
		};
		
		//TODO: add environment variables
		
		//new typechecker for the method body
		val lST = this.stateTable;
		val lambdaChecker = new InitialTypechecker { 
								val context = lContext;
								val stateTable = lST; //TODO: do we need to copy this - will it be updated (not now I don't think)
							};
		node.body.accept(lambdaChecker);
		
		//use return type to set actual return type of the lambda (no way to specify in syntax, so always dyn)
		var /*Boolean*/ retCheck = false;
		match (lambdaChecker.typedAs) {
			case Some {
				retCheck = true;
				ltype.returnType = lambdaChecker.typedAs.value; //TODO: state change not working?
			}
			case None {
				//java.lang.System.out.println("TYPECHECK FAILED: typecheck of body failed");
			}
			default {
				java.lang.System.out.println(lambdaChecker.typedAs);
			}
		};
		
		
		//check that arg output type matches - equivalent to typed in the context
		//resulted by the method typing, with receiver pulled out
		var /*Boolean*/ argCheck = false;
		match(node.x) {
			case Some {
				node.x.value.accept(lambdaChecker);
				match(lambdaChecker.typedAs) {
					case Some {
						argCheck = lambdaChecker.typedAs.value == ltype.argTypes.head.value.output;
						if (!argCheck) { java.lang.System.out.println("TYPECHECK FAILED: arg Output type wrong"); }
					}
					case None {
						//java.lang.System.out.println("TYPECHECK FAILED: type check of arg output failed");
					}
					default {
						java.lang.System.out.println(lambdaChecker.typedAs);
					}
				}
			}
			case None { argCheck = true; }
		};
		
		if(retCheck && argCheck) {
			typedAs = new Some { 
				val value = new PermType {
					val perm = new ImmutablePermission;
					val type = ltype;
					val borrowed = false;
				};  
			};
			java.lang.System.out.println("lambda typechecked!");
		}
	
	}
	
	override method visitID(node) {
		ifElse (context.containsKey(node)) {
			typedAs = createSome(context.remove(node)); //TODO: need type directed ID
		} {
			typedAs = NONE;
		}
	}
	
	override method visitUnitLiteral(node) {
		this.typedAs = new Some { 
			val value = new PermType {
							val perm = new NonePermission;
							val type = new NominalType { val typeName = new ID { val name = "unit";}; };
							val borrowed = false;
						};
		};
	}
	
	override method visitNewInstance(node) {
		match (node.s) {
			case QI {
				val stateID = new ID {val name = node.s.toString(); }; //TODO: fix
				val theState = this.stateTable.get(stateID);
				match (theState) {
					case Some {
						typedAs = new Some { 
							val value = new PermType {
								val perm = new UniquePermission;
								val type = new NominalType { val typeName = stateID; };
								val borrowed = false;
							};
						}
					}
					case None {
						typedAs = new None;
						java.lang.System.out.println("TYPECHECK FAILED: state " + node.s.name + " not defined");
					}
				}
			}
			default {
				java.lang.System.out.println("TYPECHECK FAILED: unsupported state in new expression");
			}
		}
	}
	
	override method visitMethodCall(node) {
		//steps:
		//1) find type of receiver in context (in let normal form, receiver will be an ID
		//2) find type of method on receiver
		//3) verify that receiver's type in context allows method call (initial type)
		//	a) add split and join nodes
		//4) verify that arg's type in context allows method call (if arg needed)
		//	a) add split and join nodes
		//5) update context
		
		match (node.receiver) {
			case ID { 
			val /*ID*/ theReceiver = node.receiver;
				ifElse ( this.context.containsKey(theReceiver)) {
					val /*PermType*/ tTypeStart = this.context.remove(theReceiver); //TODO: need multi set?
					match ( tTypeStart.type ) {
						case NominalType {
							val /*Option StateType*/stType = this.stateTable.get(tTypeStart.type.typeName);
							match(stType) {
								case Some {
									val /*Option DeclType*/ declType = stType.value.declaredTypeOf(node.methodName.name);
									match (declType) {
										case Some {
											match (declType.value) {
												case MethodType {
													
													//method call goes through a bit of a transformation which we start building here
													//Overall:
													// MethodCall becomes:
													//
													// Split(receiver) in
													// [Split(args)] in
													// let temp = MethodCall in
													// [Join(args)] in
													// Join(receiver) in 
													// temp
													//
													// We start wit the let binding, surround it with
													// the split/join for the args if needed,
													// and then transition the original method call
													// to the split for the receiver and set the body
													// of the let (or join if there are args) to the
													// receiver split
													
													// create the letbinding as the start
													val t = new ID { val name = "blatantTemp$plaid"; };
													var /* { val Expression body }*/ callBody = new UnannotatedLetBinding { //Note structural type!
														val /*Token*/ token = NONE;
														val /*ID*/ x = t;
														val /*Expression*/ exp = new MethodCall { //will need to state change this later
															val /*Expression*/ receiver = theReceiver;
															val /*ID*/ methodName = node.methodName;
															val /*Expression*/ argument = node.argument;
															val /*Token*/ callSite = node.callSite;	
														};	
														val /*boolean*/ mutable = false;
														val /*Expression*/ body = new None; //To be filled in //cannot be static version since will change its state
													};

													//pull out type for receiver
													val /*PermType*/ tTypeNeeded = declType.value.receiverType.input;
													val /*Option PermType*/ tTypeResidue = tTypeStart.split(tTypeNeeded);
													//java.lang.System.out.println("start: " + tTypeStart.toString()); 
													//java.lang.System.out.println("needed: " + tTypeNeeded.toString()); 
													match (tTypeResidue) {
														case Some { 
															//java.lang.System.out.println("residue: " + tTypeResidue.value.toString()); 
															this.context.put(theReceiver, tTypeResidue); //put residue back in context in case needed for typing arg, if mulit set, need to be more careful
															
															//TODO: multiple args, env
															var /*boolean*/ argOk = true;
															if (declType.value.hasArg()) { //surround callBody with split/join for args
																val /*ID*/ argID = declType.value.arg.value;
																val /*PermType*/ aTypeStart = this.context.remove(argID);
																val /*PermType*/ aTypeNeeded = declType.value.argType.head.value.input;
																val /*Option PermType*/ aTypeResidue = aTypeStart.split(aTypeNeeded);
																
																match (aTypeResidue) {
																	case Some{ //split succeeded
																		this.context.put(argID, aTypeResidue); //not really necessary now, but will be when more args/env
																		
																		//join arg
																		val /*PermType*/ aTypeOutput = declType.value.argType.head.value.output;
																		var /*Option PermType*/ aTypeEnd = NONE;
																		ifElse (aTypeStart.borrowed) {
																			//must be able to join residue and output to original type
																			aTypeEnd = aTypeOutput.joinTo(aTypeResidue.value, aTypeStart); //joinTo returns Option Permtype
																		} {
																			aTypeEnd = createSome(aTypeOutput.join(aTypeResidue.value)); //join returns PermType
																		};
																		match (aTypeEnd) {
																			case Some{ //arg success - update the callBody
																				//put final arg type in the context
																				this.context.remove(argID);
																				this.context.put(argID,aTypeEnd.value);
																				
																				// put join at end of callBody
																				callBody.body <- Join {
																					val /*ID*/ theVar = argID;
																					val /*PermType*/ toJoin1 = aTypeResidue.value;
																					val /*PermType*/ toJoin2 = aTypeOutput;
																					val /*PermType*/ result = aTypeEnd.value;
																					val /*Expression*/ body = new None; //cannot use static version since want to state change it
																				};
																				// put split in front of callBody
																				callBody = new Split {
																					val /*ID*/ theVar = argID;
																					val /*PermType*/ initialType = aTypeStart;
																					val /*PermType*/ neededType = aTypeNeeded;
																					val /*PermType*/ residue = aTypeResidue.value;
																					val /*Expression*/ body = callBody;
																				}
																				
																			}
																			case None {
																				java.lang.System.out.println("TYPECHECK FAILED: Could not join back to borrowed Permission");
																				argOk = false;
																				this.typedAs = NONE;
																			}
																		}
																	}
																	case None {
																		java.lang.System.out.println("TYPECHECK FAILED: Could not split needed permission for arg"); 
																		argOk = false;
																		this.typedAs = NONE;
																	}
																}
															};
															
															if (argOk) {
																//join receiver
																val /*PermType*/ tTypeOutput = declType.value.receiverType.output;
																var /*Option PermType*/ tTypeEnd = NONE;
																ifElse (tTypeStart.borrowed) {
																	//must be able to join residue and output to original type
																	tTypeEnd = tTypeOutput.joinTo(tTypeResidue.value, tTypeStart); //joinTo returns Option PermType
																} {
																	//if not borrowed, just join the types
																	tTypeEnd = createSome(tTypeOutput.join(tTypeResidue.value)); //join returns PermType
																};
																match (tTypeEnd) {
																	case Some {
																		//typecheck suceeded (I think....)
																		java.lang.System.out.println("Method Call typechecked!");
																		this.typedAs = createSome(declType.value.returnType); //return type is the actual type
																		this.context.remove(theReceiver); //update context with final type for the receiver
																		this.context.put(theReceiver,tTypeEnd.value);
																		
																		//put join at end of callBody and have body be the temporary variable holding method call value
																		callBody.body <- Join {
																			val /*ID*/ theVar = theReceiver;
																			val /*PermType*/ toJoin1 = tTypeResidue.value;
																			val /*PermType*/ toJoin2 = tTypeOutput;
																			val /*PermType*/ result = tTypeEnd.value;
																			val /*Expression*/ body = t;
																		};
																		
																		//transition the node to a Split with callBody as the body
																		node <- Split {
																			val /*ID*/ theVar = theReceiver;
																			val /*PermType*/ initialType = tTypeStart;
																			val /*PermType*/ neededType = tTypeNeeded;
																			val /*PermType*/ residue = tTypeResidue.value;
																			val /*Expression*/ body = callBody;
																		};
																	}
																	case None {
																		java.lang.System.out.println("TYPECHECK FAILED: could not regain borrowed permission");
																		this.typedAs = NONE;
																	}
																}
															}
														}
														case None { 
															java.lang.System.out.println("TYPECHECK FAILED: not enough permission to receiver to call method " + node.methodName.name);
															this.typedAs = NONE;
														}												
													}
												}
												default {
													java.lang.System.out.println("TYPECHECK FAILED: Unsupported decl type for method");
													typedAs = NONE;
												}
											}
										}
										case None {
											java.lang.System.out.println("TYPECHECK FAILED: Method " + node.methodName.name + 
																		" not defined in state " + stType.name.name);
											typedAs = NONE;
										}
									}
								}
								case None {
									java.lang.System.out.println("TYPECHECK FAILED: State " + tType.type.typeName.name + "not defined");
									typedAs = NONE;
								}
							}
						}
						default {
							java.lang.System.out.println("TYPECHECK FAILED: unsupported receiver type");
							typedAs = NONE;
						}
					}
				} {
							java.lang.System.out.println("No type for receiver " + node.receiver.name);
							typedAs = NONE;
				}
			}
			default { 
				java.lang.System.out.println("TYPECHECK FAILED: Method Call not in let normal form");
				typedAs = NONE;
			}
		}
	}
}