/**
 * Copyright (c) 2010 The Plaid Group (see AUTHORS file)
 * 
 * This file is part of Plaid Programming Language.
 *
 * Plaid Programming Language is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 *  Plaid Programming Language is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Plaid Programming Language.  If not, see <http://www.gnu.org/licenses/>.
 */

package plaid.typechecker.lnf;

import plaid.ast.*;
import plaid.typechecker.ast.*;
import plaid.ast.visitor.LeafVisitor;
import plaid.ast.visitor.PrintVisitor;

// TODO:  Making this a case of LeafVisitor saves some code for now but will not typecheck.
state NewLetNormalFormVisitor case of LeafVisitor {
	var immutable Integer counter = 0;
	
	method unique ID generateID(immutable Token >> immutable Token tok) {
		this.counter = this.counter + 1;
		val immutable String n = "LNF$" + this.counter + "$plaid";
		
		new ID {
			val immutable Token token = tok;
			val immutable String name = n;
			override val immutable Boolean isTemp = true;
		};
	}
	
	method /*Pair<Binding, Expression>*/ makeTake(immutable Token token, unique ID >> void x, unique Expression >> void exp, unique Expression >> void body) {
		val unique UnannotatedTakeBinding ret = new UnannotatedTakeBinding {
			val immutable Token token     = token;
			val unique ID x               = x;
			val unique Expression exp     = exp;
			val unique Expression body    = body;
			val immutable Boolean mutable = false;
		};
		
		makePair(ret, body);
	}
	
	method /*Pair<Binding, Expression>*/ makeBorrow(immutable Token token, unique ID >> void x, unique Expression >> void exp, unique Expression >> void body) {
		val unique UnannotatedBorrowBinding ret = new UnannotatedBorrowBinding {
			val immutable Token token     = token;
			val unique ID x               = x;
			val unique Expression exp     = exp;
			val unique Expression body    = body;
			val immutable Boolean mutable = false;
		};
		
		makePair(ret, body);
	}
	
	method /*unique Binding*/ zipBindings(/*List<Pair<Binding, Expression>>*/ list, unique Expression >> void last) {
		match (list.isEmpty()) {
			case True {
				last;
			}
			
			case False {
				val pair    = list.car();
				val binding = pair.first();
				val body    = pair.second();

				val ret = this.zipBindings(list.cdr(), last);

				// TODO:  The old restricted update bug bites again.
				body <- None;
				body <- freeze(ret);
				
				binding;
			}
		};
	}

	//
	// VISIT METHODS
	//
	
	override method /*Pair<Binding, Expression>*/ visitID(immutable ID node) {
		val unique ID id = this.generateID(node.token);
		this.makeTake(node.token, id, node.copy(), id.copy());
	}
	
	override method /*Pair<Binding, Expression>*/ visitDereference(immutable Dereference node) {
		val unique ID id = this.generateID(node.token);
		
		match (node.left) {
			case ID {
				this.makeBorrow(node.token, id, node.copy(), id.copy());
			}
			
			default {
				val /*Pair<Binding, Expression>*/ left = node.left.accept(this);
				
				val unique Dereference deref = new Dereference {
                	val immutable Token token  = node.token;
                	val unique Expression left = left.second().copy();
                	val unique ID right        = node.right.copy();
				};
				
				left.second() <- UnannotatedBorrowBinding {
					val immutable Token token     = node.token;
					val unique ID x               = id;
					val unique Expression exp     = deref;
					val unique Expression body    = id.copy();
					val immutable Boolean mutable = false;
				};
		
				left;
			}
		};
	}

	override method /*Pair<Binding, Expression>*/ visitDestructiveDereference(immutable DestructiveDereference node) {
		val unique ID id = this.generateID(node.token);
		
		match (node.left) {
			case ID {
				val unique Dereference deref = new Dereference {
                	val immutable Token token  = node.token;
                	val unique Expression left = node.left.copy();
                	val unique ID right        = node.right.copy();
				};
				
				this.makeTake(node.token, id, deref, id.copy());
			}
			
			default {
				val /*Pair<Binding, Expression>*/ left = node.left.accept(this);
				
				left.second() <- Dereference {
                	val immutable Token token  = node.token;
                	val unique Expression left = left.second().copy();
                	val unique ID right        = node.right.copy();
				};
				
				this.makeTake(node.token, id, left.first(), id.copy());
			}
		};
	}

	override method /*Pair<Binding, Expression>*/ visitMethodCall(immutable MethodCall node) {
		var unique ID receiverID = new ID;
		val /*List<Pair<UnannotatedBinding, Expression>>*/ bindings = makeEmptyList();
		
		match (node.receiver) {
			case ID {
				receiverID = node.receiver.copy(); 
			}
			
			default {
				val /*Pair<Binding, Expression>*/ newReceiver = node.receiver.accept(this);
				receiverID = newReceiver.second().copy();
				bindings.add(newReceiver);
			}
		};
		
		val /*List<ID>*/ argIDs = makeEmptyList();
		
		node.arguments.map(fn (arg) => {
			match (arg) {
				case ID {
					argIDs.add(arg.copy());
				}
				
				default {
					val /*Pair<Binding, Expression>*/ newArg = arg.accept(this);
					
					argIDs.add(newArg.second().copy());
					bindings.add(newArg);
				}
			};
		});
		
		
		val unique ID id = this.generateID(node.token);
		
		match (bindings.isEmpty()) {
			case True {
				// lnf-call-bare
				
				this.makeTake(node.token, id, node.copy(), id.copy());
			}
			
			case False {
				val unique MethodCall methodCall = new MethodCall {
					val unique Expression receiver     = receiverID;
					val unique ID methodName           = node.methodName.copy();
					val /*List<Expression>*/ arguments = argIDs;
					val immutable Token token          = node.token;
				};
				
				val unique Binding zipped = this.zipBindings(bindings, methodCall);
				this.makeTake(node.token, id, zipped, id.copy());
			}
		};
	}

	override method /*Pair<Binding, Expression>*/ visitApplication(immutable Application node) {
		var unique ID fID = new ID;
		val /*List<Pair<UnannotatedBinding, Expression>>*/ bindings = makeEmptyList();
		
		match (node.f) {
			case ID {
				fID = node.f.copy(); 
			}
			
			default {
				val /*Pair<Binding, Expression>*/ newF = node.f.accept(this);
				fID = newF.second().copy();
				bindings.add(newF);
			}
		};
		
		val /*List<ID>*/ argIDs = makeEmptyList();
		
		node.arguments.map(fn (arg) => {
			match (arg) {
				case ID {
					argIDs.add(arg.copy());
				}
				
				default {
					val /*Pair<Binding, Expression>*/ newArg = arg.accept(this);
					
					argIDs.add(newArg.second().copy());
					bindings.add(newArg);
				}
			};
		});
		
		
		val unique ID id = this.generateID(node.token);
		
		match (bindings.isEmpty()) {
			case True {
				// lnf-call-bare
				
				this.makeTake(node.token, id, node.copy(), id.copy());
			}
			
			case False {
				val unique Application newApp = new Application {
					val immutable Token token          = node.token;
					val unique Expression f            = fID;
					val /*List<Expression>*/ arguments = argIDs;
				};
				
				val unique Binding zipped = this.zipBindings(bindings, newApp);
				this.makeTake(node.token, id, zipped, id.copy());
			}
		};
	}
	
	override method /*Pair<Binding, Expression>*/ visitAssignment(immutable Assignment node) {
		var unique ID targetID = new ID;
		var unique ID valueID = new ID;
		val /*List<Pair<UnannotatedBinding, Expression>>*/ bindings = makeEmptyList();
		
		// Writes to local variables are currently handled by Assignment nodes where target is None.
		// This might be subject to change...
		match (node.target) {
			case None {
			}
			
			case Some {
				val unique Expression realTarget = node.target.value;
				
				match (realTarget) {
					case ID {
						targetID = realTarget.copy();
					}
					
					default {
						val /*Pair<Binding, Expression>*/ newTarget = realTarget.accept(this);
						
						targetID = newTarget.second().copy();
						bindings.add(newTarget);
					}
				};
			}
		};
		
		match (node.value) {
			case ID {
				valueID = node.value.copy();
			}
			
			default {
				val /*Pair<Binding, Expression>*/ newValue = node.value.accept(this);
				
				valueID = newValue.second().copy();
				bindings.add(newValue);
			}
		};

		val unique ID id = this.generateID(node.token);
		
		match (bindings.isEmpty()) {
			case True {
				// lnf-assign-bare
				
				this.makeTake(node.token, id, node.copy(), id.copy());
			}
			
			case False {
				val unique Assignment newAssign = new Assignment {
					var immutable Token token          = node.token;
					var /*Option Expression*/ target   = createSome(targetID);
					var unique ID field                = node.field.copy();
					var unique Expression value        = valueID;
				};
				
				val unique Binding zipped = this.zipBindings(bindings, newAssign);
				this.makeTake(node.token, id, zipped, id.copy());
			}
		};
	}
	
	override method /*Pair<Binding, Expression>*/ visitMatch(immutable Match node) {
		val /*List<Case>*/ newCaseList = node.caseList.map(fn (immutable Case c) => {
			new Case {
				val immutable Token token         = c.token;
				val /*Option QI*/ qi              = match (c.qi) { case Some { createSome(c.qi.value.copy()); } case None { new None; } };
				val /*Option ID*/ x               = match (c.x)  { case Some { createSome(c.x.value.copy());  } case None { new None; } };
				val /*Expression*/ e              = c.e.accept(this).first();
				val immutable Boolean defaultCase = c.defaultCase;
				val immutable Boolean boundVar    = c.boundVar;
			};
		});
		
		val unique ID id = this.generateID(node.token);
		
		match (node.e) {
			case ID {
				val unique Match m = new Match {
					val immutable Token token   = node.token;
					val unique Expression e     = node.e.copy();
					val /*List<Case>*/ caseList = newCaseList;
				};
				
				this.makeTake(node.token, id, m, id.copy());
			}
			
			default {
				val /*Pair<Binding, Expression>*/ p = node.e.accept(this);
				
				val unique Match m = new Match {
					val immutable Token token   = node.token;
					val unique Expression e     = p.second().copy();
					val /*List<Case>*/ caseList = newCaseList;
				};				
				
				val /*List<Pair<Binding, Expression>>*/ bindings = makeEmptyList();
				bindings.add(p);
				
				val /*List<Pair<Binding, Expression>>*/ t = this.makeTake(node.token, id, m, id.copy());
				makePair(this.zipBindings(bindings, t.first()), t.second());
			}
		};		
	}
	
	override method /*Pair<Binding, Expression>*/ visitLambda(immutable Lambda node) {
		val /*Pair<Binding, Expression>*/ p = node.body.accept(this);
		
		val unique Lambda newLambda = new Lambda {
			val immutable Token token           = node.token;
			val /*List<ID>*/ arguments          = node.arguments;
			val unique Expression body          = p.first();
			val immutable LambdaType lambdaType = node.lambdaType;
			var /*Option ID*/ recursiveName     = match (node.recursiveName) { case Some { createSome(node.recursiveName.value.copy()); } case None { new None; } };
		};
		
		val unique ID id = this.generateID(node.token);
		this.makeTake(node.token, id, newLambda, id.copy());
	}

	override method /*Pair<Binding, Expression>*/ visitLetBinding(immutable LetBinding node) {
		var /*Pair<Binding, Expression>*/ ret = makePair(new None, new None);
		
		match (node.exp) {
			case ID {
				// lnf-let-bare
				
				val /*Pair<Binding, Expression>*/ p = node.body.accept(this);
				ret = this.makeBorrow(node.token, node.x.copy(), node.exp.copy(), p.first());
			}
			
			case Dereference {
				match (node.exp.left) {
					case ID {
						// lnf-let-read1
				
						val /*Pair<Binding, Expression>*/ p = node.body.accept(this);
						ret = this.makeBorrow(node.token, node.x.copy(), node.exp.copy(), p.first());				
					}
					
					default {
						// lnf-let-read2
						
						val /*Pair<Binding, Expression>*/ p1 = node.exp.left.accept(this);
						val /*Pair<Binding, Expression>*/ p2 = node.body.accept(this);
						
						val unique Dereference newDeref = new Dereference {
		                	val immutable Token token  = node.token;
		                	val unique Expression left = p1.second().copy();
		                	val unique ID right        = node.exp.right.copy();
						};
						
						val /*List<Pair<Binding, Expression>>*/ l = makeEmptyList();
						l.add(p1);
						
						val /*Pair<Binding, Expression>*/ b  = this.makeBorrow(node.token, node.x.copy(), newDeref, p2.first());
						ret = makePair(this.zipBindings(l, b.first()), b.second());
					}
				};
			}
			
			default {
				val /*Pair<Binding, Expression>*/ p1 = node.exp.accept(this);
				val /*Pair<Binding, Expression>*/ p2 = node.body.accept(this);
				
				val /*List<Pair<Binding, Expression>>*/ l = makeEmptyList();
				l.add(p1);
				
				val /*Pair<Binding, Expression>*/ b  = this.makeBorrow(node.token, node.x.copy(), p1.second().copy(), p2.first());
				ret = makePair(this.zipBindings(l, b.first()), b.second());
			}
		};
		
		ret;
	}
	
	override method /*Pair<Binding, Expression>*/ visitAnnotatedLetBinding(immutable AnnotatedLetBinding node) {
		// TODO:  This won't typecheck but saves a lot of duplicate code for now.
		this.visitLetBinding(node);
	}
	
	override method /*Pair<Binding, Expression>*/ visitNewInstance(immutable NewInstance node) {
		// TODO:  For now, we always assume that we have a QI here.
		
		match (node.s.initState) {
			case Some {
				// Collect all FieldDecls.  While visiting, we rewrite the initialization expressions.
				this.collectFields = true;
				this.fieldDecls = makeEmptyList();
				node.s.accept(this);
				this.collectFields = false;
				
				
				val /*List<Binding, Expression>*/ takes = makeEmptyList();
				val unique ID n = this.generateID(node.token);
				
				this.fieldDecls.map(fn (p) => {
					val immutable FieldDecl fd = p.first();
					val /*Pair<Binding, Expression>*/ b = p.second();
					
					val immutable ID f = fd.f;
					val unique Assignment newAssign = new Assignment {
						var immutable Token token          = node.token;
						var /*Option Expression*/ target   = createSome(n.copy());
						var unique ID field                = f.copy();
						var unique Expression value        = b.second().copy();
					};
					
					val dummyList = makeEmptyList();
					dummyList.add(b);
					val unique Expression takeExp = this.zipBindings(dummyList, newAssign);
					
					takes.add(this.makeTake(node.token, f.copy(), takeExp, f.copy()));
				});
				
				val unique NewInstance newNew = new NewInstance {
					val /*Token*/ token = node.token;
					val /*State*/ s = new QI {
						val /*Token*/ token = node.s.token;
						val /*List<String>*/ qid = node.s.qid;
						val /*Option DeclList*/ initState = new None;
					};
				};
				
				this.makeTake(node.token, n.copy(), newNew, this.zipBindings(takes, n.copy()));
			}
			
			default {
				// lnf-new-bare
				val unique ID id = this.generateID(node.token);
				this.makeTake(node.token, id, node.copy(), id.copy());
			}
		};
	}
	
	override method /*Pair<Binding, Expression>*/ visitChangeState(immutable ChangeState node) {
		// TODO:  For now, we always assume that we have a QI here.
		
		match (node.s.initState) {
			case None {
				val unique ID id = this.generateID(node.token);
				
				match (node.e) {
					case ID {
						// lnf-change-bare
						
						this.makeTake(node.token, id, node.copy(), id.copy());
					}
					
					default {
						// lnf-change-C
						
						val /*Pair<Binding, Expression>*/ newE = node.e.accept(this);
						val unique ChangeState newChange = new ChangeState {
							val immutable Token token = node.token;
							val unique Expression e = newE.second().copy();
							val unique State s = node.s.copy();
						};
						
						val dummyList = makeEmptyList();
						dummyList.add(newE);
						this.makeTake(node.token, id, this.zipBindings(dummyList, newChange), id.copy());
					}
				};
			}
			
			case Some {
				var immutable ID targetID = new ID;
				var /*Option Pair<Binding, Expression>*/ binding = new None;
				
				match (node.e) {
					case ID {
						// lnf-change-I
						targetID = node.e;
					}
					
					default {
						// lnf-change-CI
						
						val /*Pair<Binding, Expression>*/ newTarget = node.e.accept(this);
						
						targetID = newTarget.second().copy();
						binding = createSome(newTarget);						
					}
				};
				
				
				
				// Collect all FieldDecls.  While visiting, we rewrite the initialization expressions.
				this.collectFields = true;
				this.fieldDecls = makeEmptyList();
				node.s.accept(this);
				this.collectFields = false;
				
				
				val /*List<Binding, Expression>*/ takes = makeEmptyList();
				val unique ID n = this.generateID(node.token);
				
				this.fieldDecls.map(fn (p) => {
					val immutable FieldDecl fd = p.first();
					val /*Pair<Binding, Expression>*/ b = p.second();
					
					val immutable ID f = fd.f;
					val unique Assignment newAssign = new Assignment {
						var immutable Token token          = node.token;
						var /*Option Expression*/ target   = createSome(targetID.copy());
						var unique ID field                = f.copy();
						var unique Expression value        = b.second().copy();
					};
					
					val dummyList = makeEmptyList();
					dummyList.add(b);
					val unique Expression takeExp = this.zipBindings(dummyList, newAssign);
					
					takes.add(this.makeTake(node.token, f.copy(), takeExp, f.copy()));
				});
				
				val unique ChangeState newChange = new ChangeState {
					val /*Token*/ token = node.token;
					val unique Expression e = targetID.copy();
					val /*State*/ s = new QI {
						val /*Token*/ token = node.s.token;
						val /*List<String>*/ qid = node.s.qid;
						val /*Option DeclList*/ initState = new None;
					};
				};
				
				
				match (binding) {
					case None {
						this.makeTake(node.token, n.copy(), newChange, this.zipBindings(takes, n.copy()));
					}
					
					case Some {
						val dummyList = makeEmptyList();
						dummyList.add(binding.value);
						
						this.makeTake(node.token, n.copy(), this.zipBindings(dummyList, newChange), this.zipBindings(takes, n.copy()));
					}
				};
			}
		};
	}
	
	override method /*Pair<Binding, Expression>*/ visitIntLiteral(immutable IntLiteral node) {
		val unique ID id = this.generateID(node.token);
		
		val unique Binding binding = new UnannotatedLetBinding {
			val immutable Token token     = node.token;
			val immutable ID x            = id;
			val unique Expression exp     = node.copy();
			val unique Expression body    = id.copy();
			val immutable Boolean mutable = false;
		};
		
		makePair(binding, binding.body);
	}

	override method /*Pair<Binding, Expression>*/ visitUnitLiteral(immutable UnitLiteral node) {
		val unique ID id = this.generateID(node.token);
		
		val unique Binding binding = new UnannotatedLetBinding {
			val immutable Token token     = node.token;
			val immutable ID x            = id;
			val unique Expression exp     = node.copy();
			val unique Expression body    = id.copy();
			val immutable Boolean mutable = false;
		};
		
		makePair(binding, binding.body);
	}
	
	
	// NON-EXPRESSION VISIT METHODS

	override method unique CompilationUnit visitCompilationUnit(immutable CompilationUnit node) {
		new CompilationUnit {
			val /*List<Decl>*/ decls         = node.decls.map(fn (decl) => decl.accept(this));
			val /*List<String>*/ packageName = node.packageName;
			val unique ImportList imports    = node.imports.copy();
			val immutable String sourceFile  = node.sourceFile;
		};
	}
	
	override method unique DeclList visitDeclList(immutable DeclList node) {
		new DeclList {
			val immutable Token token = node.token;
			val /*List<Decl>*/ decls = node.decls.map(fn (decl) => decl.accept(this));
		};
	}
	
	var /*List<Pair<FieldDecl, Pair<Binding, Expression>>>*/ fieldDecls = makeEmptyList();
	var immutable Boolean collectFields = false;

	override method unique FieldDecl visitFieldDecl(immutable FieldDecl node) {
		match (this.collectFields) {
			case True {
				val /*Pair<Binding, Expression>*/ rewritten = node.e.accept(this);	
				this.fieldDecls.add(makePair(node, rewritten));
			}
			
			case False {
				new FieldDecl {
					val immutable Token token            = node.token;
					val immutable ID f                   = node.f.copy();
					val unique Expression e              = node.e.accept(this).first();
					val immutable Boolean abstractField  = node.abstractField;
					val immutable Boolean immutableField = node.immutableField;
					val immutable Boolean overrides      = node.overrides;
					val immutable FieldType fieldType    = node.fieldType;
				};
			}
		};
	}

	override method visitMethodDecl(node) {
		new MethodDecl {
			val immutable Token token = node.token;
			val immutable String name = node.name;
			val unique Expression body = node.body.accept(this).first();
			val /*List<ID>*/ arguments = node.arguments;
			val immutable Boolean abstractMethod = node.abstractMethod;
			val immutable Boolean overrides = node.overrides;
			val immutable MethodType methodType = node.methodType;
		};
	}

	override method unique StateDecl visitStateDecl(immutable StateDecl node) {
		new StateDecl {
			val immutable Token token         = node.token;
			val immutable ID name             = node.name;
			val unique State stateDef         = node.stateDef.accept(this).first(); 
			val /*Option QI*/ caseOf          = match (node.caseOf) { case None { new None; } case Some { createSome(node.caseOf.value.copy()); } };
			val immutable Boolean isCaseOf    = node.isCaseOf;
			val immutable StateType stateType = node.stateType;
		};
	}

	override method unique With visitWith(immutable With node) {
		new With {
			val immutable Token token = node.token;
			val unique State s1       = node.s1.accept(this).first(); 
			val unique State s2       = node.s2.accept(this).first();
		};
	}
}
