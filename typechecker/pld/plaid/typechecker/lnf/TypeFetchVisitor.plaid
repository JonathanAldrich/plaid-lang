package plaid.typechecker.lnf;

import plaid.lang.*;
import plaid.ast.visitor.*;
import plaid.ast.*;
import plaid.ast.types.*;
import plaid.ast.types.permissions.*;

/*
 * if node.objectType = errType, it means  the object type for the expression cannot be get because some err
 * if node.objectType = noType, it means the field hasn't been initialized or it is the right ID in a dereference node.
 * TODO: gurantee this been propogate from botton to top
 * TODO: initialize context when entering lambda, method, and state
 * TODO: put basic type into st, put basic stae inot context
 * TODO: consider how to deal with top level method (should it in context? or state)
 */

state TypeFetchVisitor case of ASTVisitor {
	//TODO: initialize them
	val unique StateTable st;
	val unique Context context;
	
	method visitBinding(node) {
		val /*unique Option<immutable ObjectType>*/ expType = node.exp.accept(this);
		match (expType) {
			case ErrObjectType {
				//bound exp Failed
				newObjectError("object Inference of bound expression of binding failed")
			}
			default {
				this.context.put(node.x.copy(), expType);
				val /*unique Option<immutable ObjectType>*/ bodyType = node.body.accept(this);
				match (bodyType) {
					case ErrObjectType {
						//body failed
						newObjectError("object Inference of body of binding failed");
					}
					default {
						//success
						match (node) {
							case NoTypeAnnotation { node.addObjectType(expType) }
							default { /* no op */ }
						};
						this.context.remove(node.x);
						bodyTypeOption.value;
					}
				}
			}

		}
	}
	
	method visitBorrowBinding(node) {
		visitBinding(node)
	}
	
	method visitTakeBinding(node) {
		visitBinding(node)
	}	
			
	method visitAtomicBlock(node) {
		newObjectError("Atomic Block not implemented");
	}

	method visitCase(node) {				
		node.e.accept(this);
	}
	
	method visitChangeState(node) {		
		match (node.e) {
			case ID {
				match (this.context.containsKey(node.e)) {
					case True {
						val /*unique Option<immutable ObjectType>*/ stateType = node.s.accept(this);
						match (stateType) {
							case ErrObjectType {
								//state not supported yet
								newObjectError("Only QIs supported for state change");
							}
							default {
								this.context.update(node.e,stateTypeOption);
								getUnitType();
							}

						}
					}
					case False {
						//ID not in the context
						newObjectError("Target " + node.e.name + " not found in context");
					}
				}				
			}
			default {
				//not in let normal form
				newObjectError("Not in let normal form - target of state change not an ID");
			}
		}
	}
	
	method visitCompilationUnit(node) {		
		node.decls.map(fn (decl) => {
			decl.accept(new TypeFetchVisitor { val st = this.st; val context = new Context; })
		});
	}
	
	method visitDeclList(node) {
		node.decls.map(fn (decl) => {
			decl.accept(new TypeFetchVisitor { val st = this.st; val context = new Context; })
		});
		newObjectError("non Nominal States not implemented");
	}
	
	method visitDereference(node) {
		match (node.left) {
			case ID {
				val /*unique Option<immutable ObjectType>*/ leftTypeOption = this.context.getOption(node.left);
				match (leftTypeOption) {
					case Some {
						val /*unique Option<immutable DeclType>*/ fieldTypeOption 
							= leftTypeOption.value.declaredType(node.right,this.st);
						match( fieldTypeOption) {
							case Some {
								match (fieldTypeOption.value) {
									case FieldType {
										fieldTypeOption.value.getBinding().getObjectType()
									}
									default {
										//not a field
										newObjectError("Member " + node.toString() + " is not a field");
									}
								}
							}
							case None {
								newObjectError("Member " + node.toString() + " does not exist");
							}
						}
					}
					case None {
						//ID not found in context
						newObjectError("Target " + node.left.name + " not found in context");
					}
				}
			}
			default {
				//not in let normal form
				newObjectError("Not in let normal form - target of dereference not an ID");
			}
		}
	}
	
	method visitDestructiveDereference(node) {
		//visitDereference(node);
		newObjectError("Destructive Dereferences not allowed in Internal LNF");
	}
	
	method visitAssignment(node) {
		getUnitType()
	}
	
	method visitQI(node) {
		match (node.initState) {
			case Some { //use this visitor (context) on the initializers 
				node.initState.value.decls.map(fn (decl) => decl.accept(this) );
			}			
			case None {
				/* no op */
			}
		};
		createNominalType(makeID(node.token, node.toShortName()))
	}
	
	method visitDoubleLiteral(node) {
		getDoubleType()
    }
    
	method visitIntLiteral(node) {
		getIntegerType()	
	}
	
	method visitStringLiteral(node) {
		getStringType()
	}
	
	method visitUnitLiteral(node) {
		getUnitType()
	}
	
	method void visitFieldDecl(node) {
		node.e.accept(this);
		unit
	}
	
	method visitGroupDecl(node) {
		newObjectError("Group Decls not implemented");
	}
	
	method visitID(node) {		
		match (this.context.containsKey(node)) {
			case True {
				this.context.get(node);
			}
			case False {
				//ID not in scope
				newObjectError("ID " + node.name + " not in scope");
			}
		}
	}

	method visitMatch(node) {		
		val unique Context oldContext = context.copy();
		val unique Context result = context.copy();
		
		val /*unique Option<immutable ObjectType>*/ matchExpOption = this.context.getOption(node.e);
		match (matchExpOption) {
			case Some {
				val /*List<unique Option<unique Pair<ObjectType,Context>>>*/ casesList = node.caseList.map(fn (c) => {
					val caseContext = this.context.copy();
					
					//update type of matched ID in context
					match (c.qi) {
						case Some {
							//new context so if somehow there are initializers that don't get run, they don't mess up the context
							val /*unique Option<immutable ObjectType>*/ updateType =
								c.qi.value.accept(new TypeFetchVisitor { val st = this.st; val context = new Context; }); 
							match (updateType) {
								case ErrObjectType {
									//do nothing ... doesn't impact execution
								}
								default {
									caseContext.update(node.e.copy(),updateType)
								}
							}
						}
						case None {
							/* default case - no op */
						}
					};
					
					val /*unique Option<immutable ObjectType>*/ expType = 
						c.e.accept(new TypeFetchVisitor { val st = this.st; val context = caseContext; });
					makePair(expType, caseContext)
				});
				
				val seed = casesList.car();
				val casesListCDR = casesList.cdr();
				val outgoingTypeAndContext = casesListCDR.foldl(fn (o,z) => {
					match (z.fst) {
						case ErrObjectType {
							match (o.fst) {
								case ErrObjectType { //add to error string
									makePair(newObjectError("" + o.errorMsg + "\n" + z.errorMsg),z.snd)
								}
								default { //don't add anything - context won't be used
									o
								}
							}
						}
						default {
							match(z.fst == o.fst) { //for now types have to be the same (could do least upper bound too)
								case True {
									val /*unique Option<unique Context>*/ mergedContextOption = 
										z.snd.merge(o.snd,this.st);
									match (mergedContextOption) {
										case Some {
											makePair(z.fst,mergedContextOption.value)
										}
										case None { newObjectError("contexts could not be merged"); }
									}	
								}
								case False { newObjectError("types returned from different cases not equal"); }
							}
						}
					}
				}, seed);
				
				
				match(outgoingTypeAndContext.fst)  {
					case ErrObjectType {
						outgoingTypeAndContext.fst
					}
					default {
						//set context to the merged version from the cases
						this.context.reset();
						this.context.addAll(outgoingTypeAndContextOption.value.snd);
						outgoingTypeAndContextOption.fst // return
					}
				}

			}
			case None { 
				//ID not in scope
				newObjectError("match target not in scope or not in LNF");
			}
		}
	}
	
	method visitMethodCall(node) {
		val /* unique Option<immutable ObjectType> */ receiverTypeOption = this.context.getOption(node.receiver);
		match (receiverTypeOption) {
			case Some {
				val /*unique Option<immutable DeclType> */ methodTypeOption =
					receiverTypeOption.value.declaredType(node.methodName,this.st);
				match (methodTypeOption) {
					case Some {
						val immutable DeclType methodType = methodTypeOption.value; 
						match (node.arguments.length() == methodType.argTypes.length() ) { //redundant?
							case True {
								//TODO: add environment
								val argsAndReceiver = node.arguments.zip(methodType.argTypes);
								argsAndReceiver.prepend(makePair(node.receiver.copy(), methodType.receiverType));
								var immutable Boolean argsOk = true;
								argsAndReceiver.map( fn (p) => {
									match (this.context.containsKey(p.fst)) {
										case True {
											this.context.update(p.fst.copy(), p.snd.outputBinding().getObjectType())
										}
										case False {
											//Error - argument not in scope
											argsOk = false;
										}
									}
								});
								match (argsOk) {
									case True {
										//return the return object type
										methodType.returnType.type.copy()  //return type should probably be a Binding
									}
									case False {
										// arg not in scope
										newObjectError("not all args in LNF and in scope");
									}
								}
							}
							case False {
								//number of args mismatched
								newObjectError("incorrect number of arguments supplied");
							}
						}
					}
					case None {
						//method not found
						newObjectError("method " + node.methodName.name + " not found");
					}
				}
			}
			case None {
				//receiver not in context/not in LNF
				newObjectError("receiver not in LNF or not in scope");
			}
		}
	}
	
	method visitApplication(node) {
		val /* unique Option<immutable ObjectType> */ functionTypeOption = this.context.getOption(node.f);
		match (functionTypeOption) {
			case Some {
				val immutable ObjectType functionType = functionTypeOption.value;
				match (functionType) {
					case LambdaType {
						match (node.arguments.length() == functionType.argTypes.length() ) { //redundant?
							case True {
								//TODO: add environment
								val args = node.arguments.zip(functionType.argTypes);
								var immutable Boolean argsOk = true;
								args.map( fn (p) => {
									match (this.context.containsKey(p.fst)) {
										case True {
											this.context.update(p.fst.copy(), p.snd.outputBinding().getObjectType())
										}
										case False {
											//Error - argument not in scope
											argsOk = false;
										}
									}
								});
								match (argsOk) {
									case True {
										//return the return object type
										match (functionType.returnType) {
											case ObjectType { //TODO : this is hacky
												functionType.returnType.copy() //return type should probably be a Binding
											}
											case PermType {
												functionType.returnType.type.copy() //return type should probably be a Binding
											}
											default {
												newObjectError("bad function return type");
											}
										};
									}
									case False {
										// arg not in scope
										newObjectError("not all args in LNF and in scope");
									}
								}
							}
							case False {
								//number of args mismatched
								newObjectError("incorrect number of arguments supplied");
							}
						}
					}
					default {
						//not a lambda type
						newObjectError("ID " + node.name + " not a lambda");
					}
				}
			}
			case None {
				//receiver not in context/not in LNF
				newObjectError("ID " + node.name + " not a lambda");
			}
		}
	}
	
	method void visitMethodDecl(node) {
		match (node.arguments.length() == node.methodType.argTypes.length() ) { //redundantly checked? 
			case True {
				val methodContext = new Context;
				node.arguments.zip(node.methodType.argTypes).map(fn (p) => {
					methodContext.put(p.fst.copy(), p.snd.inputBinding().getObjectType())
				});
				methodContext.put(makeID(makeToken(),"this"),methodType.receiverType.inputBinding().getObjectType());
				//TODO: add environment
				node.body.accept(new TypeFetchVisitor { val st = this.st; val context = methodContext; })
			}
			case False {
				//error somehow....
			}
		};
		unit //always return void for now
	}
	
	method visitLambda(node) {
		match (node.arguments.length() == node.lambdaType.argTypes.length() ) { //redundantly checked? 
			case True {
				val lambdaContext = new Context;
				node.arguments.zip(node.lambdaType.argTypes).map(fn (p) => {
					lambdaContext.put(p.fst.copy(), p.snd.inputBinding().getObjectType())
				});
				//TODO: add environment
				val /*unique Option<immutable ObjectType>*/ returnType = 
					node.body.accept(new TypeFetchVisitor { val st = this.st; val context = lambdaContext; });
				match (returnType) {
					case ErrObjectType {
						newObjectError("Lambda return type could not be determined: " + returnType.errorMsg);
					}
					default {
						val unique LambdaType newLambdaType = node.lambdaType.copy();
						newLambdaType.returnType = returnType; //make this more elegant in terms of how updated
						node <<- Lambda { //udpate the lambda type for future use - more elegant way?
							val /*Token*/ token = node.token;
							val /*List<ID>*/ arguments = node.arguments;
							val /*Expression*/ body = node.body;
							val /*LambdaType*/ lambdaType = newLambdaType.copy();
							var /*Option ID*/ recursiveName = node.recursiveName;
						};
						newLambdaType;
					}
				}
			}
			case False {
				newObjectError("mismatched number of arguments in lambda");
			}
		};
	}
	
	method visitNewInstance(node) {
		node.s.accept(this) //whatever we get back from the state
	}
	
	method visitSplitBlock(node) {
		newObjectError("Split Block not implemented");
	}
	
	method visitStateDecl(node) {
		node.name.accept(this); //no use
		var oldContext = context.copy();
		
		context.put(makeID(makeToken(), "this$plaid"), createTakeType(IMM, createNominalType(node.name)));	//TODO perm??
		
		var /*Option StateType*/ statetype = st.get(node.name);	//TODO: NOT SURE IF I CAN USE node.stateType directly
		match (statetype) {
			case Some {				
			} 
			default {
				java.lang.System.err("Cannot find State in State Table: " + node.name.toString());
			}
		};
		
		//iterate all the field
		var iter = statetype.value.providedTypes.entrySet().iterator();
		while {iter.hasNext(); } {
			var entry = iter.next();
			val /*ID*/ name = entry.getKey();
			val /*DeclType*/ decltype = entry.getValue();
			match (decltype) {
				case FieldType {					
					val /*ObjectType*/ type = decltype.binding.type;
					context.put(name, createTakeType(IMM, type));	//TODO : add perm	
				}
				case MethodType {
					//TODO, check if method could be use as var x = x.m;  m is a method in x.
				}
			};
		};
					
		node.stateDef.accept(this);
		match (node.caseOf) {
            case plaid.lang.Some {
			    node.caseOf.value.accept(this);
            }
            default {}
		};
//		
//		match (node.stateDef) {
//			case DeclList {
//				node.stateDef.accept(this);
//			}
//			case QI {
//				//inheritQI(node.stateDef);
//			}
//			case With {
//				node.stateDef.accept(this);
//			}
//			default {
//				
//			}
//		};
//				
		context = oldContext;
	}
	
	method visitUnpackInnerGroups(node) {
		java.lang.System.err.println("I don't know how to deal with you");
	}
	
	method visitWith(node) {
		node.s1.accept(this);
		node.s2.accept(this);
		//TODO: add composition
		newObjectError("non Nominal States not implemented");
	}
}