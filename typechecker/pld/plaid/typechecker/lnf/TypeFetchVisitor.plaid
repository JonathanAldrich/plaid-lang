package plaid.typechecker.lnf;

import plaid.lang.*;
import plaid.ast.visitor.*;
import plaid.ast.*;
import plaid.ast.types.*;
import plaid.ast.types.permissions.*;

/*
 * if node.objectType = errType, it means  the object type for the expression cannot be get because some err
 * if node.objectType = noType, it means the field hasn't been initialized or it is the right ID in a dereference node.
 * TODO: gurantee this been propogate from botton to top
 * TODO: initialize context when entering lambda, method, and state
 * TODO: put basic type into st, put basic stae inot context
 * TODO: consider how to deal with top level method (should it in context? or state)
 */

state TypeFetchVisitor case of ASTVisitor {
	//TODO: initialize them
	val unique StateTable st;
	val unique Context context;
	
	method visitBinding(node) {
		val /*unique Option<immutable ObjectType>*/ expTypeOption = node.exp.accept(this);
		match (expTypeOption) {
			case Some {
				val immutable ObjectType expType = expTypeOption.value;
				this.context.put(node.x.copy(), expType);
				val /*unique Option<immutable ObjectType>*/ bodyTypeOption = node.body.accept(this);
				match (bodyTypeOption) {
					case Some {
						//success
						match (node) {
							case NoTypeAnnotation { node.addObjectType(expType) }
							default { /* no op */ }
						};
						this.context.remove(node.x);
						bodyTypeOption.value;
					}
					case None {
						//body failed
						new None;
					}
				}
			}
			case None {
				//Failed
				new None;
			}
		}
	}
	
	method visitBorrowBinding(node) {
		visitBinding(node)
	}
	
	method visitTakeBinding(node) {
		visitBinding(node)
	}	
			
	method visitAtomicBlock(node) {
		java.lang.System.err.println("I don't know how to deal with you");
	}

	method visitCase(node) {				
		node.e.accept(this);
	}
	
	method visitChangeState(node) {		
		match (node.e) {
			case ID {
				match (this.context.containsKey(node.e)) {
					case True {
						val /*unique Option<immutable ObjectType>*/ stateTypeOption = node.s.accept(this);
						match (stateTypeOption) {
							case Some {
								this.context.update(node.e,stateTypeOption.value)
								createSome(getUnitType());
							}
							default {
								//state not supported yet
								new None
							}
						}
					}
					case False {
						//ID not in the context
						new None
					}
				}				
			}
			default {
				//not in let normal form
				new None;
			}
		}
	}
	
	method visitCompilationUnit(node) {		
		node.decls.map(fn (decl) => {
			decl.accept(new TypeFetchVisitor { val st = this.st; val context = new Context; })
		});
	}
	
	method visitDeclList(node) {
		node.decls.map(fn (decl) => {
			decl.accept(new TypeFetchVisitor { val st = this.st; val context = new Context; })
		});
		new None;
	}
	
	method visitDereference(node) {
		match (node.left) {
			case ID {
				val /*unique Option<immutable ObjectType>*/ leftTypeOption = this.context.getOption(node.left);
				match (leftTypeOption) {
					case Some {
						val /*unique Option<immutable DeclType>*/ fieldTypeOption 
							= leftTypeOption.value.declaredType(node.right,this.st);
						match( fieldTypeOption) {
							case Some {
								match (fieldTypeOption.value) {
									case FieldType {
										createSome(fieldTypeOption.value.getBinding().getObjectType())
									}
									default {
										//not a field
										new None
									}
								}
							}
							case None {
								//field not found
								new None
							}
						}
					}
					case None {
						//ID not found in context
						new None
					}
				}
			}
			default {
				//not in let normal form
				new None
			}
		}
	}
	
	method visitDestructiveDereference(node) {
		visitDereference(node);
	}
	
	method visitAssignment(node) {
		createSome(getUnitType())
	}
	
	method visitQI(node) {
		match (node.initState) {
			case Some { //use this visitor (context) on the initializers 
				node.initState.value.decls.map(fn (decl) => decl.accept(this) );
			}			
			case None {
				/* no op */
			}
		};
		createSome(createNominalType(makeID(node.token, node.toShortName())))
	}
	
	method visitDoubleLiteral(node) {
		getDoubleType()
    }
    
	method visitIntLiteral(node) {
		getIntegerType()	
	}
	
	method visitStringLiteral(node) {
		getStringType()
	}
	
	method visitUnitLiteral(node) {
		getUnitType()
	}
	
	method void visitFieldDecl(node) {
		node.e.accept(this);
		unit
	}
	
	method visitGroupDecl(node) {
		java.lang.System.err.println("I don't know how to deal with you");
	}
	
	method visitID(node) {		
		match (this.context.containsKey(node)) {
			case True {
				createSome(this.context.get(node));
			}
			case False {
				//ID not in scope
				new None
			}
		}
	}

	method visitMatch(node) {		
		val unique Context oldContext = context.copy();
		val unique Context result = context.copy();
		
		val /*unique Option<immutable ObjectType>*/ matchExpOption = this.context.getOption(node.e);
		match (matchExpOption) {
			case Some {
				val /*List<unique Option<unique Pair<ObjectType,Context>>>*/ casesOptionList = node.caseList.map(fn (c) => {
					val caseContext = this.context.copy();
					
					//update type of matched ID in context
					match (c.qi) {
						case Some {
							//new context so if somehow there are initializers that don't get run, they don't mess up the context
							val /*unique Option<immutable ObjectType>*/ updateTypeOption =
								c.qi.value.accept(new TypeFetchVisitor { val st = this.st; val context = new Context; }); 
							match (updateTypeOption) {
								case Some {
									caseContext.update(node.e.copy(),updateTypeOption.value)
								}
								case None {
									//error
								}
							}
						}
						case None {
							/* default case - no op */
						}
					};
					
					val /*unique Option<immutable ObjectType>*/ expTypeOption = 
						c.e.accept(new TypeFetchVisitor { val st = this.st; val context = caseContext; });
					match (expTypeOption) {
						case Some {
							createSome(makePair(expTypeOption.value, caseContext))
						}
						case None {
						 	new None
						}
					}
				});
				
				match(casesOptionList.car()) {
					case Some {
						val seed = casesOptionList.car().value;
						val casesOptionListCDR = casesOptionList.cdr();
						val outgoingTypeAndContextOption = casesOptionListCDR.foldl(fn (o,z) => {
							match (z) {
								case Some {
									match(o) {
										case Some {
											match(z.fst == o.fst) { //for now types have to be the same (could do least upper bound too)
												case True {
													val /*unique Option<unique Context>*/ mergedContextOption = 
														z.snd.merge(o.snd,this.st);
													match (mergedContextOption) {
														case Some {
															createSome(makePair(z.fst,mergedContextOption.value))
														}
														case None { new None }
													}	
												}
												case False { new None }
											}
										}
										case None { o }	
									}
								}
								case None { z }
							}
							
						
						}, createSome(seed));
						
						match(outgoingTypeAndContextOption)  {
							case Some {
								//set context to the merged version from the cases
								this.context.reset();
								this.context.addAll(outgoingTypeAndContextOption.value.snd);
								createSome(outgoingTypeAndContextOption.value.fst) // return
							}
							case None { new None }
						}
					}
					case None {
						//case failure
						new None
					}
				}
			}
			case None { 
				//ID not in scope
				new None
			}
		}
	}
	
	method visitMethodCall(node) {
		val /* unique Option<immutable ObjectType> */ receiverTypeOption = this.context.getOption(node.receiver);
		match (receiverTypeOption) {
			case Some {
				val /*unique Option<immutable DeclType> */ methodTypeOption =
					receiverTypeOption.value.declaredType(node.methodName,this.st);
				match (methodTypeOption) {
					case Some {
						val immutable DeclType methodType = methodTypeOption.value; 
						match (node.arguments.length() == methodType.argTypes.length() ) { //redundant?
							case True {
								//TODO: add environment
								val argsAndReceiver = node.arguments.zip(methodType.argTypes);
								argsAndReceiver.prepend(makePair(makeID(makeToken(),"this"), methodType.receiverType));
								var immutable Boolean argsOk = true;
								argsAndReceiver.map( fn (p) => {
									match (this.context.containsKey(p.fst)) {
										case True {
											this.context.update(p.fst.copy(), p.snd.outputBinding().getObjectType())
										}
										case False {
											//Error - argument not in scope
											argsOk = false;
										}
									}
								});
								match (argsOk) {
									case True {
										//return the return object type
										createSome(methodType.returnType.type.copy())  //return type should probably be a Binding
									}
									case False {
										// arg not in scope
										new None
									}
								}
							}
							case False {
								//number of args mismatched
								new None
							}
						}
					}
					case None {
						//method not found
						new None
					}
				}
			}
			case None {
				//receiver not in context/not in LNF
			}
		}
	}
	
	method visitApplication(node) {
		val /* unique Option<immutable ObjectType> */ functionTypeOption = this.context.getOption(node.f);
		match (functionTypeOption) {
			case Some {
				val immutable ObjectType functionType = functionTypeOption.value;
				match (functionType) {
					case LambdaType {
						match (node.arguments.length() == functionType.argTypes.length() ) { //redundant?
							case True {
								//TODO: add environment
								val args = node.arguments.zip(functionType.argTypes);
								var immutable Boolean argsOk = true;
								args.map( fn (p) => {
									match (this.context.containsKey(p.fst)) {
										case True {
											this.context.update(p.fst.copy(), p.snd.outputBinding().getObjectType())
										}
										case False {
											//Error - argument not in scope
											argsOk = false;
										}
									}
								});
								match (argsOk) {
									case True {
										//return the return object type
										match (functionType.returnType) {
											case ObjectType { //TODO : this is hacky
												createSome(functionType.returnType.copy()) //return type should probably be a Binding
											}
											case PermType {
												createSome(functionType.returnType.type.copy()) //return type should probably be a Binding
											}
											default {
												new None
											}
										};
									}
									case False {
										// arg not in scope
										new None
									}
								}
							}
							case False {
								//number of args mismatched
								new None
							}
						}
					
					}
					default {
						//not a lambda type
						new None
					}
				}
			}
			case None {
				//receiver not in context/not in LNF
				new None
			}
		}
	}
	
	method void visitMethodDecl(node) {
		match (node.arguments.length() == node.methodType.argTypes.length() ) { //redundantly checked? 
			case True {
				val methodContext = new Context;
				node.arguments.zip(node.methodType.argTypes).map(fn (p) => {
					methodContext.put(p.fst.copy(), p.snd.inputBinding().getObjectType())
				});
				methodContext.put(makeID(makeToken(),"this"),methodType.receiverType.inputBinding().getObjectType());
				//TODO: add environment
				node.body.accept(new TypeFetchVisitor { val st = this.st; val context = methodContext; })
			}
			case False {
				//error somehow....
			}
		};
		unit //always return void for now
	}
	
	method visitLambda(node) {
		match (node.arguments.length() == node.lambdaType.argTypes.length() ) { //redundantly checked? 
			case True {
				val lambdaContext = new Context;
				node.arguments.zip(node.lambdaType.argTypes).map(fn (p) => {
					lambdaContext.put(p.fst.copy(), p.snd.inputBinding().getObjectType())
				});
				//TODO: add environment
				val /*unique Option<immutable ObjectType>*/ returnTypeOption = 
					node.body.accept(new TypeFetchVisitor { val st = this.st; val context = lambdaContext; });
				match (returnTypeOption) {
					case Some {
						val unique LambdaType newLambdaType = node.lambdaType.copy();
						newLambdaType.returnType = returnTypeOption.value; //make this more elegant in terms of how updated
						node <<- Lambda { //udpate the lambda type for future use - more elegant way?
							val /*Token*/ token = node.token;
							val /*List<ID>*/ arguments = node.arguments;
							val /*Expression*/ body = node.body;
							val /*LambdaType*/ lambdaType = newLambdaType.copy();
							var /*Option ID*/ recursiveName = node.recursiveName;
						};
						createSome(newLambdaType);
					}
					case None {
						//return type could not be determined from body
						new None
					}
				}
			}
			case False {
				new None
			}
		};
	}
	
	method visitNewInstance(node) {
		node.s.accept(this) //whatever we get back from the state
	}
	
	method visitSplitBlock(node) {
		java.lang.System.err.println("I don't know how to deal with you");
	}
	
	method visitStateDecl(node) {
		node.name.accept(this); //no use
		var oldContext = context.copy();
		
		context.put(makeID(makeToken(), "this$plaid"), createTakeType(IMM, createNominalType(node.name)));	//TODO perm??
		
		var /*Option StateType*/ statetype = st.get(node.name);	//TODO: NOT SURE IF I CAN USE node.stateType directly
		match (statetype) {
			case Some {				
			} 
			default {
				java.lang.System.err("Cannot find State in State Table: " + node.name.toString());
			}
		};
		
		//iterate all the field
		var iter = statetype.value.providedTypes.entrySet().iterator();
		while {iter.hasNext(); } {
			var entry = iter.next();
			val /*ID*/ name = entry.getKey();
			val /*DeclType*/ decltype = entry.getValue();
			match (decltype) {
				case FieldType {					
					val /*ObjectType*/ type = decltype.binding.type;
					context.put(name, createTakeType(IMM, type));	//TODO : add perm	
				}
				case MethodType {
					//TODO, check if method could be use as var x = x.m;  m is a method in x.
				}
			};
		};
					
		node.stateDef.accept(this);
		match (node.caseOf) {
            case plaid.lang.Some {
			    node.caseOf.value.accept(this);
            }
            default {}
		};
//		
//		match (node.stateDef) {
//			case DeclList {
//				node.stateDef.accept(this);
//			}
//			case QI {
//				//inheritQI(node.stateDef);
//			}
//			case With {
//				node.stateDef.accept(this);
//			}
//			default {
//				
//			}
//		};
//				
		context = oldContext;
	}
	
	method visitUnpackInnerGroups(node) {
		java.lang.System.err.println("I don't know how to deal with you");
	}
	
	method visitWith(node) {
		node.s1.accept(this);
		node.s2.accept(this);
		//TODO: add composition
		new None;
	}
}