package plaid.typechecker.lnf.tests;

import plaid.ast.*;
import plaid.testing.*;

val () -> void fieldReadTests = fn(unique Tester tester) => {
	var newAst = unit;
	var oldAst = unit;
	var goalAst = unit;
	val unique NewLetNormalFormVisitor lnfVisitor = new NewLetNormalFormVisitor;
	
	
	System.out.println("Testing Dereference transformation");
	testName("lnf-fieldRead-bare");
	oldAst = makeDereference(makeToken(), makeID(makeToken(),"x"), makeID(makeToken(),"f"));
	newAst = oldAst.accept(lnfVisitor).first();
	goalAst = makeBorrow(makeToken(),makeTempID(makeToken(),"t1"),
						 makeDereference(makeToken(), makeID(makeToken(),"x"), makeID(makeToken(),"f")),
					     makeTempID(makeToken(),"t1"), false);
	match (newAst == goalAst) {
		case True {
			tester.testPassed(true);
		}
		case False {
			tester.testPassed(false);
			printErrorASTs(oldAst,newAst,goalAst);
		}
	};
	
	testName("lnf-fieldRead-complex");
	oldAst = makeDereference(makeToken(),
							 makeDereference(makeToken(),makeID(makeToken(),"x"),makeID(makeToken(),"f")),
							 makeID(makeToken(),"g"));
	newAst = oldAst.accept(lnfVisitor).first();
	goalAst = makeBorrow(makeToken(),
						 makeTempID(makeToken(),"t1"),
						 makeDereference(makeToken(),makeID(makeToken(),"x"),makeID(makeToken(),"f")),
						 makeBorrow(makeToken(),
						 			makeTempID(makeToken(),"t2"),
						 			makeDereference(makeToken(), makeTempID(makeToken(),"t1"), makeID(makeToken(),"g")),
					     			makeTempID(makeToken(),"t2"), 
					     			false),
					     false);
	match (newAst == goalAst) {
		case True {
			tester.testPassed(true);
		}
		case False {
			tester.testPassed(false);
			printErrorASTs(oldAst,newAst,goalAst);
		}
	};	
	
	testName("lnf-fieldReadD-bare");
	oldAst = makeDestructiveDereference(makeToken(), makeID(makeToken(),"x"), makeID(makeToken(),"f"));
	newAst = oldAst.accept(lnfVisitor).first();
	goalAst = makeTake(makeToken(),makeTempID(makeToken(),"t1"),
						 makeDereference(makeToken(), makeID(makeToken(),"x"), makeID(makeToken(),"f")),
					     makeTempID(makeToken(),"t1"), false);
	match (newAst == goalAst) {
		case True {
			tester.testPassed(true);
		}
		case False {
			tester.testPassed(false);
			printErrorASTs(oldAst,newAst,goalAst);
		}
	};	
	
	testName("lnf-fieldReadD-complex");
	oldAst = makeDestructiveDereference(makeToken(),
							 makeDereference(makeToken(),makeID(makeToken(),"x"),makeID(makeToken(),"f")),
							 makeID(makeToken(),"g"));
	newAst = oldAst.accept(lnfVisitor).first();
	goalAst = makeTake(makeToken(),
						 makeTempID(makeToken(),"t1"),
						 makeBorrow(makeToken(),
						 			makeTempID(makeToken(),"t2"),
						 			makeDereference(makeToken(), makeID(makeToken(),"x"), makeID(makeToken(),"f")),
					     			makeDereference(makeToken(), makeTempID(makeToken(),"t2"), makeID(makeToken(),"g")), 
					     			false),
						 makeTempID(makeToken(),"t1"),
					     false);
	match (newAst == goalAst) {
		case True {
			tester.testPassed(true);
		}
		case False {
			tester.testPassed(false);
			printErrorASTs(oldAst,newAst,goalAst);
		}
	};		
	
	
	//val unique Dereference nested = makeDereference(makeToken(),makeDereference(makeToken(),makeDereference(makeToken(),makeID(makeToken(),"a"), makeID(makeToken(),"b")), makeID(makeToken(),"c")), makeID(makeToken(),"d"));
	//rewrite(nested);
};