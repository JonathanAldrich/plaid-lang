package plaid.typechecker.lnf.tests;

import plaid.ast.*;
import plaid.ast.types.*;
import plaid.ast.visitor.PrintVisitor;
import plaid.typechecker.lnf.LetNormalFormVisitor;
import plaid.testing.Tester;
import java.lang.System;
import plaid.ast.types.permissions.*;

val (unique Expression) -> void rewrite = fn (unique Expression e) => {
	val unique PrintVisitor printVisitor = new PrintVisitor;
	val unique LetNormalFormVisitor lnfVisitor = new LetNormalFormVisitor;
	
	java.lang.System.out.println("\nREWRITE TEST");
	e.accept(printVisitor);
	java.lang.System.out.println("---------------------");
	val newAst = e.accept(lnfVisitor).first();
	newAst.accept(printVisitor);
};

val printErrorASTs = fn (immutable ASTNode oldAst, immutable ASTNode newAst, immutable ASTNode goalAst) => {
	val unique PrintVisitor printVisitor = new PrintVisitor;
	java.lang.System.out.println("AST: ");
	oldAst.accept(printVisitor);
	java.lang.System.out.println("Translated to: ");
	newAst.accept(printVisitor);
	java.lang.System.out.println("But wanted: ");
	goalAst.accept(printVisitor);
};

//a faster version of createPermType, in order to writing test
//the permission is default immutable
method putPerm(context, id, oType) {
	var tBind =  new TypeBinding;
	tBind.currentType =  createPermType(IMMUTABLE, createNominalType(makeID(makeToken(), oType)));
	context.put(makeID(makeToken(), id), tBind);
}

method putState(stateTable, st) {
	val stId = makeID(makeToken(), st);
	val stType = new StateType { val name = stId; val superType = new None;};
	stateTable.put(stId, stType);
}

//add a field to a state, the field type and the state type should already in stateTable
method addField(stateTable, stStr, fieldStr, fTypeStr) {
	val stType = stateTable.get(makeID(makeToken(), stStr)).value;
	val fType =  stateTable.get(makeID(makeToken(), fTypeStr)).value;
	
	stType.providedTypes.put(makeID(makeToken(), fieldStr), fType);
	stType.declaredTypes.put(makeID(makeToken(), fieldStr), fType);
}

//add a method to a state, and don't use advanced type features
method addMethod(stateTable, stStr, metStr, retTypeStr, argTypesStr) {
	val stType = stateTable.get(makeID(makeToken(), stStr)).value;
	val retType =  stateTable.get(makeID(makeToken(), retTypeStr)).value;

	val args = makeEmptyList();
	
	argTypesStr.map( fn(argTypeStr) => {
		val aType = stateTable.get(makeID(makeToken(), argTypeStr)).value;
		val argType = new ChangeType { val immutable PermType input = aType; val immutable PermType output = aType; };
		args.add(argType);
	});	
	
	val metType = new MethodType { 
		val unique ID name = makeID(makeToken(), metStr); 
		val unique PermType returnType = createPermType(IMMUTABLE, createNominalType(makeID(makeToken(), retTypeStr)));	//now assume only return immutable
		val argTypes = args;
		val environmentTypes = java.util.HashMap.new();	//assume no stuff here
	};
	
	stType.providedTypes.put(makeID(makeToken(), metStr), metType);
	stType.declaredTypes.put(makeID(makeToken(), metStr), metType);
}

method main() {
	val tester = new Tester;
	
	varTests(tester);
	fieldReadTests(tester);
	assignmentTests(tester);
	methodCallTests(tester);
//	appTests(tester);
//	newTests(tester);
//	changeStateTests(tester);
//	matchTests(tester);
//	lambdaTests(tester);
//	letBindingTests(tester);

//	wholeProgramTest("testInputs/fibonacci/package.plaid");
//	wholeProgramTest("testInputs/basicAeminium/package.plaid");
//	wholeProgramTest("testInputs/functionalMergeSort/package.plaid");
	
	System.out.println("");
	tester.printSummary();
	
}