package plaid.typechecker;

import plaid.ast.ASTTranslator;
import plaid.ast.types.*;

state PackageRepTranslator {
	val stateTable;
	val astTranslator = new ASTTranslator;
	
	method translateState(rep) {
		match (rep) {
			case plaid.compilerjava.util.FieldRep {
				ifElse (rep.hasType()) {
					val type = rep.getType();
					
					new FieldType {
						val /*ID*/ name = new ID { val name = rep.getName(); };
						val /*PermType*/ permType = astTranslator.translateType(type.getPermType());
						val /*Boolean*/ isImmutable = type.isImmutable();
					};
				} {
					// java.lang.System.out.println("Field " + rep + " does not have a type!");
					
					new FieldType {
						val /*ID*/ name = new ID { val name = rep.getName(); };
						val /*PermType*/ permType = new Dyn;
						val /*Boolean*/ isImmutable = true;
					};
				};
			}

			case plaid.compilerjava.util.MethodRep {
				ifElse (rep.hasType()) {
					val type = rep.getType();
					
					new MethodType {
						val /*ID*/ name = new ID { val name = rep.getName(); };
						val /*PermType*/ returnType = astTranslator.translateType(type.getReturnType());
						val /*List<ChangeType>*/ argTypes = astTranslator.map(astTranslator.translateType, type.getArgTypes());
						val /*ChangeType*/ receiverType = astTranslator.translateType(type.getReceiverType());
						val /*Map<ID,ChangeType>*/ environmentTypes = astTranslator.translateMap(astTranslator.translateAST, astTranslator.translateType, type.getEnvironmentTypes());
					};
				} {
					new MethodType {
						val /*ID*/ name = new ID { val name = rep.getName(); };
						val /*PermType*/ returnType = new Dyn;
						val /*List<ChangeType>*/ argTypes = new List { var head = new Nil; };
						val /*ChangeType*/ receiverType = new ChangeType {
							val /*PermTYpe*/ input = new Dyn;
							val /*PermType*/ output = new Dyn;
							val /*boolean*/ borrow = false;
						};
						val /*Map<ID,ChangeType>*/ environmentTypes = java.util.HashMap.new();
					};
				};
			}

			case plaid.compilerjava.util.StateRep {
				val stateType = new StateType {
					val /*Option StateType*/ superType = new None; // TODO:  How to fill this in?  rep.needs is a list of strings?!
					val /*ID*/ name = new ID { val name = rep.getName(); };
				};
				
				val it = rep.getMembers().iterator();
				while { it.hasNext(); } {
					val memberRep = it.next();
					val declType = this.translateState(memberRep);
					// TODO:  This needs to account for abstract fields.
					stateType.declaredTypes.put(memberRep.getName(), declType);
					stateType.providedTypes.put(memberRep.getName(), declType); 
				};
				
				this.stateTable.put(rep.getName(), stateType);
				
				stateType;
			}

			default {
				java.lang.System.err.println("Error while translating StateRep to state table entry.");
			}
		};
	}
	
	method translate(rep) {
		match (rep) {
			case plaid.compilerjava.util.FieldRep {
				// Global variable, ignore. 
			}

			case plaid.compilerjava.util.MethodRep {
				// Global method, ignore.
			}

			case plaid.compilerjava.util.StateRep {
				this.translateState(rep);
			}

			case plaid.compilerjava.util.PackageRep {
				var it = rep.getPackageMembers().iterator();
				while { it.hasNext(); } {
					this.translate(it.next());
				};

				it = rep.getNestedPackages().iterator();
				while { it.hasNext(); } {
					this.translate(it.next());
				};
			}
		};
	}
	
	method test() {
		var javaAST = plaid.compilerjava.ParserCore.parse(java.io.FileInputStream.new(java.io.File.new("testInputs/fibonacci/package.plaid")));
	
		val stateTable = new StateTable {
			override val states = java.util.HashMap.new();
		};
		val tr = new PackageRepTranslator {
			val stateTable = stateTable;
		};
		
		val userDir = java.lang.System.getProperty("user.dir");
	
		val cc = plaid.compilerjava.CompilerConfiguration.new();
		cc.addToPlaidPath(userDir + "/bin/");
		cc.addToPlaidPath(userDir + "/../stdlib/bin/");	
		val core = plaid.compilerjava.CompilerCore.new(cc);
		val cus = java.util.ArrayList.new();
		cus.add(javaAST);
		val packageRep = core.buildPlaidPath(cus);
		
		tr.translate(packageRep);
		
		java.lang.System.out.println("Printing state table:");
		stateTable.printTable();
	}
}