package plaid.typechecker.AST;

import plaid.lang.*;

state LNFTranslator case of ASTTranslator {
	var counter = 0;
	
	// TODO: Refactor this into a Plaid List library
	override method map(f, list) {
		val iter = list.iterator();
		val newList = new plaid.lang.List with { var head = new plaid.lang.Nil; };
		while {iter.hasNext();} {
			newList.prepend(f(iter.next()));
		};
		newList
	}
	
	method generateID(tok) {
		// translateAST(plaid.compilerjava.util.IdGen.getId())
		
		
		counter = counter + 1;
		val n = "LNF$vAr" + counter + "$plaid";
		new ID with {
			val /*Token*/ token = tok;
			val /*String*/ name = n;
		};
	}
	
	override method translateAST(root) {
		match(root) {
			case plaid.compilerjava.AST.Application {
				match (root.getFunction()) {
					// Already in LNF
					case plaid.compilerjava.AST.ID {
						new LNFApplication {
							val /*Token*/ token = root.getToken();
							val /*ID*/ f = translateAST(root.getFunction());
							val /*Expression*/ arg = translateAST(root.getArg());
						};
					}
					// The function is some more complicated expression => add a let binding
					default {
						val id = generateID(root.getToken());
						new UnannotatedLetBinding with {
							val /*Token*/ token = root.getToken();
							val /*ID*/ x = id;
							val /*Expression*/ exp = translateAST(root.getFunction());
							val /*Expression*/ body = new LNFApplication with {
								val /*Token*/ token = root.getToken();
								val /*ID*/ f = id;
								val /*Expression*/ arg = translateAST(root.getArg());
							};
							val /*boolean*/ mutable = false;
						};
					}
				}
			}
			case plaid.compilerjava.AST.Assignment {
				new Assignment with {
					var /*Token*/ token = root.getToken();
					var /*Expression*/ target = ifElse (root.hasTarget()) {
							translateAST(root.getTarget());
						} {
							new NullNode;
						};
					var /*ID*/ field = translateAST(root.getField());
					var /*Expression*/ value = translateAST(root.getValue());
				};
			}
			case plaid.compilerjava.AST.Case {
				new Case with {
					val /*Token*/ token = root.getToken();
					val /*QI*/ qi = ifElse (root.hasQi()) {
							translateAST(root.getQi());
						} {
							new NullNode;
						};
					val /*ID*/ x = ifElse (root.hasX()) {
							translateAST(root.getX());
						} {
							new NullNode;
						};
					val /*Expression*/ e = translateAST(root.getE());
					val /*boolean*/ defaultCase = root.isDefaultCase();
					val /*boolean*/ boundVar = root.isBoundVar();
				};
			}
			case plaid.compilerjava.AST.ChangeState {
				val expr = root.getE();
				
				match (expr) {
					// Already LNF
					case plaid.compilerjava.AST.ID {
						new LNFChangeState with {
							val /*Token*/ token = root.getToken();
							val /*ID*/ e = translateAST(expr);
							val /*State*/ s = translateAST(root.getSt());
						};
					}
					// Bring AST to LNF
					default {
						val id = generateID(root.getToken());
						new UnannotatedLetBinding with {
							val /*Token*/ token = root.getToken();
							val /*ID*/ x = id;
							val /*Expression*/ exp = translateAST(expr);
							val /*Expression*/ body = new LNFChangeState with {
								val /*Token*/ token = root.getToken();
								val /*ID*/ e = id;
								val /*State*/ s = translateAST(root.getSt());
							};
							val /*boolean*/ mutable = false;
						};
					}
				}
			}
			case plaid.compilerjava.AST.CompilationUnit {
				new CompilationUnit with {
					val /*List<Decl>*/ decls = map(translateAST, root.getDecls());
					val /*List<String>*/ packageName = root.getPackageName();
					val /*ImportList*/ imports = translateAST(root.getImports());
					val javaImports = root.getImports();
					// TODO: ???
					val /*File*/ sourceFile = java.io.File.new(">>UNKNOWN<<");
				};
			}
			case plaid.compilerjava.AST.DeclList {
				new DeclList with {
					val /*Token*/ token = root.getToken();
					val /*List<Decl>*/ decls = map(translateAST, root.getDecls());
				};
			}
			case plaid.compilerjava.AST.Dereference {
				val left = root.getLeft();
				
				match (left) {
					// Already LNF
					case plaid.compilerjava.AST.ID {
						new LNFDereference with {
							val /*Token*/ token = root.getToken();
							val /*ID*/ left = translateAST(root.getLeft());
							val /*ID*/ right = translateAST(root.getRight());
						};
					}
					// Bring AST to LNF
					default {
						val id = generateID(root.getToken());
						new UnannotatedLetBinding with {
							val /*Token*/ token = root.getToken();
							val /*ID*/ x = id;
							val /*Expression*/ exp = translateAST(left);
							val /*Expression*/ body = new LNFDereference with {
								val /*Token*/ token = root.getToken();
								val /*ID*/ left = id;
								val /*ID*/ right = translateAST(root.getRight());
							};
							val /*boolean*/ mutable = false;
						};
					}
				}
			}
			case plaid.compilerjava.AST.DestructiveDereference {
				val left = root.getLeft();
				
				match (left) {
					// Already LNF
					case plaid.compilerjava.AST.ID {
						new LNFDestructiveDereference with {
							val /*Token*/ token = root.getToken();
							val /*ID*/ left = translateAST(root.getLeft());
							val /*ID*/ right = translateAST(root.getRight());
						};
					}
					// Bring AST to LNF
					default {
						val id = generateID(root.getToken());
						new UnannotatedLetBinding with {
							val /*Token*/ token = root.getToken();
							val /*ID*/ x = id;
							val /*Expression*/ exp = translateAST(left);
							val /*Expression*/ body = new LNFDestructiveDereference with {
								val /*Token*/ token = root.getToken();
								val /*ID*/ left = id;
								val /*ID*/ right = translateAST(root.getRight());
							};
							val /*boolean*/ mutable = false;
						};
					}
				}
			}
			case plaid.compilerjava.AST.FieldDecl {
				new FieldDecl with {
					val /*Token*/ token = root.getToken();
					val /*ID*/ f = translateAST(root.getF());
					val /*Expression*/ e = translateAST(root.getE());
					val /*boolean*/ abstractField = root.isAbstractField();
				};
			}
			case plaid.compilerjava.AST.ID {
				new ID with {
					val /*Token*/ token = root.getToken();
					val /*String*/ name = root.getName();
				};
			}
			case plaid.compilerjava.AST.ImportList {
				new ImportList with {
					val /*List<QualifiedID>*/ imports = map(translateAST, root.getImports());
					val /*Token*/ token = root.getToken();
				};
			}
			case plaid.compilerjava.AST.IntLiteral {
				new IntLiteral with {
					val /*Token*/ token = root.getToken();
					val /*int*/ integer = root.getValue();
				};
			}
			case plaid.compilerjava.AST.Lambda {
				new Lambda with {
					val /*Token*/ token = root.getToken();
					val /*ID*/ x = translateAST(root.getVar());
					val /*Expression*/ body = translateAST(root.getBody());
				};
			}
			case plaid.compilerjava.AST.LetBinding {
				new UnannotatedLetBinding with {
					val /*Token*/ token = root.getToken();
					val /*ID*/ x = translateAST(root.getX());
					val /*Expression*/ exp = translateAST(root.getExp());
					val /*Expression*/ body = translateAST(root.getBody());
					val /*boolean*/ mutable = root.isMutable();
				};
			}
			case plaid.compilerjava.AST.Match {
				val expr = root.getE();
				
				match (expr) {
					// Already in LNF
					case plaid.compilerjava.AST.ID {
						new LNFMatch with {
							val /*Token*/ token = root.getToken();
							val /*ID*/ e = translateAST(expr);
							val /*List<Case>*/ caseList = map(translateAST, root.getCaseList());
						};
					}
					// Bring AST to LNF
					default {
						val id = generateID(root.getToken());
						new UnannotatedLetBinding with {
							val /*Token*/ token = root.getToken();
							val /*ID*/ x = id;
							val /*Expression*/ exp = translateAST(left);
							val /*Expression*/ body = new LNFMatch with {
								val /*Token*/ token = root.getToken();
								val /*ID*/ e = id;
								val /*List<Case>*/ caseList = map(translateAST, root.getCaseList());
							};
							val /*boolean*/ mutable = false;
						};						
					}
				}
			}
			case plaid.compilerjava.AST.MethodDecl {
				new MethodDecl with {
					val /*Token*/ token = root.getToken();
					val /*String*/ name = root.getName();
					val /*Expression*/ body = translateAST(root.getBody());
					val /*ID*/ arg = ifElse (root.hasArg()) {
							translateAST(root.getArg());
						} {
							new NullNode;
						};
					val /*boolean*/ abstractMethod = root.isAbstractMethod();
				};
			}
			case plaid.compilerjava.AST.NewInstance {
				new NewInstance with {
					val /*Token*/ token = root.getToken();
					val /*State*/ st = translateAST(root.getSt());
				};
			}
			case plaid.compilerjava.AST.QI {
				new QI with {
					val /*Token*/ token = root.getToken();
					val /*List<String>*/ qid = root.getQid();
				};
			}
			case plaid.compilerjava.AST.StateDecl {
				new StateDecl with {
					val /*Token*/ token = root.getToken();
					val /*ID*/ name = new ID { val name = root.getName(); };
					val javaStateDef = root.getStateDef();
					val /*State*/ stateDef = translateAST(root.getStateDef());
					val /*boolean*/ isCaseOf = root.getIsCaseOf();
					val javaCaseOf = root.getCaseOf();
					val /*QI*/ caseOf = ifElse (root.getIsCaseOf()) {
							translateAST(root.getCaseOf());
						} {
							new NullNode;
						};
				};
			}
			case plaid.compilerjava.AST.StringLiteral {
				new StringLiteral with {
					val /*Token*/ token = root.getToken();
					val /*String*/ string = root.toString();
				};
			}
			case plaid.compilerjava.AST.Throws {
				new Throws with {
					val /*Token*/ token = root.getToken();
					val /*ID*/ throwableID = translateAST(root.getThrowableID());
				};
			}
			case plaid.compilerjava.AST.UnitLiteral {
				new UnitLiteral with {
					val /*Token*/ token = root.getToken();
				};
			}
			case plaid.compilerjava.AST.With {
				new With with {
					val /*Token*/ token = root.getToken();
					val /*State*/ s1 = translateAST(root.getR1());
					val /*State*/ s2 = translateAST(root.getR2());
				};
			}
			default {
				// TODO: ???
				java.lang.System.out.print("Unknown AST node type: ");
				java.lang.System.out.println((root.getClass()).getSimpleName());
			}
		}
	}
}