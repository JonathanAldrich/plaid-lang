package plaid.typechecker.AST;

method translateAST(root) {
	var /*String*/ className = root.getClass().getSimpleName();

	ifelse (className.equals("Application")) {
		new Application with {
			val /*Token*/ token = root.getToken();
			val /*Expression*/ f = translateAST(root.getFunction());
			val /*Expression*/ arg = translateAST(root.getArg());
		};
	}{
	ifelse (className.equals("Assignment")) {
		new Assignment with {
			val /*Token*/ token = root.getToken();
			val /*Expression*/ target = translateAST(root.getTarget());
			val /*ID*/ field = translateAST(root.getField());
			val /*Expression*/ value = translateAST(root.getValue());
		};
	}{	
	ifelse (className.equals("Case")) {
		new Case with {
			val /*Token*/ token = root.getToken();
			val /*QI*/ qi = translateAST(root.getQI());
			val /*ID*/ x = translateAST(root.getX());
			val /*Expression*/ e = translateAST(root.getE());
			val /*boolean*/ defaultCase = root.getDefaultCase();
			val /*boolean*/ boundVar = root.isBoundVar();
		};
	}{	
	ifelse (className.equals("ChangeState")) {
		new ChangeState with {
			val /*Token*/ token = root.getToken();
			val /*Expression*/ e = translateAST(root.getE());
			val /*State*/ s = translateAST(root.getState());
		};
	}{	
	ifelse (className.equals("CompilationUnit")) {
		new CompilationUnit with {
			val /*List<Decl>*/ decls = map(translateAST, root.getDecls());
			val /*List<String>*/ packageName = root.getPackageName();
			val /*ImportList*/ imports = translateAST(root.getImports());
			// TODO: ???
			val /*File*/ sourceFile = new File(">>UNKNOWN<<");
		};
	}{
	ifelse (className.equals("DeclList")) {
		new DeclList with {
			val /*Token*/ token = root.getToken();
			val /*List<Decl>*/ decls = map(translateAST, root.getDecls());
		};
	}{
	ifelse (className.equals("Dereference")) {
		new Dereference with {
			val /*Token*/ token = root.getToken();
			val /*Expression*/ left = translateAST(root.getLeft());
			val /*ID*/ right = translateAST(root.getRight());
		};
	}{
	ifelse (className.equals("FieldDecl")) {
		new FieldDecl with {
			val /*Token*/ token = root.getToken();
			val /*ID*/ f = translateAST(root.getF());
			val /*Expression*/ e = translateAST(root.getE());
			val /*boolean*/ abstractField = root.getAbstractField();
		};
	}{
	ifelse (className.equals("ID")) {
		new ID with {
			val /*Token*/ token = root.getToken();
			val /*String*/ name = root.getName();
		};
	}{
	ifelse (className.equals("ImportList")) {
		new ImportList with {
			val /*List<QualifiedID>*/ imports = root.getImports();
			val /*Token*/ token = root.getToken();
		};
	}{
	ifelse (className.equals("IntLiteral")) {
		new IntLiteral with {
			val /*Token*/ token = root.getToken();
			val /*int*/ integer = root.getValue();
		};
	}{
	ifelse (className.equals("Lambda")) {
		new Lambda with {
			val /*Token*/ token = root.getToken();
			val /*ID*/ x = root.getVar();
			val /*Expression*/ body = translateAST(root.getBody());
		};
	}{
	ifelse (className.equals("LetBinding")) {
		new LetBinding with {
			val /*Token*/ token = root.getToken();
			val /*ID*/ x = root.getX();
			val /*Expression*/ exp = translateAST(root.getExp());
			val /*Expression*/ body = translateAST(root.getBody());
			val /*boolean*/ mutable = root.getMutable();
		};
	}{
	ifelse (className.equals("Match")) {
		new Match with {
			val /*Token*/ token = root.getToken();
			val /*Expression*/ e = translateAST(root.getE());
			val /*List<Case>*/ caseList = map(translateAST, caseList);
		};
	}{
	ifelse (className.equals("MethodDecl")) {
		new MethodDecl with {
			val /*Token*/ token = root.getToken();
			val /*String*/ name = root.getName();
			val /*Expression*/ body = translateAST(root.getBody());
			val /*ID*/ arg = translateAST(root.getArg());
			val /*boolean*/ abstractMethod = root.getAbstractMethod();
		};
	}{
	ifelse (className.equals("NewInstance")) {
		new NewInstance with {
			val /*Token*/ token = root.getToken();
			val /*State*/ s = translateAST(root.getState());
		};
	}{
	ifelse (className.equals("QI")) {
		new QI with {
			val /*Token*/ token = root.getToken();
			val /*List<String>*/ qid = root.getQID();
		};
	}{
	ifelse (className.equals("StateDecl")) {
		new StateDecl with {
			val /*Token*/ token = root.getToken();
			val /*ID*/ name = translateAST(root.getName());
			val /*State*/ stateDef = translateAST(root.getStateDef());
			val /*QI*/ caseOf = translateAST(root.getCaseOf());
			val /*boolean*/ isCaseOf = root.getIsCaseOf();
		};
	}{
	ifelse (className.equals("StringLiteral")) {
		new StringLiteral with {
			val /*Token*/ token = root.getToken();
			val /*String*/ string = root.getString();
		};
	}{
	ifelse (className.equals("UnitLiteral")) {
		new UnitLiteral with {
			val /*Token*/ token = root.getToken();
		};
	}{
	ifelse (className.equals("With")) {
		new With with {
			val /*Token*/ token = root.getToken();
			val /*State*/ s1 = translateAST(root.getS1());
			val /*State*/ s2 = translateAST(root.getS2());
		};
	}{
		// TODO: ???
		java.lang.System.out.println("Unknown AST node type.");
	}
	}}}}}}}}}}}}}}}}}}}}
}

// TODO: Refactor this into a Plaid List library
method map(f, list) {
	val iter = list.iterator();
	val newList = new java.util.LinkedList;
	while (iter.hasNext()) {
		newList.addLast(f(iter.next()));
	}
	newList
}