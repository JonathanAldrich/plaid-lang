package plaid.typechecker.AST;

import plaid.typechecker.AST.visitor.ASTVisitor;
import plaid.typechecker.AST.FieldDecl;
import plaid.typechecker.AST.MethodDecl;

import java.lang.Thread;
import java.awt.BorderLayout;
import java.awt.Dimension;
import javax.swing.JFrame;
import javax.swing.JTree;
import javax.swing.JScrollPane;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.WindowConstants;


state ASTViewer case of ASTVisitor {
    var /* DefaultMutableTreeNode */ parent;

    method draw(root) {
        var jtree  = JTree.new(root);
        jtree.setRootVisible(true);
        var scroll = JScrollPane.new(jtree);
        var jframe = JFrame.new("ASTViewer");
        jframe.add(scroll); 
        jframe.setMinimumSize(Dimension.new(500,500));
        jframe.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        jframe.setVisible(true);
    }
    
    method createNode(name) {
        DefaultMutableTreeNode.new(name);
    }
    
    method visitCompilationUnit(node) {
        System.out.println("Starting ASTVisitor ... ");
        var cu = createNode("CompilationUnit");
        cu.add(createNode("Source File : " + node.sourceFile));
        cu.add(createNode("Package     : " + node.packageName));
        // get imports
        var imports = createNode("Imports");
        parent = imports;
        node.imports.accept(this);
        cu.add(imports);
        // get decls
        var fields = createNode("Top-Level Fields");
        cu.add(fields);
        var methods = createNode("Top-Level Methods");
        cu.add(methods);
        var states = createNode("Top-Level States");
        cu.add(states);
        node.decls.map( fn (decl) => {
            match (decl) {
                case FieldDecl {
                    parent = fields;
                    decl.accept(this);
                }
                case MethodDecl {
                    parent = methods;
                    decl.accept(this);
                }
                case StateDecl {
                    parent = states;
                    decl.accept(this);
                }
                default {
                    System.out.println("Unsupported top level declaration.");
                }
            }
        });
        draw(cu);
    }
    
    method visitImportList(node) {
        var iter = node.imports.iterator();
        while { iter.hasNext(); } {
            var imp = createNode(iter.next());
            parent.add(imp);
        }
    }
    
    method visitFieldDecl(node) {
        var fd = createNode(node.getName());
        ifElse ( node.abstractField ) {
            fd.add(createNode("Abstract  : True"));
        } {
            fd.add(createNode("Abstract  : False"));
            // TODO: add initializer;        
        };
        ifElse ( node.immutableField ) {
            fd.add(createNode("Immutable : True"));
        } {
            fd.add(createNode("Immutable : False"));
        };
        // TODO: add type
        parent.add(fd);
    }
    
    method visitMethodDecl(node) {
        var md = createNode(node.getName());
        // TODO: add types, params  and body
        // get body
        var body = createNode("Body");
        parent.add(md);
        md.add(body);
        parent = body;
        node.body.accept(this);

    }
    
    method visitStateDecl(node) {
        var sd = createNode(node.getName());
        if ( node.isCaseOf ) {
            sd.add(createNode("CaseOf   : " + node.caseOf.toString()));
        };
        // TODO: add types, params  and body
        parent.add(sd);    
    }
    
    method visitLetBinding(node) {
        var let = createNode("let");
        parent.add(let);
        let.add(createNode("ID  : " + node.x.name));
        // TODO: get sub expressions
        
    }
    
    method visitID(node) {
        parent.add(createNode("ID  : " + node.name));
    }
}