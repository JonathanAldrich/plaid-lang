package plaid.typechecker.AST.visitor;

state CodeGenVisitor case of ASTVisitor {
	val jCodeGen = plaid.compilerjava.util.CodeGen;
	var out = "";	// Java codegen helper object.

	// Additional fields for passing state around accept() calls.
	// Invariant: Assigned before accept() call, and copied to local variables
	// at the beginning of method call.
	// TODO: Reimplement using state change once that's working properly?
	var g_packageName = "";
	var g_returnVar = "";
	var g_imports = "";
	var g_y = "";


	method visitApplication(node) {
		
	}
	
	method visitAssignment(node) {
		
	}
	
	method visitCase(node) {
	
	}
	
	method visitChangeState(node) {
	
	}
	
	method visitCompilationUnit(node) {
		java.lang.System.out.println("Generating code for '" + node.packageName + "'...");
		g_packageName = node.packageName;
		g_imports = node.imports;

		node.decls.map(fn (d) => {
			d.accept(this);
		});
	}
	
	method visitDeclList(node) {
	
	}
	
	method visitDereference(node) {
	
	}
	
	method handleTopLevelFieldDecl(node) {
		val cc = plaid.compilerjava.CompilerConfiguration.new();
		cc.setPrettyPrint(java.lang.Boolean.TRUE);
		out = jCodeGen.new(cc);
		var freshImports = plaid.compilerjava.util.IdGen.getId();
		
		// package qid;
		val qid = plaid.compilerjava.AST.QI.new(g_packageName);
		val thePackage = qid.toString();
		out.declarePackage(thePackage);
		
		// @plaid.runtime.annotations (...)
		out.topFieldAnnotation(node.f.name, thePackage);
		
		// public class c {
		out.declarePublicClass(node.f.name); 
		out.openBlock();
		
		// Get imports, define scopes
		out.declarePublicStaticFinalVar("java.util.List<plaid.runtime.utils.Import>", freshImports.getName());
		
		g_imports.accept(this);
		
		out.declareGlobalScope(thePackage, freshImports.getName());
		
		out.fieldAnnotation(node.f.name);
		out.openStaticBlock(); //static {
		out.declareLocalScope(jCodeGen.globalScope);
		
		// Generate the expr
		out.declareVar(out.plaidObjectType, node.f.name);
		g_y = node.f;
		node.e.accept(this);
		
		// TODO: Improve translation of Plaid booleans
		ifElse (node.immutableField) {
			out.insertIntoScope(jCodeGen.globalScope, node.f.name, java.lang.Boolean.TRUE);
		} {
			out.insertIntoScope(jCodeGen.globalScope, node.f.name, java.lang.Boolean.FALSE);
		};
		
		out.closeBlock(); out.closeBlock(); //}}
		
		val result = out.formatFile();
		java.lang.System.out.println(result);
		java.lang.System.out.println("-------------------------------------------");	
	}
	
	method visitFieldDecl(node) {
		handleTopLevelFieldDecl(node);
	}
	
	method visitID(node) {
	
	}
	
	method visitImportList(node) {
		out.openStaticBlock();  // static {
		out.assignToNewJavaObject(g_returnVar.getName(), 
			"java.util.ArrayList<plaid.runtime.utils.Import>");

		val it = node.imports.iterator();
		while { it.hasNext(); } {
			val qi = it.next();
			var s = g_returnVar.getName();
			s = s + ".add(new plaid.runtime.utils.Import(\\\"";
			s = s + qi.toString();
			s = s + "\\\"));"; 
			out.append(s);
		};

		out.closeBlock();
	}
	
	method visitIntLiteral(node) {
		out.setLocation(node.token);
		out.assign(g_y.name);
		out.plaidInt(node.integer);
		out.append(";");
		out.updateVarDebugInfo(g_y.name);
	}
	
	method visitLambda(node) {
	
	}
	
	method visitLetBinding(node) {
	
	}
	
	method visitMatch(node) {
	
	}
	
	method handleTopLevelMethodDecl(node) {
		val newName = jCodeGen.convertOpNames(node.name);
		java.lang.System.out.println("Generating code for method '" + newName + "'...");

		g_returnVar = plaid.compilerjava.util.IdGen.getId();
		val freshImports = plaid.compilerjava.util.IdGen.getId();
		
		val cc = plaid.compilerjava.CompilerConfiguration.new();
		cc.setPrettyPrint(java.lang.Boolean.TRUE);
		out = jCodeGen.new(cc);
		
		val qid = plaid.compilerjava.AST.QI.new(g_packageName);
		val thisMethod = newName + "_func";
		val thePackage = qid.toString();
		
		//package and needed imports
		out.declarePackage(thePackage);
		
		//annotation and class definition
		out.topMethodAnnotation(newName, thePackage);
		out.declarePublicClass(newName);
		out.openBlock(); //public class newName {

		//generate code to create the package scope with imports
		out.declarePublicStaticFinalVar("java.util.List<plaid.runtime.utils.Import>", freshImports.getName());
		
		g_imports.accept(this);

		out.declareGlobalScope(qid.toString(), freshImports.getName());
		
		if (newName.equals("main") /*&& this.methodType.getArgTypes().get(0) == PermType.UNIT && this.methodType.getArgTypes().size() == 1*/) {
			out.topLevelMain(newName + "_func");
		};

		out.methodAnnotation(newName);
		out.declarePublicStaticFinalVar(jCodeGen.plaidMethodType, thisMethod);
		out.openStaticBlock(); // static {
		// add local scope so that the lambda creation works properly
		out.declareLocalScope(jCodeGen.globalScope);
		out.assignToNewLambda(thisMethod, node.arg.name);
		
		out.declareVar(jCodeGen.plaidObjectType, g_returnVar.getName());
		//top level functions lookup with unit
		node.body.accept(this);

		out.ret(g_returnVar.getName());
		out.closeAnonymousDeclaration(); // }});
		
		out.closeBlock(); // }  (for static block)
		out.closeBlock(); // }  (for class declaration)
		
//		return FileGen.createOutputFile(newName, cc.getOutputDir(), out.formatFile(), qid);
		val result = out.formatFile();
		java.lang.System.out.println(result);
		java.lang.System.out.println("-------------------------------------------");
	}
	
	method visitMethodDecl(node) {
		// TODO: Handle nested decls
		handleTopLevelMethodDecl(node);
	}
	
	method visitNewInstance(node) {
	
	}
	
	method visitQI(node) {
	
	}
	
	method visitStateDecl(node) {
	
	}
	
	method visitStringLiteral(node) {
	
	}
	
	method visitUnitLiteral(node) {
	
	}
	
	method visitWith(node) {
	
	}

	method createStateDecl() {
		var freshImports = IdGen.getId();
		var theState = IdGen.getId();
		var thePackage = qid.toString();
		
		//package and needed imports
		out.declarePackage(thePackage); //package qid;
		
		//determine what members this state has and add annotations
		var stateVars = genStateVars(qid, imports.getImports(), root.stateDef,
			root.caseOf); //TODO write this method in Plaid
		
		var members = StringBuilder.new();
		
		var i = 0;
		while { i < stateVars.size() } {
			members.append(stateVars.get(i).getName() + ",");
			i = i + 1;
		};
		
		var memberString = members.toString();
		if (memberString.length() > 0) {
			memberString = memberString.substring(0, memberString.length() - 1);
		};
		
		// state annotation and class definition
		out.topStateAnnotation(root.name.getName(), thePackage, memberString);
		out.declarePublicClass(root.name.getName()); 
		out.openBlock();  // public class f {
		
		//generate code to create the package scope with imports
		out.declarePublicStaticFinalVar(
			"java.util.List<plaid.runtime.utils.Import>",
			freshImports.getName());
			
		g_freshImports = freshImports;
		g_theState = theState;
		g_stateVars = stateVars;
		imports.accept(this);
		out.declareGlobalScope(qid.toString(), freshImports.getName());

		//annotation for the prototype object representing the state
		out.stateAnnotation(root.name.getName());
		out.declarePublicStaticFinalVar(out.plaidObjectType, 
			root.name.getName());
		
		out.openStaticBlock(); //static {
		out.declareLocalScope(out.globalScope);
		out.declareFinalVar(out.plaidStateType, theState.getName());

		var idList = IDList.new(globals);
		// "this" should be visible during field initializations
		idList.add(ID.new(out.thisVar)); 
		
		// with caseOf State
		ifElse  (!root.isCaseOf) {
			// this is this declaration.  It will not have any members, but 
			// at runtime can forward to its enclosing (instantiated) state
			g_name = qid.toString() + "." + root.name.getName();
			g_idList = idList;
			root.stateDef.accept(this);
			
			out.assignToPrototype(root.name.getName(), theState.getName());
		}{
			var caseOfState = IdGen.getId();
			var declaredState = IdGen.getId();
			out.declareFinalVar(out.plaidStateType, caseOfState.getName());
			g_name = out.anonymousDeclaration;
			g_idList = idList;
			root.caseOf.accept(this);
			out.declareFinalVar(out.plaidStateType, declaredState.getName());
			
			// this is this declaration.  It will not have any members, but
			// at runtime can forward to its enclosing (instantiated) state
			g_name = qid.toString() + "." + root.name.getName();
			g_declaredState = declaredState;
			stateDef.accept(this);
			
			//y = fresh1.with(fresh2); 
			out.assignToWith(theState.getName(),caseOfState.getName(),
				declaredState.getName());  
					
			out.assignToPrototype(name.getName(), theState.getName());
			
			// because of subtagging, we don't want the resulting object to 
			// have the caseOf's state's tag
			
			// If the caseOf State has a tag
			out.ifCondition(caseOfState.getName() + ".hasTag()"); 
			// //remove it from the prototype
			//out.append(root. name.getName() + ".removeTag(" + 
			//	caseOfState.getName() + ".getTag());"); 
		};
		out.closeBlock(); // } (for static block to init prototype)

		if (root.isCaseOf) { //if we have a tag	
			//Declare variable to hold the tag
			var tag = ID.new(name.getName() + "$Tag" + 
				PlaidConstants.ID_SUFFIX);
			var tagPath = qid.toString() + "." + root.name.getName();
			out.tagAnnotation(tagPath);
			out.declarePublicStaticFinalVar(out.plaidTagType, tag.getName());
			
			out.openStaticBlock(); //static {	
			var caseOfState = IdGen.getId();
			out.declareFinalVar(out.plaidStateType, caseOfState.getName());
			caseOf.accept(this);
			g_idList = IDList.new();
			g_theState = caseOfState;
			g_declaredState = out.anonymousDeclaration;
			caseOf.codegenState(this);
			//tag = new PlaidTag(caseOfState)
			out.assignToNewTag(tag.getName(), tagPath, caseOfState.getName());
			
			out.closeBlock(); // } (for static block to init tag)
		};
		
		out.closeBlock(); // } (for class Def)
		
		FileGen.createOutputFile(name.getName(), cc.getOutputDir(),
			out.formatFile(), qid);
	}
}