package plaid.typechecker.AST.visitor;

import plaid.typechecker.util.*;

state CodeGenVisitor case of ASTVisitor {
	val /* CodeGen */ jCodeGen = plaid.compilerjava.util.CodeGen;
	var /* CodeGen */ out = "";	// Java codegen helper object.
	var /* IdGen */ idgen = ""; // Plaid ID generator.

	// Additional fields for passing state around accept() calls.
	// Invariant: Assigned before accept() call, and copied to local variables
	// at the beginning of method call.
	// TODO: Reimplement using state change once that's working properly?
	var /* QualifiedID */ g_packageName = "";
	var /* ID */ g_returnVar = "";
	var /* ImportList */ g_imports = "";
	var /* ID */ g_y = "";


	method visitApplication(node) {
		//out.setLocation(token);
		var /* ID */ x = idgen.getId();
		var /* ID */ y = g_y;
		var /* ID */ z = idgen.getId();
		// public final PlaidObject x;
		// public final PlaidObject z;
		out.declareFinalVar(jCodeGen.plaidObjectType, x.name);
		out.declareFinalVar(jCodeGen.plaidObjectType, z.name);
		
		g_y = x;
		node.f.accept(this);
		
		g_y = z;
		node.arg.accept(this);
		
		//out.setLocation(token);
		// y = Util.call(x,z);
		out.assignToCall(y.name, x.name, z.name);  
	}
	
	method visitAssignment(node) {
		val /* ID */ y = g_y;
		//out.setLocation(node.token); TODO: Why does this break?
		val /* ID */ assignTo = idgen.getId();
		out.declareFinalVar(jCodeGen.plaidObjectType, assignTo.name);
		g_y = assignTo;
		node.value.accept(this);
		
		// Generates (e.g.):
		// PlaidObject var$foo = local$c0pe.lookup('y')
		// local$c0pe.update('x', var$foo)
		ifElse (node.target.isNull()) {
			// if we haven't seen it in this scope at all, then we must be 
			// referencing an instance field with an implicit "this"
			// need to make sure we've loaded it before
			out.lookupInCurrentScope(node.field.name);
			out.updateVarInScope(node.field.name, assignTo.name);
			out.assignToID(y.name, assignTo.name);
			
			out.updateVarDebugInfo(assignTo.name);
		} {
			// we have a target, so we need to check if that particular 
			// field of the target is mutable and if so assign the new value
			// evaluate the target
			val /* ID */ temp = idgen.getId();
			out.declareFinalVar(jCodeGen.plaidObjectType, temp.name);
			g_y = temp;
			node.target.accept(this);
			out.updateMember(temp.name, node.field.name, assignTo.name);
			out.assignToID(y.name, assignTo.name);
	
			out.updateVarDebugInfo(assignTo.name);
		}
	}
	
	method visitCase(node) {
	
	}
	
	method visitChangeState(node) {
	
	}
	
	method visitCompilationUnit(node) {
		java.lang.System.out.println("Generating code for '" + node.packageName + "'...");
		g_packageName = node.packageName;
		g_imports = node.imports;

		node.decls.map(fn (d) => {
			d.accept(this);
		});
	}
	
	method visitDeclList(node) {
	
	}
	
	method visitDereference(node) {
		val /* ID */ y = g_y;
		//out.setLocation(token);
		
		//generate code for the object to lookup the right ID in
		var /* ID */  x = idgen.getId();
		out.declareFinalVar(jCodeGen.plaidObjectType, x.name);

		g_y = x;
		node.left.accept(this);

		//out.setLocation(left.token);
		
		//code for the lookup
		//out.setLocation(right.token);
		//out.setLocation(y.token);
		out.assignToLookup(y.name, jCodeGen.convertOpNames(node.right.name), 
			x.name);
	}
	
	method handleTopLevelFieldDecl(node) {
		val cc = plaid.compilerjava.CompilerConfiguration.new();
		cc.setDebugMode(java.lang.Boolean.FALSE);
		cc.setPrettyPrint(java.lang.Boolean.TRUE);
		out = jCodeGen.new(cc);
		idgen = new IdGen;
		var freshImports = idgen.getId();
		
		// package qid;
		val qid = plaid.compilerjava.AST.QI.new(g_packageName);
		val thePackage = qid.toString();
		out.declarePackage(thePackage);
		
		// @plaid.runtime.annotations (...)
		out.topFieldAnnotation(node.f.name, thePackage);
		
		// public class c {
		out.declarePublicClass(node.f.name); 
		out.openBlock();
		
		// Get imports, define scopes
		out.declarePublicStaticFinalVar("java.util.List<plaid.runtime.utils.Import>", freshImports.name);
		
		g_imports.accept(this);
		
		out.declareGlobalScope(thePackage, freshImports.name);
		
		out.fieldAnnotation(node.f.name);
		out.openStaticBlock(); //static {
		out.declareLocalScope(jCodeGen.globalScope);
		
		// Generate the expr
		out.declareVar(out.plaidObjectType, node.f.name);
		g_y = node.f;
		node.e.accept(this);
		
		// TODO: Improve translation of Plaid booleans
		ifElse (node.immutableField) {
			out.insertIntoScope(jCodeGen.globalScope, node.f.name, java.lang.Boolean.TRUE);
		} {
			out.insertIntoScope(jCodeGen.globalScope, node.f.name, java.lang.Boolean.FALSE);
		};
		
		out.closeBlock(); out.closeBlock(); //}}
		
		val result = out.formatFile();
		java.lang.System.out.println(result);
		java.lang.System.out.println("-------------------------------------------");	
	}
	
	method visitFieldDecl(node) {
		handleTopLevelFieldDecl(node);
	}
	
	method visitID(node) {
	
	}
	
	method visitImportList(node) {
		out.openStaticBlock();  // static {
		out.assignToNewJavaObject(g_returnVar.name, 
			"java.util.ArrayList<plaid.runtime.utils.Import>");

		val it = node.imports.iterator();
		while { it.hasNext(); } {
			val qi = it.next();
			var s = g_returnVar.name;
			s = s + ".add(new plaid.runtime.utils.Import(\\\"";
			s = s + qi.toString();
			s = s + "\\\"));"; 
			out.append(s);
		};

		out.closeBlock();
	}
	
	method visitIntLiteral(node) {
		//out.setLocation(node.token);
		out.assign(g_y.name);
		out.plaidInt(node.integer);
		out.append(";");
		out.updateVarDebugInfo(g_y.name);
	}
	
	method visitLambda(node) {
	
	}
	
	method visitLetBinding(node) {
	
	}
	
	method visitMatch(node) {
	
	}
	
	method handleTopLevelMethodDecl(node) {
		idgen = new IdGen;
		
		val newName = jCodeGen.convertOpNames(node.name);
		java.lang.System.out.println("Generating code for method '" + newName + "'...");

		g_returnVar = idgen.getId();
		val freshImports = idgen.getId();
		
		val cc = plaid.compilerjava.CompilerConfiguration.new();
		cc.setPrettyPrint(java.lang.Boolean.TRUE);
		cc.setDebugMode(java.lang.Boolean.FALSE);
		out = jCodeGen.new(cc);
		
		val qid = plaid.compilerjava.AST.QI.new(g_packageName);
		val thisMethod = newName + "_func";
		val thePackage = qid.toString();
		
		//package and needed imports
		out.declarePackage(thePackage);
		
		//annotation and class definition
		out.topMethodAnnotation(newName, thePackage);
		out.declarePublicClass(newName);
		out.openBlock(); //public class newName {

		//generate code to create the package scope with imports
		out.declarePublicStaticFinalVar("java.util.List<plaid.runtime.utils.Import>", freshImports.name);
		
		g_imports.accept(this);

		out.declareGlobalScope(qid.toString(), freshImports.name);
		
		if (newName.equals("main") /*&& this.methodType.getArgTypes().get(0) == PermType.UNIT && this.methodType.getArgTypes().size() == 1*/) {
			out.topLevelMain(newName + "_func");
		};

		out.methodAnnotation(newName);
		out.declarePublicStaticFinalVar(jCodeGen.plaidMethodType, thisMethod);
		out.openStaticBlock(); // static {
		// add local scope so that the lambda creation works properly
		out.declareLocalScope(jCodeGen.globalScope);
		out.assignToNewLambda(thisMethod, node.arg.name);
		
		out.declareVar(jCodeGen.plaidObjectType, g_returnVar.name);
		//top level functions lookup with unit
		g_y = idgen.getId();
		node.body.accept(this);

		out.ret(g_returnVar.name);
		out.closeAnonymousDeclaration(); // }});
		
		out.closeBlock(); // }  (for static block)
		out.closeBlock(); // }  (for class declaration)
		
//		return FileGen.createOutputFile(newName, cc.getOutputDir(), out.formatFile(), qid);
		val result = out.formatFile();
		java.lang.System.out.println(result);
		java.lang.System.out.println("-------------------------------------------");
	}
	
	method visitMethodDecl(node) {
		// TODO: Handle nested decls
		handleTopLevelMethodDecl(node);
	}
	
	method visitNewInstance(node) {
	
	}
	
	method visitQI(node) {
	
	}
	
	method visitStateDecl(node) {
	
	}
	
	method visitStringLiteral(node) {
		//out.setLocation(node.token);
		out.assign(g_y.name);
		out.plaidString(node.string);
		out.append(";");  
		out.updateVarDebugInfo(g_y.name);
	}
	
	method visitUnitLiteral(node) {
	
	}
	
	method visitWith(node) {
	
	}

	method createStateDecl() {
		idgen = new IdGen;
		var freshImports = idgen.getId();
		var theState = idgen.getId();
		var thePackage = qid.toString();
		
		//package and needed imports
		out.declarePackage(thePackage); //package qid;
		
		//determine what members this state has and add annotations
		var stateVars = genStateVars(qid, imports.getImports(), root.stateDef,
			root.caseOf); //TODO write this method in Plaid
		
		var members = StringBuilder.new();
		
		var i = 0;
		while { i < stateVars.size() } {
			members.append(stateVars.get(i).name + ",");
			i = i + 1;
		};
		
		var memberString = members.toString();
		if (memberString.length() > 0) {
			memberString = memberString.substring(0, memberString.length() - 1);
		};
		
		// state annotation and class definition
		out.topStateAnnotation(root.name.name, thePackage, memberString);
		out.declarePublicClass(root.name.name); 
		out.openBlock();  // public class f {
		
		//generate code to create the package scope with imports
		out.declarePublicStaticFinalVar(
			"java.util.List<plaid.runtime.utils.Import>",
			freshImports.name);
			
		g_freshImports = freshImports;
		g_theState = theState;
		g_stateVars = stateVars;
		imports.accept(this);
		out.declareGlobalScope(qid.toString(), freshImports.name);

		//annotation for the prototype object representing the state
		out.stateAnnotation(root.name.name);
		out.declarePublicStaticFinalVar(out.plaidObjectType, 
			root.name.name);
		
		out.openStaticBlock(); //static {
		out.declareLocalScope(out.globalScope);
		out.declareFinalVar(out.plaidStateType, theState.name);

		var idList = IDList.new(globals);
		// "this" should be visible during field initializations
		idList.add(ID.new(out.thisVar)); 
		
		// with caseOf State
		ifElse  (!root.isCaseOf) {
			// this is this declaration.  It will not have any members, but 
			// at runtime can forward to its enclosing (instantiated) state
			g_name = qid.toString() + "." + root.name.name;
			g_idList = idList;
			root.stateDef.accept(this);
			
			out.assignToPrototype(root.name.name, theState.name);
		}{
			var caseOfState = idgen.getId();
			var declaredState = idgen.getId();
			out.declareFinalVar(out.plaidStateType, caseOfState.name);
			g_name = out.anonymousDeclaration;
			g_idList = idList;
			root.caseOf.accept(this);
			out.declareFinalVar(out.plaidStateType, declaredState.name);
			
			// this is this declaration.  It will not have any members, but
			// at runtime can forward to its enclosing (instantiated) state
			g_name = qid.toString() + "." + root.name.name;
			g_declaredState = declaredState;
			stateDef.accept(this);
			
			//y = fresh1.with(fresh2); 
			out.assignToWith(theState.name,caseOfState.name,
				declaredState.name);  
					
			out.assignToPrototype(name.name, theState.name);
			
			// because of subtagging, we don't want the resulting object to 
			// have the caseOf's state's tag
			
			// If the caseOf State has a tag
			out.ifCondition(caseOfState.name + ".hasTag()"); 
			// //remove it from the prototype
			//out.append(root. name.name + ".removeTag(" + 
			//	caseOfState.name + ".getTag());"); 
		};
		out.closeBlock(); // } (for static block to init prototype)

		if (root.isCaseOf) { //if we have a tag	
			//Declare variable to hold the tag
			var tag = ID.new(name.name + "$Tag" + 
				PlaidConstants.ID_SUFFIX);
			var tagPath = qid.toString() + "." + root.name.name;
			out.tagAnnotation(tagPath);
			out.declarePublicStaticFinalVar(out.plaidTagType, tag.name);
			
			out.openStaticBlock(); //static {	
			var caseOfState = idgen.getId();
			out.declareFinalVar(out.plaidStateType, caseOfState.name());
			caseOf.accept(this);
			g_idList = IDList.new();
			g_theState = caseOfState;
			g_declaredState = out.anonymousDeclaration;
			caseOf.codegenState(this);
			//tag = new PlaidTag(caseOfState)
			out.assignToNewTag(tag.name, tagPath, caseOfState.name);
			
			out.closeBlock(); // } (for static block to init tag)
		};
		
		out.closeBlock(); // } (for class Def)
		
		FileGen.createOutputFile(name.name, cc.getOutputDir(),
			out.formatFile(), qid);
	}
}