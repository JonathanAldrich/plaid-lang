/**
 * Copyright (c) 2010 The Plaid Group (see AUTHORS file)
 * 
 * This file is part of Plaid Programming Language.
 *
 * Plaid Programming Language is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 *  Plaid Programming Language is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Plaid Programming Language.  If not, see <http://www.gnu.org/licenses/>.
 */

package plaid.typechecker;

import plaid.typechecker.context.*;
import plaid.ast.stateTable.*;
import plaid.ast.*;
import plaid.ast.types.*;

var counter = 0;

/**
 * Helper functions for typechecking
 */

val createError= fn (message, node) => {
	new Error{val message = message; val node=node;};
};

val createOuterError = fn (message, node, innerError) => {
	new OuterError{val message = message; val node=node; val innerError = innerError;};
};

val typeCheckExpression = fn (unique Context c, 
	unique StateTable st, 
	unique Expression e, 
	unique PermType pt) => {
		match(e) {
			case UnitLiteral {
				match(pt==getVoidType()) {
					case True { makePair(createSome(c), new None); }
					case False { makePair(new None, 
						createSome(createError("Unit literals must have type void.", e)));}
				}
			}
			default {
				makePair(new None, 
					createSome(createError("Unsupported expression type", e)));
			}
		}
};

val typeCheckDecl = fn (unique Decl d, unique StateTable st) => {
	match(d) {
		case FieldDecl {
			match(d.abstractField) {
				case True { makePair(createSome(d.fieldType), new None); }
				case False {
					val expCheck = typeCheckExpression(
						new Context, st, d.e, d.fieldType.binding);
					match(expCheck.second()) {
						case None {
							makePair(createSome(d.fieldType), new None);
						}
						case Some {
							makePair(new None, createSome(
								createOuterError("Field initialization expression has wrong type.", d, 
									expCheck.second().value)));
						}
					}
				}
			}
		}
		case MethodDecl {
		}
		case StateDecl {
		}
		default {
			new None;
		}
	}
};