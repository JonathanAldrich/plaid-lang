package V8Benchmarks.deltaBlue;


import plaid.collections.Stack;

/**
 * A JavaScript implementation of the DeltaBlue constraint-solving
 * algorithm, as described in:
 *
 * "The DeltaBlue Algorithm: An Incremental Constraint Hierarchy Solver"
 *   Bjorn N. Freeman-Benson and John Maloney
 *   January 1990 Communications of the ACM,
 *   also available as University of Washington TR 89-08-06.
 *
 * Beware: this benchmark is written in a grotesque style where
 * the constraint model is built by side-effects from constructors.
 * I've kept it this way to avoid deviating too much from the original
 * implementation.
 */


var NEWNONE = new None;

/* --- O b j e c t   M o d e l --- */

/*
//==================================still in javascript
Object.prototype.inheritsFrom = function (shuper) {
  function Inheriter() { }
  Inheriter.prototype = shuper.prototype;
  this.prototype = new Inheriter();
  this.superConstructor = shuper;
}
//==================================still in javascript
*/

state OrderedCollection {
	var elms =  makeStack();

	method add(elm) {
		this.elms.add(elm);
	}
	
	method at(index) {
		this.elms.get(index);
	}
	
	method size(){
		this.elms.size();
	}
	
	method removeFirst() {
		this.elms.pop()
	}
	
	method remove(elm) {
		this.elms.filterAll(fn(elem) => { elem != elm }); //debug, does this need to be stored?
	}

}

/* --- *
 * S t r e n g t h
 * --- */

/**
 * Strengths are used to measure the relative importance of constraints.
 * New strengths may be inserted in the strength hierarchy without
 * disrupting current constraints.  Strengths cannot be created outside
 * this class, so pointer comparison can be used for value comparison.
 */

//make a new Strength object with Strength{strenghtValue=<val>;name=<name>}
state Strength {
	var strenthValue;
	var name;
	
	method setStrengthFields(sv,n){
		this.strengthValue=sv;
		this.name=n;
	}
	
	method stronger(s1, s2){
		s1.strengthValue < s2.strengthValue;
	}
	
	method weaker(s1, s2) {
  		s1.strengthValue > s2.strengthValue;
	}
	
	method weakestOf(s1, s2){
		ifElse (this.weaker(s1,s2)){
			s1;
		}
		{
			s2;
		}
	}
	
	method strongest(s1, s2){
		ifElse (this.stronger(s1,s2)){
			s1;
		}
		{
			s2;
		}
	}
	
	method nextWeaker(){
		if (this.strengthValue==0){
			WEAKEST;
		};
		if (this.strengthValue==1){
			WEAK_DEFAULT;
		};
		if (this.strengthValue==2){
			NORMAL;
		};
		if (this.strengthValue==3){
			STRONG_DEFAULT;
		};
		if (this.strengthValue==4){
			PREFERRED;
		};
		if (this.strengthValue==5){
			REQUIRED
		};
	}

}

//Strength constants
var REQUIRED        = (new Strength).setFields(0, "required");
var STONG_PREFERRED = (new Strength).setFields(1, "strongPreferred");
var PREFERRED       = (new Strength).setFields(2, "preferred");
var STRONG_DEFAULT  = (new Strength).setFields(3, "strongDefault");
var NORMAL          = (new Strength).setFields(4, "normal");
var WEAK_DEFAULT    = (new Strength).setFields(5, "weakDefault");
var WEAKEST         = (new Strength).setFields(6, "weakest");



/* --- *
 * C o n s t r a i n t
 * --- */

/**
 * An abstract class representing a system-maintainable relationship
 * (or "constraint") between a set of variables. A constraint supplies
 * a strength instance variable; concrete subclasses provide a means
 * of storing the constrained variables and other information required
 * to represent a constraint.
 */


state Constraint {
	var strength;
	
	method setFields(s){
		this.strength=s;
	}
	
	
	/**
	 * Activate this constraint and attempt to satisfy it.
	 */
	method addConstraint(){
		this.addToGraph();
		planner.incrementalAdd(this);
	}
	
	 /**
	 * Attempt to find a way to enforce this constraint. If successful,
	 * record the solution, perhaps modifying the current dataflow
	 * graph. Answer the constraint that this constraint overrides, if
	 * there is one, or nil, if there isn't.
	 * Assume: I am not already satisfied.
	 */
	 method satisfy(mark){
	 	this.chooseMethod(mark);
		if (!this.isSatisfied()) {
		    if (this.strength == REQUIRED){
		      printLine("Could not satisfy a required constraint!");
		    };
		    NEWNONE;
		};
		this.markInputs(mark);
		var out = this.output();
		var overridden = out.determinedBy;
	 	if (overridden != NEWNONE) {overridden.markUnsatisfied();};
		out.determinedBy = this;
		if (!planner.addPropagate(this, mark)){
		  printLine("Cycle encountered");
		};
		out.mark = mark;
		overridden;
	 }
	 
	 method destroyConstraint() {
		  ifElse (this.isSatisfied()){
		  	planner.incrementalRemove(this);}
		  {this.removeFromGraph();};
	 }
	 
	 /**
	 * Normal constraints are not input constraints.  An input constraint
	 * is one that depends on external state, such as the mouse, the
	 * keybord, a clock, or some arbitraty piece of imperative code.
	 */
	 method isInput() {
	 	new False;
	 }
	
}


/* --- *
 * U n a r y   C o n s t r a i n t
 * --- */

/**
 * Abstract superclass for constraints having a single possible output
 * variable.
 */
 
state UnaryConstraint case of Constraint {
	var myOutput;
	var satisfied = new False;
	
	method setFields(v, stren){
		superConstructor.call(this, strength); //this is a likely problems spot; debug
		this.myOutput = v;
		this.addConstraint();
	}
	
	 /**
	 * Adds this constraint to the constraint graph
	 */
	method addToGraph(){
		this.myOutput.addConstraint(this);
		this.satisfied = new False;
	}
	
	 /**
	 * Decides if this constraint can be satisfied and records that
	 * decision.
	 */
	method chooseMethod(mark) {
		this.satisfied = (this.myOutput.mark != mark) && this.strength.stronger(this.strength, this.myOutput.walkStrength);
	}
	
	 /**
	 * Returns true if this constraint is satisfied in the current solution.
	 */
	method isSatisfied() {
		this.satisfied;
	}
	
	method markInputs(mark){
		NEWNONE; //has no inputs
	}
	
	/**
	 * Returns the current output variable.
	 */
	method output() {
		this.myOutput;
	}
		
	/**
	 * Calculate the walkabout strength, the stay flag, and, if it is
	 * 'stay', the value for the current output of this constraint. Assume
	 * this constraint is satisfied.
	 */
	method recalculate(){
		this.myOutput.walkStrength = this.strength;
		this.myOutput.stay = !this.isInput();
		if (this.myOutput.stay){
			this.execute(); //stay optimization
		};
	}
		
	/**
	 * Records that this constraint is unsatisfied
	 */
	method markUnsatisfied(){
		this.satisfied = new False;
	}
	
	method inputsKnown(){
		new True;
	}
	
	method removeFromGraph(){
		if (this.myOutput != NEWNONE){
			this.myOutput.removeConstraint(this);
		};
		this.satisfied=new False;
	}
}

//UnaryConstraint.inheritsFrom(Constraint); debug is this taken care of by making it a case of state?

/* --- *
 * S t a y   C o n s t r a i n t
 * --- */

/**
 * Variables that should, with some level of preference, stay the same.
 * Planners may exploit the fact that instances, if satisfied, will not
 * change their output during plan execution.  This is called "stay
 * optimization".
 */ 
 
state StayConstraint case of UnaryConstraint {
	method setFields(v,str){
		this.superConstructor.call(this,v,str);//another debug
	}

	method execute(){
		NEWNONE; //stay constraints do nothing
	}
}
 
 
/* --- *
 * E d i t   C o n s t r a i n t
 * --- */

/**
 * A unary input constraint used to mark a variable that the client
 * wishes to change.
 */
 
 state EditConstraint case of UnaryConstraint {
 
 /**
 * Edits indicate that a variable is to be changed by imperative code.
 */
 
	method setFields(v,str){
		this.superConstructor.call(this,v,str);//another debug
	}
 	
 	method isInput(){
 		new True;
 	}
 	
 	method execute(){
 		NEWNONE; //edit constraints do nothing
 	}
 }
 
 
/* --- *
 * B i n a r y   C o n s t r a i n t
 * --- */
 
 

var Direction_NONE = 0;
var Direction_FORWARD = 1;
var Direction_BACKWARD = -1;

/**
 * Abstract superclass for constraints having two possible output
 * variables.
 */ 
state BinaryConstraint case of Constraint {
	var v1;
	var v2;
	var direction;

	method setFields(var1, var2, strength) {
  		this.superConstructor.call(this, strength); //debug
		this.v1 = var1;
		this.v2 = var2;
		this.direction = Direction_NONE;
		this.addConstraint();
	}
	
	 /**
	 * Decides if this constraint can be satisfied and which way it
	 * should flow based on the relative strength of the variables related,
	 * and record that decision.
	 */
	
	method chooseMethod(mark) {
	
		if (this.v1.mark==mark){
			ifElse (this.v2.mark != mark && Strength.stronger(this.strength, this.v2.walkStrength)) {
				this.direction = Direction_FORWARD;
			}
			{
				this.direction = Direction_NONE;
			};
		};
		
		if (this.v2.mark==mark){
			ifElse (this.v1.mark != mark && Strength.stronger(this.strength, this.v1.walkStrength)) {
				this.direction = Direction_BACKWARD;
			}
			{
				this.direction = Direction_NONE;
			};
		};
		
		ifElse ((this.strength.weaker(this.v1.walkStrength,this.v2.walkStrength)){
			ifElse (this.strength.stronger(this.strength, this.v1,walkStrength)) {
				this.direction = Direction_BACKWARD;
			}
			{
				this.direction = Direction_NONE;
			};
		}
		{
			ifElse (this.strength.stronger(this.strength, this.v2,walkStrength)) {
				this.direction = Direction_FORWARD;
			}
			{
				this.direction = Direction_BACKWARD;
			};
		};
		
	}
		
	
	/**
	 * Add this constraint to the constraint graph
	 */
	method addToGraph() {
		this.v1.addConstraint(this);
		this.v2.addConstraint(this);
		this.direction = Direction_NONE;
	}
	
	/**
	 * Answer true if this constraint is satisfied in the current solution.
	 */
	method isSatisfied() {
		this.direction != Direction_NONE;
	}
		
	/**
	 * Mark the input variable with the given mark.
	 */
	method markInputs(mark) {
		this.input().mark = mark;
	}
	
	/**
	 * Returns the current input variable
	 */
	method input(){
		ifElse (this.direction==Direction_FORWARD) {
			this.v1;
		}
		{
			this.v2;
		};
	}
	
	/**
	 * Returns the current output variable
	 */
	method output(){
		ifElse (this.direction==Direction_FORWARD) {
			this.v2;
		}
		{
			this.v1;
		};
	}
		
	/**
	 * Calculate the walkabout strength, the stay flag, and, if it is
	 * 'stay', the value for the current output of this
	 * constraint. Assume this constraint is satisfied.
	 */
	method recalculate(){
		var ihn = this.input();
		var out = this.output();
		out.walkStrength = this.strength.weakesOf(this.strength, ihn.walkStrength);
		out.stay = ihn.stay;
		if (out.stay) {
			this.execute();
		};
	}
		
	/**
	 * Record the fact that this constraint is unsatisfied.
	 */
	method markUnsatisfied(){
		this.direction = Direction_NONE;
	}
	
	method inputsKnown(mark){
		var i= this.input();
		(i.mark == mark || i.stay || i.determinedBy==NEWNONE);
	}
	
	method removeFromGraph(){
		if (this.v1 != NEWNONE) {
			this.v1.removeConstraint(this);
		};
		if (this.v2 != NEWNONE) {
			this.v2.removeConstraint(this);
		};
		this.direction = Direction_NONE;
	}
}


/* --- *
 * S c a l e   C o n s t r a i n t
 * --- */
 

/**
 * Relates two variables by the linear scaling relationship: "v2 =
 * (v1 * scale) + offset". Either v1 or v2 may be changed to maintain
 * this relationship but the scale factor and offset are considered
 * read-only.
 */ 
 
 state ScaleConstraint case of BinaryConstraint {
 	var direction;
 	var scale;
 	var offset;
 	
 	method setFields(src, scale, offset, dest, strength) {
 		this.direction = Direction_NONE;
 		this.scale = scale;
 		this.offset = offset;
 		this.superConstructor.call(this, src, dest, strength); //debug problem
 	}
	 	
	/**
	 * Adds this constraint to the constraint graph.
	 */
 	method addToGraph() {
 		//ScaleConstraint.superConstructor.prototype.addToGraph.call(this);
 		// what is this????????? debug
 		this.scale.addConstraint(this);
 		this.offset.addContstraint(this);
 	}
 	
 	method removeFromGraph() {
 		//ScaleConstraint.superConstructor.prototype.removeFromGraph.call(this);
 		//debug
  		if (this.scale != NEWNONE) {this.scale.removeConstraint(this);};
  		if (this.offset != NEWNONE) {this.offset.removeConstraint(this);};
 		
 	}
 	
 	method markInputs(mark){
 		//ScaleConstraint.superConstructor.prototype.markInputs.call(this, mark); debug
  		this.scale.mark = mark;
  		this.offset.mark = mark;
 	}
 	
	/**
	 * Enforce this constraint. Assume that it is satisfied.
	 */
	 method execute(){
	 	ifElse(this.direction==Direction_FORWARD){
	 		this.v2.value = this.v1.value*this.scale.value+this.offset.value;
	 	}
	 	{
	 		this.v1.value = (this.v2.value - this.offset.value) / this.scale.value;
	 	};
	 }
	 
	/**
	 * Calculate the walkabout strength, the stay flag, and, if it is
	 * 'stay', the value for the current output of this constraint. Assume
	 * this constraint is satisfied.
	 */
	 method recalculate(){
	 	var ihn = this.input();
	 	var out = this.output();
	 	out.walkStrength = this.strenght.weakesOf(this.strength, ihn.walkStrength);
  		out.stay = ihn.stay && this.scale.stay && this.offset.stay;
  		if (out.stay){ this.execute();};
	 }
 }
 
 
 /* --- *
 * E q u a l i t  y   C o n s t r a i n t
 * --- */

/**
 * Constrains two variables to have the same value.
 */
 
 state EqualityConstraint case of BinaryConstraint {
 	method setFields(var1, var2, strength){
 		//EqualityConstraint.superConstructor.call(this, var1, var2, strength);
 	}
 	
	/**
 	* Enforce this constraint. Assume that it is satisfied.
 	*/
 	method execute(){
 		this.output().value=this.input().value;
 	}
 }
 	
 /* --- *
 * V a r i a b l e
 * --- */
 	
 	
/**
 * A constrained variable. In addition to its value, it maintain the
 * structure of the constraint graph, the current dataflow graph, and
 * various parameters of interest to the DeltaBlue incremental
 * constraint solver.
 **/
 
 state Variable{
 	var value;
 	var constraints = new OrderedCollection;
 	var determinedBy = NEWNONE;
 	var mark = 0;
 	var walkStrength = WEAKEST;
 	var stay = new True;
 	var name;
 	
 	method setFields(name, initialValue){
 		this.name=name;
 		this.value = initialValue;
 	}
 	
 	/**
	 * Add the given constraint to the set of all constraints that refer
	 * this variable.
	 */
 	method addConstraint(c) {
 		this.constraints.add(c);
 	}
 	
	/**
	 * Removes all traces of c from this variable.
	 */
 	method removeConstraint(c) {
 		this.constraints.remove(c);
 		if (this.determinedBy==c) {
 			this.determinedBy=NEWNONE;
 		};
 	}
 }
 

/* --- *
 * P l a n n e r
 * --- */

/**
 * The DeltaBlue planner
 */
 state Planner {
 	var mark=0;
 	
 	/**
	 * Attempt to satisfy the given constraint and, if successful,
	 * incrementally update the dataflow graph.  Details: If satifying
	 * the constraint is successful, it may override a weaker constraint
	 * on its output. The algorithm attempts to resatisfy that
	 * constraint using some other method. This process is repeated
	 * until either a) it reaches a variable that was not previously
	 * determined by any constraint or b) it reaches a constraint that
	 * is too weak to be satisfied using any of its methods. The
	 * variables of constraints that have been processed are marked with
	 * a unique mark value so that we know where we've been. This allows
	 * the algorithm to avoid getting into an infinite loop even if the
	 * constraint graph has an inadvertent cycle.
	 */
	 method incrementalAdd(c) {
	 	var mark = this.newMark();
	 	var overriden = c.satisfy(mark);
	 	while (overridden !=NEWNONE){
	 		overridden = overridden.satisfy(mark);
	 	};
	 }
	 
	/**
	 * Entry point for retracting a constraint. Remove the given
	 * constraint and incrementally update the dataflow graph.
	 * Details: Retracting the given constraint may allow some currently
	 * unsatisfiable downstream constraint to be satisfied. We therefore collect
	 * a list of unsatisfied downstream constraints and attempt to
	 * satisfy each one in turn. This list is traversed by constraint
	 * strength, strongest first, as a heuristic for avoiding
	 * unnecessarily adding and then overriding weak constraints.
	 * Assume: c is satisfied.
	 */
	 method incrementalRemove(c){
	 	var output = c.output();
	 	c.markUnsatisfied();
	 	c.removeFromGraph();
	 	var unsatisfied = this.removePropogateFrom(out);
	 	var strength = REQUIRED;
	 	//possible debug section below...might need to do this once no matter what
	 	while (strength!=WEAKEST){
	 		//possible debug; is map what I want? add map to collection?
	 		unsatisfied.map(fn(elem) => {
	 			if (elem.strength == strength){
	 				this.incrementalAdd(elem);
	 			};
	 			strength=strength.nextWeaker();
	 			});
	 	};
	 } 

	/**
	 * Select a previously unused mark value.
	 */
	 method newMark() {
	 	this.currentMark+1;
	 }
	 
	 /**
 	* Extract a plan for resatisfaction starting from the given source
	 * constraints, usually a set of input constraints. This method
	 * assumes that stay optimization is desired; the plan will contain
	 * only constraints whose output variables are not stay. Constraints
	 * that do no computation, such as stay and edit constraints, are
	 * not included in the plan.
	 * Details: The outputs of a constraint are marked when it is added
	 * to the plan under construction. A constraint may be appended to
	 * the plan when all its input variables are known. A variable is
	 * known if either a) the variable is marked (indicating that has
	 * been computed by a constraint appearing earlier in the plan), b)
	 * the variable is 'stay' (i.e. it is a constant at plan execution
	 * time), or c) the variable is not determined by any
	 * constraint. The last provision is for past states of history
	 * variables, which are not stay but which are also not computed by
	 * any constraint.
	 * Assume: sources are all satisfied.
	 */
	 method makePlan(sources) {
	 	var mark = this.newMark();
	 	var plan = new Plan;
	 	var todo = sources;
	 	while (todo.size() >0){
	 		var c = todo.removeFirst();
	 		if (c.output().mark != mark && c.inputsKnown(mark)){
	 			plan.addConstraint(c);
	 			c.output().mark = mark;
	 			this.addConstraintsConsumingTo(c.output(),todo);
	 		};
	 	};
	 	plan;
	 }
	 
	/**
	 * Extract a plan for resatisfying starting from the output of the
	 * given constraints, usually a set of input constraints.
	 */
	 method extractPlanFromConstraints(constraints){
	 	var sources = new OrderedCollection;
	 	constraints.map(fn(c) => {
	 				if(c.isinput() && c.isSatisfied()){
	 					//not in plan already and eligible for inclusion
	 					sources.add(c);
	 				};
	 			});
	 	this.makePlan(sources);
	 }
	 
	/**
	 * Recompute the walkabout strengths and stay flags of all variables
	 * downstream of the given constraint and recompute the actual
	 * values of all variables whose stay flag is true. If a cycle is
	 * detected, remove the given constraint and answer
	 * false. Otherwise, answer true.
	 * Details: Cycles are detected when a marked variable is
	 * encountered downstream of the given constraint. The sender is
	 * assumed to have marked the inputs of the given constraint with
	 * the given mark. Thus, encountering a marked node downstream of
	 * the output constraint means that there is a path from the
	 * constraint's output to one of its inputs.
	 */
	 method addPropogate(c, mark){
	 	var todo = new OrderedCollection;
	 	todo.add(c);
	 	while (todo.size()>0){
	 		var d = todo.removeFirst();
	 		if (d.output().mark==mark){
	 			this.incrementalRemove(c);
	 			new False;
	 		};
	 		d.recalculate();
	 		this.addConstraintsConsumingTo(d.output(),todo);
	 	};
	 	new True;
	 }
	 
	/**
	 * Update the walkabout strengths and stay flags of all variables
	 * downstream of the given constraint. Answer a collection of
	 * unsatisfied constraints sorted in order of decreasing strength.
	 */
	 method removePropogateFrom(out){
	 	out.determinedBy=NEWNONE;
	 	out.walkStrength = WEAKEST;
	 	out.stay = new True;
	 	var unsatisfied = new OrderedCollection;
	 	var todo = new OrderedCollection;
	 	todo.add(out);
	 	while (todo.size()>0){
	 		var v = todo.removeFirst();
	 		constraints.map(fn(c) => {
	 				if (!c.isSatisfied()){
	 					unsatisfied.add(c);
	 				};
	 			});
	 		var determining = v.determinedBy;
	 		constraints.map(fn(next) => {
	 			if (next != determining && next.isSatisfied()) {
	 				next.recalculate();
	 				todo.add(next.output());
	 			};
	 		});
	 	};
	 	unsatisfied;
	 }
	 
	 method addConstraintsConsumingTo(v, coll){
	 	var determining = v.determinedBy;
	 	var cc = v.constraints;
	 	cc.map(fn(c) => {
	 		if (c!=determining && c.isSatisfied()){
	 			coll.add(c);
	 		};
	 	});
	 }
 }
 	
 

/* --- *
 * P l a n
 * --- */

/**
 * A Plan is an ordered list of constraints to be executed in sequence
 * to resatisfy all currently satisfiable constraints in the face of
 * one or more changing inputs.
 */	
 
 state Plan {
 	var v = new OrderedCollection;
 	
 	method addConstraint(c){
 		this.v.add(c);
 	}
 	
 	method size(){
 		this.v.size();
 	}
 	
 	method constraintAt(index) {
 		this.v.at(index);
 	}
 	
 	method execute() {
 		this.v.map(fn(c) => {
 			c.execute();
	 	});
 	}
 }


/* --- *
 * M a i n
 * --- */

/**
 * This is the standard DeltaBlue benchmark. A long chain of equality
 * constraints is constructed with a stay constraint on one end. An
 * edit constraint is then added to the opposite end and the time is
 * measured for adding and removing this constraint, and extracting
 * and executing a constraint satisfaction plan. There are two cases.
 * In case 1, the added constraint is stronger than the stay
 * constraint and values must propagate down the entire length of the
 * chain. In case 2, the added constraint is weaker than the stay
 * constraint so it cannot be accomodated. The cost in this case is,
 * of course, very low. Typical situations lie somewhere between these
 * two extremes.
 */ 
 
 
//===================================================still javascript below

method chainTest(n) {
  planner = new Planner;
  var prev = NEWNONE;
  var first = NEWNONE;
  var last = NEWNONE;

  // Build chain of n equality constraints
  var counter = 0;
  while(counter<n){
  	counter=counter+1;
  	var name = "v"+i;
  	var v = new Variable;
  	v.setFields(name);
  	if (prev!=null){
  		var ec = new EqualityConstraint;
  		ec.setFields(prev, v, REQUIRED);
  	};
  	if (counter==0) {first = v;};
  	if (counter==n) {last=v;};
  	prev=v;
  };

  var sc = new StayConstraint;
  sc.setFields(last, STRONG_DEFAULT);
  var edit = new EditConstraint;
  edit.setFields(first, PREFERRED);
  var edits = new OrderedCollection;
  edits.add(edit);
  var plan = planner.extractPlanFromConstraints(edits);
  
  counter=0;
  while (counter<100){
  	counter=counter+1;
  	first.value = counter;
  	plan.execute();
  	if (last.value !=i) {
  		printLine("Chain test failed.");
  	};
  };
}

/**
 * This test constructs a two sets of variables related to each
 * other by a simple linear transformation (scale and offset). The
 * time is measured to change a variable on either side of the
 * mapping and to change the scale and offset factors.
 */
method projectionTest(n) {
  planner = new Planner;
  var scale = new Variable;
  scale.setFields("scale", 10);
  var offset = new Variable;
  offset.setFields("offset", 1000);
  var src = NEWNONE;
  var dst = NEWNONE;

  var dests = new OrderedCollection;
  
  var counter=0;
  while (counter<n){
  	counter=counter+1;
  	src = new Variable;
  	src.setFields("src"+i, i);
  	dst = new Variable;
  	dst.setFields("dst"+i, i);
  	dests.add(dst);
  	var stay = new StayConstraint;
  	stay.setFields(src, NORMAL);
  	var scale = new ScaleConstraint;
  	scale.setFields(src, scale, offset, dst, REQUIRED);
  };

  change(src, 17);
  if (dst.value != 1170) {printLine ("Projection 1 failed");};
  change(dst, 1050);
  if (src.value != 5) {printLine("Projection 2 failed");};
  change(scale, 5);
  counter=0;
  while(counter<(n-1)){
  	counter=counter+1;
  	if (dests.at(i).value != i*5+1000){
  		printLine("Projection 3 failed");
  	};
  };
  
  change(offset, 2000);
  couter=0;
  while (counter<(n-1)){
  	counter=counter+1;
  	if(dests.at(i).value != i*5+2000){
  		printLine("Projection 4 failed");
  	};
  };
}

method change(v, newValue) {
  var edit = new EditConstraint;
  edit.setFields(v, PREFERRED);
  var edits = new OrderedCollection;
  edits.add(edit);
  var plan = planner.extractPlanFromConstraints(edits);
  var counter=0;
  while (counter<10){
  	counter=counter+1;
  	v.value = newValue;
  	plan.execute();
  };
  edit.destroyConstraint();
}

// Global variable holding the current planner.
var planner = NEWNONE

method DeltaBlue() {
  chainTest(100);
  projectionTest(100);
}

method main(){
	DeltaBlue();
}