package plaid.ast;

import plaid.lang.*;
import plaid.ast.types.*;

state ASTTranslator {
	// TODO: Refactor this into a Plaid List library
	method map(f, list) {
		val iter = list.iterator();
		val newList = new plaid.lang.List { var head = new plaid.lang.Nil; };
		while {iter.hasNext();} {
			newList.add(f(iter.next()));
		};
		newList
	}
	
	method translateSet(fVal, set) {
        val newSet = HashSet.new();
        val iter = set.iterator();
        while { iter.hasNext(); }{
            newSet.add(fVal (iter.next()));
        };
        newSet;
    }
    
    method translateMap(fKey, fVal, map) {
    	val newMap = HashMap.new();
    	val iter = map.keySet().iterator();
    	var key = unit;
    	while { iter.hasNext(); }{
    		key = iter.next();
    		newMap.put(fKey (key), fVal (map.get(key)));
    	};
    }
	
	method getToken(root) {
		ifElse (root.hasToken()) {
			new Some { val value = this.translateAST(root.getToken()); };
		} {
			new None;
		};
	}
	
	method translatePermission(root) {
		// TODO: I'm not sure this is the correct way to translate this.
		ifElse (root.equals(plaid.compilerjava.types.Permission.FULL)) {
			new FullPermission {
				val /*Option Token*/ token = this.getToken(root);
				val /*String*/ image = root.getImage();
			};
		} {
			ifElse (root.equals(plaid.compilerjava.types.Permission.IMMUTABLE)) {
				new ImmutablePermission {
					val /*Option Token*/ token = this.getToken(root);
					val /*String*/ image = root.getImage();
				};
			} {
				ifElse (root.equals(plaid.compilerjava.types.Permission.PURE)) {
					new PurePermission {
						val /*Option Token*/ token = this.getToken(root);
						val /*String*/ image = root.getImage();
					};
				} {
					ifElse (root.equals(plaid.compilerjava.types.Permission.UNIQUE)) {
						new UniquePermission {
							val /*Option Token*/ token = this.getToken(root);
							val /*String*/ image = root.getImage();
						};
					} {
					    ifElse (root.equals(plaid.compilerjava.types.Permission.SHARED)) {
					        new SharedPermission {
                                val /*Option Token*/ token = this.getToken(root);
                                val /*String*/ image = root.getImage();
                            };
                        } {
                        	ifElse (root.equals(plaid.compilerjava.types.Permission.DYN)) {
                        		new DynPermission {
                        			val /*Option Token*/ token = this.getToken(root);
                                	val /*String*/ image = root.getImage();
                        		}
                        	
                        	} {
                        		ifElse (root.equals(plaid.compilerjava.types.Permission.NONE)) {
                        			new NonePermission {
                        				val /*Option Token*/ token = this.getToken(root);
                                		val /*String*/ image = root.getImage();
                        			}
                        		} {
                            		java.lang.System.out.println("Unknown Permission: ");
									java.lang.System.out.println((root.getClass()).getName());
									NONE;
								};
							};
                        };              
				    };
				};
			};
		};
	}
	
	method translateAST(root) {
		match(root) {
			case plaid.compilerjava.AST.Application {
				new Application {
					val /*Option Token*/ token = this.getToken(root);
					val /*Expression*/ f = this.translateAST(root.getFunction());
					val /*Expression*/ arg = this.translateAST(root.getArg());
				};
			}
			case plaid.compilerjava.AST.Assignment {
				new Assignment {
					var /*Option Token*/ token = this.getToken(root);
					var /*Option Expression*/ target = ifElse (root.hasTarget()) {
							new Some { val value = this.translateAST(root.getTarget()); };
						} {
							new None;
						};
					var /*ID*/ field = this.translateAST(root.getField());
					var /*Expression*/ value = this.translateAST(root.getValue());
				};
			}
			case plaid.compilerjava.AST.Case {
				new Case {
					val /*Option Token*/ token = this.getToken(root);
					val /*Option QI*/ qi = ifElse (root.hasQi()) {
							new Some { val value = this.translateAST(root.getQi()); };
						} {
							new None;
						};
					val /*ID*/ x = ifElse (root.hasX()) {
							new Some { val value = this.translateAST(root.getX());};
						} {
							new None;
						};
					val /*Expression*/ e = this.translateAST(root.getE());
					val /*boolean*/ defaultCase = root.isDefaultCase();
					val /*boolean*/ boundVar = root.isBoundVar();
				};
			}
			case plaid.compilerjava.AST.ChangeState {
				new ChangeState {
					val /*Option Token*/ token = this.getToken(root);
					val /*Expression*/ e = this.translateAST(root.getE());
					val /*State*/ s = this.translateAST(root.getSt());
				};
			}
			case plaid.compilerjava.AST.CompilationUnit {
				new CompilationUnit {
					val /*List<Decl>*/ decls = this.map(this.translateAST, root.getDecls());
					val /*List<String>*/ packageName = this.map(fn (s) => {s}, root.getPackageName());
					val /*ImportList*/ imports = this.translateAST(root.getImports());
					val /*String*/ sourceFile = root.getSourceFile().getName();
				};
			}
			case plaid.compilerjava.AST.DeclList {
				new DeclList {
					val /*Option Token*/ token = this.getToken(root);
					val /*List<Decl>*/ decls = this.map(this.translateAST, root.getDecls());
				};
			}
			case plaid.compilerjava.AST.Dereference {
				new Dereference {
					val /*Option Token*/ token = this.getToken(root);
					val /*Expression*/ left = this.translateAST(root.getLeft());
					val /*ID*/ right = this.translateAST(root.getRight());
				};
			}
			case plaid.compilerjava.AST.DestructiveDereference {
				new DestructiveDereference {
					val /*Option Token*/ token = this.getToken(root);
					val /*Expression*/ left = this.translateAST(root.getLeft());
					val /*ID*/ right = this.translateAST(root.getRight());
				}
			}
			case plaid.compilerjava.AST.FieldDecl {
				new FieldDecl {
					val /*Option Token*/ token = this.getToken(root);
					val /*ID*/ f = this.translateAST(root.getF());
					val /*Expression*/ e = this.translateAST(root.getE());
					val /*boolean*/ abstractField = root.isAbstractField();
					val /*boolean*/ immutableField = root.getImmutable();
					val /*FieldType*/ fieldType = this.translateType(root.getFieldType());
				};
			}
			case plaid.compilerjava.AST.ID {
				new ID {
					val /*Option Token*/ token = this.getToken(root);
					val /*String*/ name = root.getName();
				};
			}
			case plaid.compilerjava.AST.ImportList {
				new ImportList {
					val /*List<QualifiedID>*/ imports = this.map(this.translateAST, root.getImports());
					val /*Option Token*/ token = this.getToken(root);
				};
			}
			case plaid.compilerjava.AST.IntLiteral {
				new IntLiteral {
					val /*Option Token*/ token = this.getToken(root);
					val /*int*/ integer = root.getValue();
				};
			}
			case plaid.compilerjava.AST.Lambda {
				new Lambda {
					val /*Option Token*/ token = this.getToken(root);
					val /*ID*/ x = ifElse (root.hasArg()) {
							new Some { val value = this.translateAST(root.getVar()); };
						} {
							new None;
						};
					val /*Expression*/ body = this.translateAST(root.getBody());
					val /*LambdaType*/ lambdaType = this.translateType(root.getType());
				};
			}
			case plaid.compilerjava.AST.LetBinding {
				ifElse (root.isAnnotated()) {
					new AnnotatedLetBinding {
						val /*Option Token*/ token = this.getToken(root);
						val /*ID*/ x = this.translateAST(root.getX());
						val /*Expression*/ exp = this.translateAST(root.getExp());
						val /*Expression*/ body = this.translateAST(root.getBody());
						val /*boolean*/ mutable = root.isMutable();
						val /*PermType*/ annotation = this.translateType(root.getPermType());
					}
				} {
					new UnannotatedLetBinding {
						val /*Option Token*/ token = this.getToken(root);
						val /*ID*/ x = this.translateAST(root.getX());
						val /*Expression*/ exp = this.translateAST(root.getExp());
						val /*Expression*/ body = this.translateAST(root.getBody());
						val /*boolean*/ mutable = root.isMutable();
					};
				}
			}
			case plaid.compilerjava.AST.Match {
				new Match {
					val /*Option Token*/ token = this.getToken(root);
					val /*Expression*/ e = this.translateAST(root.getE());
					val /*List<Case>*/ caseList = this.map(this.translateAST, root.getCaseList());
				};
			}
			case plaid.compilerjava.AST.MethodCall {
				new MethodCall {
					val /*Expression*/ receiver = this.translateAST(root.getReceiver());
					val /*ID*/ methodName = this.translateAST(root.getMethod());
					val /*Expression*/ argument = this.translateAST(root.getArgument());
					val /*Option Token*/ token = this.getToken(root);
				}
			}
			case plaid.compilerjava.AST.MethodDecl {
				new MethodDecl {
					val /*Option Token*/ token = this.getToken(root);
					val /*String*/ name = root.getName();
					val /*Expression*/ body = this.translateAST(root.getBody());
					val /*Option ID*/ arg = ifElse (root.hasArg()) {
							new Some { val value = this.translateAST(root.getArg()); };
						} {
							new None;
						};
					val /*boolean*/ abstractMethod = root.isAbstractMethod();
					val /*MethodTypeDecl*/ methodType = this.translateType(root.getMethodType());
				};
			}
//			case plaid.compilerjava.AST.MethodTypeDecl {
//				new MethodTypeDecl {
//					val /*Option Token*/ token = this.getToken(root);
//					val /*ID*/ name = this.translateAST(root.getName());
//					val /*PermType*/ retPermType = this.translateAST(root.getRetPermType());
//					val /*List<PermType>*/ argTypes = this.map(this.translateAST, root.getArgTypes());
//					val /*List<ID>*/ argNames = this.map(this.translateAST, root.getArgNames());
//				};
//			}
			case plaid.compilerjava.AST.NewInstance {
				new NewInstance {
					val /*Option Token*/ token = this.getToken(root);
					val /*State*/ s = this.translateAST(root.getSt());
				};
			}
			case plaid.compilerjava.AST.QI {
				new QI {
					val /*Option Token*/ token = this.getToken(root);
					val /*List<String>*/ qid = this.map(fn (s) => {s}, root.getQid());
					val /*Option DeclList*/ initState = ifElse (root.hasInit()) {
							new Some { val value = this.translateAST(root.getInitState()); };
						} {
							new None;
						};
				};
			}
			case plaid.compilerjava.AST.StateDecl {
				new StateDecl {
					val /*Option Token*/ token = this.getToken(root);
					val /*ID*/ name = this.translateAST(root.getID());
					val /*State*/ stateDef = this.translateAST(root.getStateDef());
					val /*boolean*/ isCaseOf = root.getIsCaseOf();
					val /*QI*/ caseOf = ifElse (root.getIsCaseOf()) {
							new Some { val value = this.translateAST(root.getCaseOf()); };
						} {
							new None;
						};
				};
			}
			case plaid.compilerjava.AST.StringLiteral {
				new StringLiteral {
					val /*Option Token*/ token = this.getToken(root);
					val /*String*/ string = root.toString();
				};
			}
			case plaid.compilerjava.AST.UnitLiteral {
				new UnitLiteral {
					val /*Option Token*/ token = this.getToken(root);
				};
			}
			case plaid.compilerjava.AST.With {
				new With {
					val /*Option Token*/ token = this.getToken(root);
					val /*State*/ s1 = this.translateAST(root.getR1());
					val /*State*/ s2 = this.translateAST(root.getR2());
				};
			}
			case plaid.compilerjava.util.QualifiedID {
				new QI {
					val /*Option Token*/ token = unit;
					val /*List<String>*/ qid = this.map(fn (s) => {s},  root.getQidList());
				};
			}
			case  plaid.compilerjava.coreparser.Token { 
			    new Token {
			        val beginLine   = root.beginLine;
			        val beginColumn = root.beginColumn;
			        val endLine     = root.endLine;
			        val endColumn   = root.endColumn;
			        val image       = root.image;
			    };
			}
			default {
				java.lang.System.out.print("Unknown AST node type: ");
				java.lang.System.out.println((root.getClass()).getName());
			}
		}
	}
	
	method translateType(type) {
		match (type) {
			case plaid.compilerjava.types.ChangeType {
				new ChangeType {
					val /*PermType*/ input = this.translateType(type.getInput());
					val /*PermType*/ output = this.translateType(type.getOutput());
					val /*Boolean*/ borrow = type.borrows(); //this.translateBoolean(type.borrows());
				}
			}
			case plaid.compilerjava.types.FieldType {
				new FieldType {
					val /*PermType*/ permType = this.translateType(type.getPermType());
					val /*ID*/ name = this.translateAST(type.getName());
					val /*boolean*/ isImmutable = type.isImmutable();
				}
			}
			case plaid.compilerjava.types.LambdaType {
				new LambdaType {
					var /*PermType*/ returnType = this.translateType(type.getReturnType());
					val /*List<ChangeType>*/ argTypes = this.map(this.translateType, type.getArgTypes());
					val /*Map<ID,ChangeType>*/ environmentTypes = this.translateMap(this.translateAST, this.translateType, type.getEnvironmentTypes());
				}
			}
			case plaid.compilerjava.types.MethodType {
				new MethodType {
					val /*ID*/ name = this.translateAST(type.getName());
					val /*PermType*/ returnType = this.translateType(type.getReturnType());
					val /*List<ChangeType>*/ argTypes = this.map(this.translateType, type.getArgTypes());
					val /*ChangeType*/ receiverType = this.translateType(type.getReceiverType());
					val /*Map<ID,ChangeType>*/ environmentTypes = this.translateMap(this.translateAST, this.translateType, type.getEnvironmentTypes());
				}
			}
			case plaid.compilerjava.types.ObjectType {
				ifElse (type.isNominal()) {
					new NominalType {
						val /*ID*/ typeName = this.translateAST(type.getNominalType());
					}
				}/* else */ {
					new StructuralType {
						val /*Set<ID>*/ typeAbbrevs = this.translateSet(this.translateAST, root.getTypeAbbrevs());
						val /*Set<TypeDecl>*/ typeDecls = this.translateSet(this.translateAST, root.getTypeDecls());
					};
				}
			}
			case plaid.compilerjava.types.PermType {
				new PermType {
					val /*Permission*/ perm = this.translatePermission(type.getPermission());
					val /*Type*/ type = this.translateType(type.getType());
					val /*Boolean*/ borrowed = type.isBorrowed();
				}
			}
			default {
				java.lang.System.out.print("Unknown Type node type: ");
				java.lang.System.out.println((root.getClass()).getName());
			}
		}
	
	}
}