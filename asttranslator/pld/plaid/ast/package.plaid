package plaid.ast;

method main() {
	var javaAST = plaid.compilerjava.ParserCore.parse(java.io.FileInputStream.new(java.io.File.new("../compilerTests/coreExamples/AEminium/unpackGroups/package.plaid")));
	val translator = new ASTTranslator;
	var plaidAST = translator.translateAST(javaAST);

    //val json = plaid.lang.Serialization.toJSON(plaidAST);
    //System.out.println(json);
    //val file = java.io.FileWriter.new("AST.json");    
    //file.write(json);
    //file.close();

    //val reconAST = plaid.lang.Serialization.fromJSON(json);

    plaidAST.accept(new visitor.PrintVisitor);
    //reconAST.accept(new visitor.ASTViewer);
}



//Need to set token, etc
val (immutable String >> void) -> unique ID createID = fn (immutable String >> void name) => {
	new ID {
		val immutable String name = name;
	}
};


val () -> unique Token makeToken = fn() => {
	new Token {
		val immutable Integer beginLine = 0;
		val immutable Integer beginColumn = 0;
		val immutable Integer endLine = 0;
		val immutable Integer endColumn = 0;
		val immutable String image = ""; 
	};
};

val (immutable String) -> unique ID makeID = fn(immutable String n) => {
	new ID {
		val immutable Token token = makeToken();
		val immutable String name = n;
	};
};

val (immutable String) -> unique ID makeTempID = fn(immutable String n) => {
	new ID {
		val immutable Token token = makeToken();
		val immutable String name = n;
		override val immutable Boolean isTemp = true;
	};
};

val (unique ID, unique Expression, unique Expression) -> unique UnannotatedLetBinding makeLetBinding = fn(unique ID x, unique Expression exp, unique Expression body) => {
	new UnannotatedLetBinding {
		val immutable Token token = makeToken();
		val unique ID x = x;
		val unique Expression exp = exp;
		val unique Expression body = body;
	};
};

val (unique Expression, unique ID) -> unique Dereference makeDereference = fn(unique Expression left, unique ID right) => {
	new Dereference {
		val immutable Token token = makeToken();
		val unique Expression left = left;
		val unique ID right = right;
	};
}; 

val makeMethodCall = fn(receiver, name, args) => {
	new MethodCall {
		val unique Expression receiver     = receiver;
		val immutable ID methodName        = name;
		val /*List<Expression>*/ arguments = args;
		val immutable Token token          = makeToken();
	};
};

val makeApplication = fn(f, args) => {
	new Application {
		val immutable Token token          = makeToken();
		val unique Expression f            = f;
		val /*List<Expression>*/ arguments = args;
	};
};

val (unique Expression) -> unique Case makeCase = fn(unique Expression e) => {
	new Case {
		val immutable Token token         = makeToken();
		val /*Option QI*/ qi              = new None;
		val /*Option ID*/ x               = new None;
		val unique Expression e           = e;
		val immutable Boolean defaultCase = false;
		val immutable Boolean boundVar    = false;
	};
};

val makeMatch = fn(e, cases) => {
	new Match {
		val immutable Token token   = makeToken();
		val unique Expression e     = e;
		val /*List<Case>*/ caseList = cases;
	};
};

val makeLambda = fn(body) => {
	new Lambda {
		val immutable Token token = makeToken();
		val /*List<ID>*/ arguments = makeEmptyList();
		val unique Expression body = body;
		// Set up a dummy type.
		val immutable LambdaType lambdaType = new LambdaType {
			var immutable PermType returnType = new UncheckedType;
			val /*unique List<immutable ChangeType>*/ argTypes = makeEmptyList();
			val /*unique Map<immutable ID,immutable ChangeType>*/ environmentTypes = java.util.HashMap.new();
		};
		var /*Option ID*/ recursiveName = new None;
	};
};

val unique Expression makeNewInstance = fn(s) => {
	new NewInstance {
		val immutable Token token = makeToken();
		val unique State s = s;
	};
};

val makeQI = fn(qid, initState) => {
	// TODO: Do this right.
	
	val /*List<String>*/ l = makeEmptyList();
	l.add(qid);
	
	new QI {
		val immutable Token token = makeToken();
		val /*List<String>*/ qid = l; 
		val /*Option DeclList*/ initState = initState;
	};
};

val makeDeclList = fn(decls) => {
	new DeclList {
		val immutable Token token = makeToken();
		val /*List<Decl>*/ decls = decls;
	};
};

val makeFieldDecl = fn(name, exp) => {
	new FieldDecl {
		val immutable Token token = makeToken();
		val /*ID*/ f = name;
		val /*Expression*/ e = exp;
		val /*boolean*/ abstractField = false;
		val /*boolean*/ immutableField = false;
		val /*boolean*/ overrides = false;
		val /*FieldType*/ fieldType = new FieldType;
	};
};

val makeChangeState = fn(exp, s) => {
	new ChangeState {
		val immutable Token token = makeToken();
		val unique Expression e = exp;
		val unique State s = s;
	};
};