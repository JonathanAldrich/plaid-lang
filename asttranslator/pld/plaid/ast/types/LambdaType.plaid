package plaid.ast.types;

import plaid.lang.*;

/**
 *	represents a lambda type as an object type
 *	this could also be represented as a PlaidType, but instead for
 *	consistency and flexibility it is an object Type.  Currently,
 *	all LambdaType objects are considered to have an Immutable 
 *	permission, but later we could allow other permissions under
 *	this structure.
 */
state LambdaType case of ObjectType {

	var /*PermType*/ returnType; //TODO: change back to val when have restricted update state change working for PermType <- PermType
	val /*List<ChangeType>*/ argTypes;
	val /*Map<ID,ChangeType>*/ environmentTypes;
	
	method ==(other) {
		match (other) {
			case LambdaType {
				this.returnType == other.returnType
				&& this.argTypes.zip(other.argTypes)
				                   .map(fn (p) => { p.first() == p.second(); })
				                   .foldr(fn (x, y) => { x && y; }, true);
			}
			default {
				false;
			}
		};
	}
	
	method /*boolean*/ hasArg() {
		match (argTypes.head) {
			case Nil { false }
			case Cons { true }
		}
	}
	
	method toString() {
		var /*String*/ envTypeString = "";
		val envIter = environmentTypes.keySet().iterator();
		while { envIter.hasNext() } {
			val /*ID*/ envVar = envIter.next();
			val /*ChangeType*/ envVarType = environmentTypes.get(envVar);
			envTypeString = envTypeString + ", " + envVarType.toString() + " " + envVar.name;
		};
		if (envTypeString.length() > 0) {
			envTypeString = "[" + envTypeString.substring(2) + "]";
		};
		
		var /*String*/ args = "";
		ifElse (this.hasArg()) {
			args = this.argTypes.foldr(fn (a,r) => ", " + a.toString() + r, "");
			args = "(" + args.substring(2) + ")";
		} {
			args = "()";
		};
		
		args + envTypeString + " -> " + returnType.toString();
	}
	
	method /*Boolean*/ subtypeOf(/*Type*/ other, /*StateTable*/ stateTable) {
		match (other) {
			case LambdaType {
				//requirements:
				
				//1) this.returnType <: other.returnType
				val /*Boolean*/ retTypeOk = this.returnType.isSubPermTypeOf(other.returnType, stateTable); //error message elsewhere
				
				//2) same number and compatible arg types
				var /*Boolean*/ argsOk = this.argTypes.length() == other.argTypes.length();
				ifElse (argsOk) {
					val /*List<Pair<ChangeType,ChangeType>>*/ pairedArgs = this.argTypes.zip(other.argTypes);
					argsOk = pairedArgs.foldr(fn (p,z) => {
					
						var inputOk = false;
						//2a) other.argTypes[i].input <: this.argTypes[i].input //TODO: multiple args
						if ( p.snd.input.isSubChangeTypeOf(p.fst.input, stateTable)) {
							inputOk = true; 
						};
						
						var outputOk = false;
						//2b) this.argTypes[i].output <: other.argTypes[i].output
						if ( p.fst.output.isSubChangeTypeOf(p.snd.output, stateTable)) {
							outputOk = true;
						};
					
						inputOk && outputOk && z;
					
					}, true);
				} {
					java.lang.System.out.println("SUBTYPING FAILED : mismatched number of args");
				};
				
				//4) //TODO: environment Types
				
				retTypeOk && argsOk;
			}
			default { 
				java.lang.System.out.println("TYPECHECK FAILED: lambda must subtype another lambda");
				false 
			}
		}
	}
	
	//try to find the least upper bound on the two lambda types
	//for arguments and environment variables, we need:
	//	most specific input (the other type must be a supertype and we need the weakest permission)
	//	least specific output (the other must be a subtype)
	//need the same number of arguments
	//in terms of environment variables they must have the same list //TODO: can we do better than this?
	method /*Type*/ join(/*Type*/ other, /*StateTable*/ stateTable) {
		match (other) {
			case LambdaType {
				ifElse (this.argTypes.length() == other.argTypes.length()) {
					ifElse (this.environmentTypes.size() == other.environmentTypes.size()) {
						val /*List<Pair<ChangeType,ChangeType>>*/ argZip = this.argTypes.zip(other.argTypes);
						val /*List<ChangeType>*/ joinedArgs = argZip.map(fn (p) => {
							//TODO : FIXME - update to new rep of Change Type
							new ChangeType {
								val input = p.fst.input.join(p.snd.input, stateTable);
								val output = p.fst.output.join(p.snd.output, stateTable);
								val borrow = p.fst.borrow && p.snd.borrow;
							}
						});
						var /*boolean*/ envOk = true;
						val /*Map<ID,ChangeType>*/ joinedEnv = java.util.HashMap.new();
						val envIter = this.environmentTypes.keySet().iterator();
						while { envOk && envIter.hasNext() } {
							val /*ID*/ envID = envIter.next()
							ifElse (other.environmentTypes.containsKey(envID)) {
								val /*ChangeType*/ thisEnvCT = this.environmentTypes.get(envID);
								val /*ChangeType*/ otherEnvCT = other.environmentTypes.get(envID);
								joinedEnv.put(envID,new ChangeType {
									val input = thisEnvCT.input.join(otherEnvCT.input,stateTable);
									val output = thisEnvCT.output.join(otherEnvCT.output, stateTable);
									val borrow = thisEnvCT.borrow && otherEnvCT.borrow;
								});
							} {
								java.lang.System.out.println("JOIN FAILED: both lambdas do not specify environment variable " + envID.name);
							}
							
						};
						
						ifElse (envOk) {
							//success!
							val /*PermType*/ joinedReturnType = this.returnType.join(other.returnType, stateTable);
							new LambdaType {
								var returnType = joinedReturnType;
								val argTypes = joinedArgs;
								val environmentTypes = joinedEnv;
							}
						} {
							//error elsewhere, return generic lambda type
							new LambdaType {
								var returnType = VOID;
								val argTypes = makeEmptyList();
								val environmentTypes = java.util.HashMap.new();
							};
						}
						
						
					} {
						java.lang.System.out.println("JOIN FAILED: lambdas do not have the same number of environment variables");
						new LambdaType {
							var returnType = VOID;
							val argTypes = makeEmptyList();
							val environmentTypes = java.util.HashMap.new();
						};
					}
				} {
					java.lang.System.out.println("JOIN FAILED: lambdas do not have the same number of arguments");
					new LambdaType {
						var returnType = VOID;
						val argTypes = makeEmptyList();
						val environmentTypes = java.util.HashMap.new();
					};
				}
			}
			default {
				java.lang.System.out.println("JOIN FAILED: lambda can only join with another lambda");
				new LambdaType {
					var returnType = VOID;
					val argTypes = makeEmptyList();
					val environmentTypes = java.util.HashMap.new();
				};
			}
		}
	}
}