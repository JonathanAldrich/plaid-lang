package plaid.ast.types;

/**
 * Nominal Types consist only of a typeName which indexes into the state table
 * in order to get detailed state member and subtyping information for
 * typechecking purposes 
 */
state NominalType case of Type {
	val /*ID*/ typeName;
	
	method ==(/*NominalType*/ other) {
		match (other) {
			case NominalType {
				this.typeName == other.typeName;
			}
			default {
				false;
			}
		
		}
	
	}
	
	method join(other) {
		match (other) {
			case NominalType {
				ifElse (other.typeName == this.typeName)
					{ this }
					{ new NominalType { val typeName = "unit"; } } //TODO: better handling of join
			}
			default { new NominalType { val typeName = "unit"; } } //TODO: better handling of join
		}
	
	}
	
	method toString() {
		"N(" + this.typeName.name + ")"
	}
	
	method /*Boolean*/ subtypeOf(/*Type*/ other, /*StateTable*/ stateTable) {
		match (other) {
			case NominalType {
				val /*Option StateType*/ otherST = stateTable.get(other.typeName);
				val /*Option StateType*/ thisST = stateTable.get(this.typeName);
				match (otherST) {
					case Some {
						match (thisST) {
							case Some {
								val /*Boolean*/ typeSub = thisST.value.subtypeOf(otherST.value, stateTable);
								if(!typeSub) { java.lang.System.out.println("TYPECHECK FAILED: " + this.typeName.name + " not a subtype of " + other.typeName.name) };
								typeSub
							}
							case None {
								java.lang.System.out.println("TYPECHECK FAILED: type " + this.typeName.name + " not declared");
							}
						}	
					}
					case None {
						java.lang.System.out.println("TYPECHECK FAILED: type " + other.typeName.name + " not declared");
					}
				}
			}
			default {
				java.lang.System.out.println("TYPECHECK FAILED: nominal cannot be a subtype of a non-nominal Type");
				false;
			}
		}
	}
	

}