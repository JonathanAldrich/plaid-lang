package plaid.ast.types;

/**
 * Nominal Types consist only of a typeName which indexes into the state table
 * in order to get detailed state member and subtyping information for
 * typechecking purposes 
 */
state NominalType case of Type {
	val /*ID*/ typeName;
	
	method ==(/*NominalType*/ other) {
		match (other) {
			case NominalType {
				this.typeName == other.typeName;
			}
			default {
				false;
			}
		
		}
	
	}
	
	method join(other, stateTable) {
		match (other) {
			case NominalType { //least upper bound
				val /*Option StateType*/ thisST = stateTable.get(this.typeName);
				val /*Option StateType*/ otherST = stateTable.get(other.typeName);
				match (thisST) {
					case Some {
						match(otherST) {
							case Some {
								val /*Option StateType*/ lub = thisST.value.leastUpperBound(otherST.value);
								match (lub) {
									case Some {
										//java.lang.System.out.println("***JOIN SUCCEEDED: " + this.toString() + " + " + other.toString() + " = " + lub.value.name.name);
										new NominalType { val typeName = lub.value.name.copy(); }
									}
									case None {
										java.lang.System.out.println("cannot join " + this.toString() + " and " + other.toString());
										new NominalType { val typeName = new ID { val name = "unit"; }; };
									
									}
								}
							}
							case None {
								java.lang.System.out.println("state " + other.typeName.name + " not declared");
								new NominalType { val typeName = new ID { val name = "unit"; }; };	
							}
						}
					}
					case None {
						//where to log an error?
						java.lang.System.out.println("state " + this.typeName.name + " not declared");
						new NominalType { val typeName = new ID { val name = "unit"; }; };	
					}
				}	
			}
			default { 
				java.lang.System.out.println("cannot join " + this.toString() + " with a non-NominalType");
				new NominalType { val typeName = new ID { val name = "unit"; }; };
			} 
		}
	}

	method merge(other, stateTable) {
		java.lang.System.out.println("Implement merging in NominalType");
	}
	
	method toString() {
		"N(" + this.typeName.name + ")"
	}
	
	method /*Boolean*/ subtypeOf(/*Type*/ other, /*StateTable*/ stateTable) {
		match (other) {
			case NominalType {
				val /*Option StateType*/ otherST = stateTable.get(other.typeName);
				val /*Option StateType*/ thisST = stateTable.get(this.typeName);
				match (otherST) {
					case Some {
						match (thisST) {
							case Some {
								val /*Boolean*/ typeSub = thisST.value.subtypeOf(otherST.value, stateTable);
								if(!typeSub) { java.lang.System.out.println("TYPECHECK FAILED: " + this.typeName.name + " not a subtype of " + other.typeName.name) };
								typeSub
							}
							case None {
								java.lang.System.out.println("TYPECHECK FAILED: type " + this.typeName.name + " not declared");
								false;
							}
						}	
					}
					case None {
						java.lang.System.out.println("TYPECHECK FAILED: type " + other.typeName.name + " not declared");
						false;
					}
				}
			}
			default {
				java.lang.System.out.println("TYPECHECK FAILED: nominal cannot be a subtype of a non-nominal Type");
				false;
			}
		}
	}
	

}