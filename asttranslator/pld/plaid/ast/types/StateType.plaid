package plaid.ast.types;

import plaid.ast.ID;

/**
 * 	represents the type of a state in Plaid.  Currently designed to contain
 * information for a nominal type mapped in the state table.  Will likely
 * need to be changed to accommodate the addition of Structural Types
 */
state StateType case of DeclType {
	val /*Map<ID,DeclType>*/ declaredTypes = java.util.HashMap.new();
	val /*Map<ID,DeclType>*/ providedTypes = java.util.HashMap.new();
	val /*Option StateType*/ superType;
	val /*ID*/ name;
	
	method /*Option DeclType */ declaredTypeOf(/*ID*/ name) {
		ifElse(declaredTypes.containsKey(name)) 
			{ new Some { val value = declaredTypes.get(name); }}
			{ new None }
	}
	
	method /*Option DeclType */ providedTypeOf(name) {
		ifElse(providedTypes.containsKey(name)) 
			{ new Some { val value = providedTypes.get(name); }}
			{ new None }
	}
	
	//TODO: more robust naming, etc
	method /*boolean*/ subtypeOf(/*DeclType*/ other, /*StateTable*/ stateTable) {
		match (other) {
			case StateType {
				ifElse (this.name == other.name) { //TODO: this should be more robust
					true;
				} {
					match (this.superType) {
						case Some {
							this.superType.value.subtypeOf(other, stateTable);
						}
						case None {
							false;
						}
					}
				}
			}
			default {
				java.lang.System.out.println("TYPECHECK FAILED: StateType cannot be a subtype of a non-StateType");
				false;
			}
		}
	}
	
	method /*boolean*/ checkCaseOf(/*StateType*/ other, /*StateTable*/ stateTable) {
		match (other) {
			case StateType {
				//To check the case of relationship, we need to make sure that
				//all of the members declared by other are also declared by this
				//and that they are subtypes.  Secondly, we need to make sure that
				//all of the members provided by other are also provided by this
				//and are subtypes
				var /*Boolean*/ isCaseOf = true;
				val iter = other.declaredTypes.keySet().iterator();
				while { iter.hasNext() && isCaseOf } {
					val /*ID*/ declName = iter.next();
					val /*DeclType*/ otherDecl = other.declaredTypes.get(declName); //we know it is there
					val /*Option DeclType*/ thisDecl = this.declaredTypeOf(declName); //don't know if it is here
					match (thisDecl) {
						case Some {
							isCaseOf = thisDecl.value.declSubTypeOf(otherDecl, stateTable);
							if (!isCaseOf) {java.lang.System.out.println("CASE OF FAILED: state " +
								this.name.name + "'s declared member " + declName.name +
								"is not a subtype of the declared member in state " + other.name.name) };
						}
						case None {
							isCaseOf = false;
							java.lang.System.out.println("CASE OF FAILED: state " + this.name.name +
														" does not declare member " + declName.name);
						}
					}
				};
				
				val iter2 = other.providedTypes.keySet().iterator();
				while { iter2.hasNext() && isCaseOf } {
					val /*ID*/ declName = iter2.next();
					val /*DeclType*/ otherDecl = other.providedTypes.get(declName); //we know it is there
					val /*Option DeclType*/ thisDecl = this.providedTypeOf(declName); //don't know if it is here
					match (thisDecl) {
						case Some {
							isCaseOf = thisDecl.value.declSubTypeOf(otherDecl, stateTable);
							if (!isCaseOf) { java.lang.System.out.println("CASE OF FAILED: state " +
								this.name.name + "'s provided member " + declName.name +
								"is not a subtype of the  provided member in state " + other.name.name) };
						}
						case None {
							isCaseOf = false;
							java.lang.System.out.println("CASE OF FAILED: state " + this.name.name +
														" does not provide member " + declName.name);
						}
					}
				};
				
				isCaseOf;
			}
			default {
				java.lang.System.out.println("TYPECHECK FAILED: case of not a StateType");
				false
			}
		}
	}
	
	method toString() {
		val pfn = fn (dType) => ret = ret + "\n\t\t" + dType.toString();
		var ret = "state " + this.name.name;
		match(this.superType) {
			case Some { ret = ret + " case of " + superType.value.name.name }
			default { }
		};
		ret = ret + ":\n\tDeclaredType = ";
		val iter = declaredTypes.values().iterator();
		while { iter.hasNext() } {
			ret = ret + "\n\t\t" + iter.next().toString();
		};
		ret = ret + "\n\tProvidedType = ";
		val iter2 = providedTypes.values().iterator();
		while { iter2.hasNext() } {
			ret = ret + "\n\t\t" + iter2.next().toString();
		};
		ret = ret + "\n";		
	}
}