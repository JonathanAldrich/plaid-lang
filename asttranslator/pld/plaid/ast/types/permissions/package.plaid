package plaid.ast.types.permissions;

//globals for permissions
val immutable Permission DYNP = new DynPermission;
val immutable Permission UNIQUE = new UniquePermission;
val immutable Permission FULL = new FullPermission;
val immutable Permission IMM = new ImmutablePermission;
val immutable Permission SHARED = new SharedPermission;
val immutable Permission PURE = new PurePermission;
val immutable Permission NONEP = new NonePermission;


/**
 *  Take a list of permissions and return the least upper Bound (strongest) by folding
 */ 
val /*(unique list<immutable Permission>) -> immutable Permission*/ leastUpperBound =
	 fn (/*unique list<immutable Permission> */ permList) => {
	 	permList.foldl(fn (immutable Permission p1, immutable Permission p2) => p1.leastUpperBound(p2),
	 				   NONEP);
	 };

/**
 *  Take a list of permissions and return the greatest lower bound (weakest) by folding
 */
val /*(unique list<immutable Permission>) -> immutable Permission*/ greatestLowerBound =
	 fn (/*unique list<immutable Permission> */ permList) => {
	 	permList.foldl(fn (immutable Permission p1, immutable Permission p2) => p1.greatestLowerBound(p2),
	 				   NONEP);
	 };

/**
 *  Returns the permission needed to the receiver if neededPerm is pulled from a field with permission
 *  fieldPerm.  If the permission is strongly borrowed, we only need the needed permission, but if
 *  it is not borrowed, then we must have the same permission as the field itself.
 *  NOTE - this works for unique/immutable/none, but may have to be revised with other permissions
 */
val (immutable Permission >> void, immutable Permission >> void, immutable Boolean) -> immutable Permission
fieldReadPermission =
	fn (immutable Permission >> void fieldPerm,
		immutable Permission >> void neededPerm,
		immutable Boolean stronglyBorrowed) => 
	{
		match (stronglyBorrowed) {
			case True {
				neededPerm
			}
			case False {
				fieldPerm
			}
		}		
	}; 
	
method main() {  //test permissions 


}
