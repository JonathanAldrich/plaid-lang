package plaid.ast.types.permissions;

/**
 *	Full permission
 */
state FullPermission case of Permission {
	method isWritable() {
		true;
	}

	method splitPerm(p2) {
		match(p2) {
			// full => full/pure
			case FullPermission {
				new Some{ val value = new PurePermission; };
			}
			// full => shared/shared
			case SharedPermission {
				new Some{ val value = new SharedPermission; };
			}
			// full => immutable/immutable
			case ImmutablePermission {
				new Some{ val value = new ImmutablePermission; };
			}
			// full => pure/full
			case PurePermission {
				new Some{ val value = this; };
			}
			// full => none/full
			case NonePermission {
				new Some{ val value = this; };
			}
			default {
				new None;
			}
		};
	}
	
	method ==(p2) {
		match(p2) {
			case FullPermission {
				true;
			}
			default {
				false;
			}
		};
	}
	
	//everything except merging with a unique permission leaves a full permission
	method /*Permission*/ join(p2) {
		match (p2) {
			case UniquePermission { p2 }
			default { this }
		}
	}
	
	method /*Option Permission*/ joinTo(p2,target) {
		match (target) {
			case UniquePermission {  //pure + full = unique
				match (p2) {
					case PurePermission { createSome(target) }
					default { NONE; }
				}
			}
			default { //normal join and check relative strength
				val joined = this.join(p2);
				ifElse (joined.asStrongAs(target))
					{ createSome(target); }
					{ NONE; };
			}
		}
	}
			
	
	//only unique and Dyn are stronger
	method /*boolean*/ asStrongAs(p2) {
		match (p2) {
			case UniquePermission { false }
			case DynPermission { false }
			default { true } 
		}
	}
	
	method immutable Permission leastUpperBound(p2) {
		match (p2) {
			case DynPermission { DYNP }
			case UniquePermission { UNIQUE }
			case FullPermission { FULL }
			case ImmutablePermission { FULL }
			case SharedPermission { FULL }
			case PurePermission { FULL }
			case NonePermission { FULL }
			default { 
				java.lang.System.out.println("not a permission"); 
				DYNP; 
			}
		}
	}
	
	method immutable Permission greatestLowerBound(p2) {
		match (p2) {
			case DynPermission { DYNP }
			case UniquePermission { FULL }
			case FullPermission { FULL }
			case ImmutablePermission { IMMUTABLE }
			case SharedPermission { SHARED }
			case PurePermission { PURE }
			case NonePermission { NONEP }
			default { 
				java.lang.System.out.println("not a permission"); 
				NONEP; 
			}
		}
	}
	
	
	//weaker
	method /*Permission*/ merge(p2) {
		match (p2) {
			case DynPermission { DYNP }
			case UniquePermission { FULL }
			default { p2 } //most things weaker
		}
	}
	
	method toString() {
		"full"
	}
}