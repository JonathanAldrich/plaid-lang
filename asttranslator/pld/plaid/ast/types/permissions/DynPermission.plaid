package plaid.ast.types.permissions;

/**
 *	Dynamic Permission (separate from Dynamic object type)
 */
state DynPermission case of Permission {
	
	//changes can be made to an object with dynamic permission
	method immutable Boolean isWritable()[pure DynPermission] {
		true;
	}
	
	//objects with dynamic permission could be changed, though it doesn't much impact the dynamic permission object
	method immutable Boolean guaranteesState()[pure DynPermission] {
		false;
	}
	
	method immutable Boolean ==(immutable Permission p2)[immutable DynPermission] {
		match(p2) {
			case DynPermission {
				true;
			}
			default {
				false;
			}
		};
	}

	//You can split anything from a Dynamic permission (KBN - this probably isn't actually true - would you want to split an immutable out?)
	method /*unique Option<immutable Permission>*/ splitPerm(immutable Permission p2)[immutable DynPermission] {
		createSome(this);
	}
	
	//Always join to Dyn
	method /*unique Some<immutable DynPermission>*/ join(immutable Permission p2)[immutable DynPermission] {
		createSome(this);
	}
	
	//only join to dyn, None otherwise
	method /*Option Permission*/ joinTo(p2, target) {
		match (target) {
			case DynPermission { createSome(this) }
			default { NONE }
		}
	}
	
	//Dyn is outside of the lattice and captures
	method immutable Permission leastUpperBound(immutable Permission p2)[immutable DynPermission] {
		match (p2) {
			case DynPermission { DYNP }
			case UniquePermission { DYNP }
			case FullPermission { DYNP }
			case ImmutablePermission { DYNP }
			case SharedPermission { DYNP }
			case PurePermission { DYNP }
			case NonePermission { DYNP }
			default { 
				java.lang.System.out.println("not a permission"); 
				DYNP; 
			}
		}
	}
	
	//Dyn is outside of the lattice and captures
	method immutable Permission greatestLowerBound(immutable Permission p2)[immutable DynPermission] {
		match (p2) {
			case DynPermission { DYNP }
			case UniquePermission { DYNP }
			case FullPermission { DYNP }
			case ImmutablePermission { DYNP }
			case SharedPermission { DYNP }
			case PurePermission { DYNP }
			case NonePermission { DYNP }
			default { 
				java.lang.System.out.println("not a permission"); 
				DYNP; 
			}
		}
	}
	
	//if we can split anything from Dyn then this is right, otherwise, we might need to change it
	method immutable Boolean isSubPermOf(immutable Permission p2)[immutable DynPermission] {
		true
	}
	
	//weaker
	method /*Permission*/ merge(p2) {
		DYNP //dyn special (I think)
	}
	
	// Dyn permission always stronger
	method /*boolean*/ asStrongAs(p2) {
		true
	}
	
	method toString() {
		"DynP"
	}
}