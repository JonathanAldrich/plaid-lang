package plaid.ast.types;

/**
 * UnpackedTypes are nominal types which have had the invariants on their
 * state temporarily broken.  Thus, they have an underlying ID representing
 * the NominalType that it started as and then a list of members representing
 * the current structural type of the object.  Since packing is done lazily,
 * it may be the case that the structural type provides the invariants of
 * the nominal type.
 */
state UnpackedType case of ObjectType {
	val unique ID typeName;
	val /*unique Map<unique ID,immutable DeclType>*/ members;
	
	method immutable Boolean ==(immutable ObjectType other)[immutable UnpackedType] {
		match (other) {
			case UnpackedType {
				ifElse  (this.typeName == other.typeName && 
						 this.members.size() == other.members.size()) 
				{
					var immutable Boolean ret = true;
					val /*unique Iterator<immutable ID>*/ iter = this.members.keySet().iterator();
					while { iter.hasNext() && ret} { 
						val immutable ID member = iter.next();
						ifElse (other.members.containsKey(member)) {
							ret = (this.members.get(member) == other.members.get(member))
						} { ret = false; }	
					};
					ret
				} { false }	
			}
			default { false }
		}
	}
	
	method immutable String toString()[immutable UnpackedType] {
		var ret = "upk(" + typeName.toString() + ", {";
		val iter = this.members.values().iterator();
		while { iter.hasNext() } { 
			ret = ret + iter.next().toString() + ","
		};
		ret + "})";
	}

}