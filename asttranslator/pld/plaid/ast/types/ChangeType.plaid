package plaid.ast.types;

/**
 *	ChangeTypes are used in the type of methods and lambdas to 
 *  summarize the way in which the types of inputs to these
 *  abstractions change as a part of the execution.  We represent
 *  the start and end states as TypeBindings.  Change Types
 *  that return a non-none permission will be represented
 *  as BorrowBinding, while anything that ends with a none
 *  permission will simply be represented as a TakeBinding.
 *  We might be able to make these more lightweight by
 *  separating out duplicate information between the two
 *  TypeBindings, however, it is simpler to do it this
 *  way for uniform handling elsewhere.
 */
state ChangeType case of PlaidType {
	
	val immutable TypeBinding input;
	val immutable TypeBinding output;
	
	method immutable Boolean ==(immutable ChangeType other) {
		match (other) {
			case ChangeType {
				this.input == other.input && this.output == other.output;
			}
			default { false }
		}
	}
	
	method toString() {
		input.toString() + " >> " + output.toString()
	}
	
	method immutable Boolean isSubChangeTypeOf(immutable ChangeType other, stateTable) {
		// other.input <: this.input && this.output <: other.output 
		other.input.isSubTypeBindingOf(this.input, stateTable) && 
			this.output.isSubTypeBindingOf(other.output, stateTable);
	}
	
	 /**
 	 *  the least upper bound finds the most specific type that is a supertype of the
 	 *  two given types.  Since we follow covariance for outputs and contravariance for inputs
 	 *  finding the least upper bound on the change type corresponds to finding the greatest
 	 *  lower bound of the input and the lowest upper bound on the output. 
 	 */ 
 	method /*unique Option<unique ChangeType>*/ 
 		leastUpperBound(immutable ChangeType other, unique StateTable st)[immutable ChangeType]
 	{
 		val /*unique Option<unique TypeBinding>*/ newInput = this.input.greatestLowerBound(other.input, st);
		match (newInput) {
			case Some {
				val /*unique Option<unique TypeBinding>*/ newOutput = this.output.leastUpperBound(other.output, st);
				match (newOutput) {
					case Some {
						createSome(new ChangeType {
							val input = newInput.value;
							val output = newOutput.value;
						})
					}
					case None { new None }
				}
			}
			case None { new None }
		}	
 	}
 	
 	/**
 	 *  the least upper bound finds the most general type that is a subtype of the
 	 *  two given types.  Since we follow covariance for outputs and contravariance for inputs
 	 *  finding the greatest lower bound on the change type corresponds to finding the least
 	 *  upper bound of the input and the greatest lower bound on the output. 
 	 */
 	method /*unique Option<unique ChangeType>*/ 
 		greatestLowerBound(immutable ChangeType other, unique StateTable st)[immutable ChangeType]
 	{
 		val /*unique Option<unique TypeBinding>*/ newInput = this.input.leastUpperBound(other.input, st);
		match (newInput) {
			case Some {
				val /*unique Option<unique TypeBinding>*/ newOutput = this.output.greatestLowerBound(other.output, st);
				match (newOutput) {
					case Some {
						createSome(new ChangeType {
							val input = newInput.value;
							val output = newOutput.value;
						})
					}
					case None { new None }
				}
			}
			case None { new None }
		}	
	}	
 		
}