package plaid.ast.types;

/**
 *	ChangeTypes are used in the type of methods and lambdas to 
 *  summarize the way in which the types of inputs to these
 *  abstractions change as a part of the execution.  We represent
 *  the start and end states as TypeBindings.  Change Types
 *  that return a non-none permission will be represented
 *  as BorrowBinding, while anything that ends with a none
 *  permission will simply be represented as a TakeBinding.
 *  We might be able to make these more lightweight by
 *  separating out duplicate information between the two
 *  TypeBindings, however, it is simpler to do it this
 *  way for uniform handling elsewhere.
 */
state ChangeType case of PlaidType {
	
	val immutable PermType input;
	val immutable PermType output;
	val immutable Boolean strongBorrow;
	
	method immutable Boolean ==(immutable ChangeType other) {
		match (other) {
			case ChangeType {
				this.input == other.input && this.output == other.output;
			}
			default { false }
		}
	}
	
	method toString() {
		val immutable String b = 
			match (this.strongBorrow) {
				case True { "(B)" }
				case False { "" }
			};
		input.toString() + " >>" + b + " " + output.toString()
	}
	
	method immutable Boolean isSubChangeTypeOf(immutable ChangeType other, stateTable) {
		ifElse (other.strongBorrow) {
			//if other is strongly borrowed, then so must this and we still must have subtyping relationships
			this.strongBorrow && 
				other.input.isSubPermTypeOf(this.input, stateTable) && 
				this.output.isSubPermTypeOf(other.output, stateTable);
		} {
			// if other is not strongly borrowed, then we don't care about whether this is strongly borrowed or not
			// other.input <: this.input && this.output <: other.output 
			other.input.isSubPermTypeOf(this.input, stateTable) && 
				this.output.isSubPermTypeOf(other.output, stateTable);
		}
	}
	
	 /**
 	 *  the least upper bound finds the most specific type that is a supertype of the
 	 *  two given types.  Since we follow covariance for outputs and contravariance for inputs
 	 *  finding the least upper bound on the change type corresponds to finding the greatest
 	 *  lower bound of the input and the lowest upper bound on the output. 
 	 */ 
 	method /*unique Option<unique ChangeType>*/ 
 		leastUpperBound(immutable ChangeType other, unique StateTable st)[immutable ChangeType]
 	{
 		val /*unique Option<unique TypeBinding>*/ newInput = this.input.greatestLowerBound(other.input, st);
		match (newInput) {
			case Some {
				val /*unique Option<unique TypeBinding>*/ newOutput = this.output.leastUpperBound(other.output, st);
				match (newOutput) {
					case Some {
						createSome(new ChangeType {
							val input = newInput.value;
							val output = newOutput.value;
							val immutable Boolean strongBorrow = this.strongBorrow && other.strongBorrow; //strongly borrowed if both are
						})
					}
					case None { new None }
				}
			}
			case None { new None }
		}	
 	}
 	
 	/**
 	 *  the least upper bound finds the most general type that is a subtype of the
 	 *  two given types.  Since we follow covariance for outputs and contravariance for inputs
 	 *  finding the greatest lower bound on the change type corresponds to finding the least
 	 *  upper bound of the input and the greatest lower bound on the output. 
 	 */
 	method /*unique Option<unique ChangeType>*/ 
 		greatestLowerBound(immutable ChangeType other, unique StateTable st)[immutable ChangeType]
 	{
 		val /*unique Option<unique TypeBinding>*/ newInput = this.input.leastUpperBound(other.input, st);
		match (newInput) {
			case Some {
				val /*unique Option<unique TypeBinding>*/ newOutput = this.output.greatestLowerBound(other.output, st);
				match (newOutput) {
					case Some {
						createSome(new ChangeType {
							val input = newInput.value;
							val output = newOutput.value;
							val immutable Boolean strongBorrow = this.strongBorrow || other.strongBorrow;
						})
					}
					case None { new None }
				}
			}
			case None { new None }
		}	
	}
	
	/**
	 *  the inputBinding method extracts a Type Binding needed for the input to the Change Type
	 */
	method immutable TypeBinding inputBinding()[immutable ChangeType] {
		ifElse (output.perm == NONEP) {  //take binding if not giving any permission back
			new TakeBinding { val unique PermType currentType = this.input; }
		} {  //otherwise a BorrowBinding
			new BorrowBinding {
				val unique PermType currentType = this.input;
				val immutable Boolean stronglyBorrowed = this.strongBorrow;
 				val immutable Permission lowerBound = this.output.perm;
			}
		}
	} 	
	
	/**
	 *  the outputBinding method extracts a Type Binding resulting as the output to the Change Type
	 */
	method immutable TypeBinding outputBinding()[immutable ChangeType] {
		ifElse (output.perm == NONEP) {  //take binding if not giving any permission back
			new TakeBinding { val unique PermType currentType = this.output; }
		} {  //otherwise a BorrowBinding
			new BorrowBinding {
				val unique PermType currentType = this.output;
				val immutable Boolean stronglyBorrowed = this.strongBorrow;
 				val immutable Permission lowerBound = this.output.perm;
			}
		}
	}	
}