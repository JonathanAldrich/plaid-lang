package plaid.printNodeNames;

import plaid.ast.*;
import plaid.ast.visitor.ASTVisitor;

state PrintVisitor = ASTVisitor {

	method visitApplication(node) {
		java.lang.System.out.println("I am an Application");
		node.f.accept(this); 
		//TO DO:
		//we don't have foldToPairs, as used below.  should they be passed in seperately?  is there a reason why they're grouped?
		//this.foldToPairs(node.arguments).accept(this); 
		node.arguments.map(fn(n) => n.accept(this));
	}
	method visitAssignment(node) {
		java.lang.System.out.println("I am an Assignment");
		node.value.accept(this); 
		node.target.value.accept(this); 
	}
	method visitAtomicBlock(node) {
		java.lang.System.out.println("I am an AtomicBlock");
	}
	method visitBorrowBinding(node) {
		java.lang.System.out.println("I am a BorrowBinding");
		node.exp.accept(this); 
		node.body.accept(this); 
	}
	method visitCase(node) {
		java.lang.System.out.println("I am a Case");
		//the one called below should only be called if this case is not the default case
		node.qi.value.accept(this); 
		node.e.accept(this); 
	}
	method visitCast(node) {
		java.lang.System.out.println("I am a Cast");
		node.body.accept(this);
	}
	method visitChangeState(node) {
		java.lang.System.out.println("I am a ChangeState");
		node.e.accept(this); 
		node.s.accept(this); 
	}
	method visitCompilationUnit(node) {
		java.lang.System.out.println("I am a CompilationUnit");	
		node.imports.accept(this);
		node.decls.map(fn (d) => {
			d.accept(this);
		});
		//java.lang.System.out.println(node.toString());
	}
	method visitDeclList(node) {
		java.lang.System.out.println("I am a DeclList");
		node.decls.map(fn (d) => d.accept(this));
	}
	method visitDereference(node) {
		java.lang.System.out.println("I am a Dereference");
		node.left.accept(this); 
	}
	method visitDestructiveDereference(node) {
		java.lang.System.out.println("I am a DestructiveDereference");
	}
	method visitDoubleLiteral(node) {
		java.lang.System.out.println("I am a DoubleLiteral");
	}
	method visitFieldDecl(node) {
		java.lang.System.out.println("I am a FieldDecl");
		node.e.accept(this);
	}
	method visitGroupDecl(node) {
		java.lang.System.out.println("I am a GroupDecl");
	}
	method visitGroupParameter(node) {
		java.lang.System.out.println("I am a GroupParameter");
	}
	method visitID(node) {
		java.lang.System.out.println("I am an ID");
	}
	method visitImportList(node) {
		java.lang.System.out.println("I am an ImportList");
	}
	method visitIntLiteral(node) {
		java.lang.System.out.println("I am an IntLiteral");
	}
	method visitJoin(node) {
		java.lang.System.out.println("I am a Join");
		node.body.accept(this);
	}
	method visitLambda(node) {
		java.lang.System.out.println("I am a Lambda");
		node.body.accept(this); 
	}
	method visitLetBinding(node) {
		java.lang.System.out.println("I am a LetBinding");
		node.x.accept(this);
		node.exp.accept(this); 
		node.body.accept(this); 
	}
	method visitMatch(node) {
		java.lang.System.out.println("I am a Match");
		node.e.accept(this);
		node.caseList.map(fn (c) => {
			c.accept(this);
		});
	}
	method visitMetaDereference(node) {
		java.lang.System.out.println("I am a MetaDereference");
	}
	method visitMetaTypeArgument(node) {
		java.lang.System.out.println("I am a MetaTypeArgument");
	}
	method visitMetaVariable(node) {
		java.lang.System.out.println("I am a MetaVariable");
	}
	method visitMethodCall(node) {
		java.lang.System.out.println("I am a MethodCall");
		node.receiver.accept(this);
		node.arguments.map(fn (n) => n.accept(this));
		//same problem as other foldToPairs problem
		//this.foldToPairs(node.arguments).accept(this); 
	}
	method visitMethodDecl(node) {
		java.lang.System.out.println("I am a MethodDecl");
		node.body.accept(this); 
	}
	method visitNewInstance(node) {
		java.lang.System.out.println("I am a NewInstance");
		node.s.accept(this); 
	}
	method visitQI(node) {
		java.lang.System.out.println("I am a QI");
		//if node.initState is Some
		//node.initState.value.accept(this);
		//if node.initState is DeclList
		//node.initState.accept(this); 
	}
	method visitSplitBlock(node) {
		java.lang.System.out.println("I am a SplitBlock");
	}
	method visitStateDecl(node) {
		java.lang.System.out.println("I am a StateDecl");	
		node.stateDef.accept(this);
		node.caseOf.value.accept(this);
	}
	method visitStringLiteral(node) {
		java.lang.System.out.println("I am a StringLiteral");
	}
	method visitsplitPerm(node) {
		java.lang.System.out.println("I am a Split");
		node.body.accept(this);
	}
	method visitTakeBinding(node) {
		java.lang.System.out.println("I am a TakeBinding");
		node.exp.accept(this); 
		node.body.accept(this); 
	}
	method visitTypeParameter(node) {
		java.lang.System.out.println("I am a TypeParameter");
	}
	method visitUnitLiteral(node) {
		java.lang.System.out.println("I am a UnitLiteral");
	}
	method visitUnpackerInnerGroups(node) {
		java.lang.System.out.println("I am an UnpackerInnerGroups");
	}
	method visitWith(node) {
		java.lang.System.out.println("I am a With");
		node.s1.accept(this);
		node.s2.accept(this); 
	}

}