package plaid.codegen;

import plaid.ast.visitor.ASTViewer;
import plaid.ast.*;
import plaid.scope.*;
import plaid.typechecker.*;
import plaid.typechecker.typecheckerMethods.*;
import plaid.optimizer.*;


state CodeGenerator{

	method compileFiles(/*String*/inputDir, /*String*/output, /*List<String>*/ plaidPathEntries) {
	    var cc = plaid.compilerjava.CompilerConfiguration.new();
		cc.setInputDir(inputDir);
		cc.setOutputDir(output);
		plaidPathEntries.map( fn(plaidPathEntry) => {
			cc.addToPlaidPath(plaidPathEntry);
		});
		cc.setPrettyPrint(true);
		cc.setDebugMode(true);
		cc.setVerbose(true);
		var compiler = plaid.compilerjava.CompilerCore.new(cc);
		compiler.convertInputDirToInputFiles(java.io.File.new(cc.getInputDir()));
		var javaList = java.util.ArrayList.new();
		var plaidList = new List{var head = new plaid.lang.Nil;};
		var iter = cc.getInputFiles().iterator();
		while { iter.hasNext(); } {
			var file = iter.next();
			var javaAST = plaid.compilerjava.ParserCore.parse(java.io.FileInputStream.new(file));
			javaList.add(javaAST);
		};
		//following two line should be rewrite in plaid in the future
		
		var packrep = compiler.buildPlaidPath(javaList); // javaAST in javaList has changed
		
		iter = javaList.iterator();
		val stateTable = new StateTable {
			override val states = java.util.HashMap.new();
		};

		var translator = new ASTTranslator;
		while { iter.hasNext(); } {
			var javaAST = iter.next();
			var plaidAST = translator.translateAST(javaAST);
			plaidList.add(plaidAST);
			//plaidAST.accept(codeGenVisitor); //We must delay this even there are performance issues
		};
		
		//scope build phase
		var /*ScopeBuildingVisitor*/ scopebuilder = new ScopeBuildingVisitor{val rep = packrep;};
		scopebuilder.build(plaidList);
		
		//typechecking phase
		//TODO: add type checking here
		plaidList.map(fn(x) => {
			//x.accept(something);
		});
		
		//optimization phase
		var /*OptimizationVisitor*/ optVisitor = new OptimizationVisitor;
		//TODO need double check if something should be modify for the new version of the ASTNodes
		plaidList.map(fn(x) => {
			x.accept(optVisitor);
		});
						
		//code genearation phase
		val codeGenVisitor = new CodeGenVisitor {val stateTable = stateTable; };		
		codeGenVisitor.cc.setOutputDir(output);		
		codeGenVisitor.cc = cc;
		plaidList.map(fn(x) => {
			x.accept(codeGenVisitor);
		});
	}
	
}
method main() {
	//This will compile ASTTranslator and The TypeChecker Projects
	var codeGenerator = new CodeGenerator;
	var plaidPathEntries = new List{var head = new plaid.lang.Nil;};
	plaidPathEntries.add("../stdlib/bin/");
	plaidPathEntries.add("../runtime/bin/");
	codeGenerator.compileFiles("../asttranslator/pld","../asttranslator/src_new",plaidPathEntries);
	plaidPathEntries.add("../asttranslator/bin");
	codeGenerator.compileFiles("../typechecker/pld","../typechecker/src_new",plaidPathEntries);
}
	

