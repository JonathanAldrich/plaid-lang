package plaid.codegen;

import plaid.ast.visitor.ASTViewer;
import plaid.ast.*;
import plaid.typechecker.*;
import plaid.typechecker.typecheckerMethods.*;
import plaid.optimizer.*;


state CodeGenTest{

	method compileFiles(val /*List<File>*/ fileList, val /*String*/ output) {
		var javaList = java.util.ArrayList.new();
		var plaidList = new List;
		var iter = fileList.iterator();
		while { iter.hasNext(); } {
			var file = iter.next();
			var javaAST = plaid.compilerjava.ParserCore.parse(java.io.FileInputStream.new( file ));
			javaList.add(javaAST);
		};
		
		var cc = plaid.compilerjava.CompilerConfiguration.new();
		cc.addToPlaidPath("../stdlib/bin/");
		cc.addToPlaidPath("../runtime/bin/");
		cc.setPrettyPrint(true);
		cc.setDebugMode(true);
				
		//following two line should be rewrite in plaid in the future
		var compiler = plaid.compilerjava.CompilerCore.new(cc);
		compiler.buildPlaidPath(javaList); // javaAST in javaList has changed
		
		iter = javaList.iterator();
		while { iter.hasNext(); } {
			var javaAST = iter.next();
			var translator = new ASTTranslator;
			var plaidAST = translator.translateAST(javaAST);
			plaidList.add(plaidAST);
		}
		
		val codeGenVisitor = new CodeGenVisitor;		
		codeGenVisitor.cc.setOutputDir(output);		
		codeGenVisitor.cc = cc;
		
		plaidList.map(fn(x) => {
			x.accept(codeGenVisitor);
		});
	}
	
	method generateJava(filePath,runTypechecker){
	/**
	 *  The problem is that the set of programs that typecheck doesn't
	 *  completely match the set of programs that we can compile -- for
	 *  example anything using Java classes will not typecheck but
	 *  should compile just fine.
	 */
	 	val javaList = java.util.ArrayList.new();
	 	
		val javaAST = plaid.compilerjava.ParserCore.parse(java.io.FileInputStream.new(java.io.File.new(filePath)));
		
		javaList.add(javaAST);		
		
		//using java buildpath
		var cc = plaid.compilerjava.CompilerConfiguration.new();

		cc.addToPlaidPath("../stdlib/bin/");
		cc.addToPlaidPath("../asttranslator/bin/");
		
		var compiler = plaid.compilerjava.CompilerCore.new(cc);
		compiler.buildPlaidPath(javaList); // javaAST in javaList has changed		
		
		val translator = new ASTTranslator;
		val plaidAST = translator.translateAST(javaAST);
		val stTranslator = new StateTableBuilderVisitor;
		plaidAST.accept(stTranslator);
		val stateTable = new StateTable {
			override val states = java.util.HashMap.new();
		};
		//val tr = new PackageRepTranslator {
		//	val stateTable = stateTable;
		//};
		//val userDir = java.lang.System.getProperty("user.dir");
		//val plaidPath = makeEmptyList();
		//plaidPath.add(userDir + "/bin/");
		//plaidPath.add(userDir + "/../stdlib/bin/");
		//val packageRep = tr.buildPackageRep(javaAST, plaidPath);
		//tr.translate(packageRep);
		val codeGenVisitor = new CodeGenVisitor { val stateTable = stateTable; };
		codeGenVisitor.cc.setPrettyPrint(true);
		codeGenVisitor.cc.setDebugMode(true);
		codeGenVisitor.cc.setOutputDir("testOutput/");
		plaidAST.accept(codeGenVisitor);
	}
}
method main() {
	var codeGenTest = new CodeGenTest;
	codeGenTest.generateJava("testInputs/stateTest/package.plaid",false);
	//codeGenTest.generateJava("../compilerTests/coreExamples/turing/package.plaid",false);
	//codeGenTest.generateJava("../compilerTests/coreExamples/tree/package.plaid",false);
	//codeGenTest.generateJava("../compilerTests/coreExamples/stateVarsTest/package.plaid",false);
	//codeGenTest.generateJava("../compilerTests/coreExamples/destructiveRead/package.plaid",false);

}
	

