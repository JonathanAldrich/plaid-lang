package plaid.benchmarks.sorting.StateBST;

import plaid.collections.makeArray;
import java.util.Random;

state Node = {
	var value;
} with TreePart with RootType

state TreePart {
	method add(elem);
	method find(elem);
	method delete(elem);
}

state RootType = {}

state Root case of RootType {
	var tree;
}

state NotRoot case of RootType {
	var parent;
}

state BST {
	method add(elem);
}

state EmptyBST case of BST {
	method add(elem) {
		this <- InitBST;
		this.root = new Node { var value = elem; } with Root { var tree = this; } with Leaf;
	}
}

state InitBST case of BST {
	var root = new Leaf { var value = 0; };
	
	method add(elem) {
		this.root.add(elem);
	}
	
	method find(elem) {
		this.root.find(elem);
	}
	
	method delete(elem) {
		this.root.delete(elem);
	}
}

method main() {
	val tstBST = new EmptyBST;
	tstBST.add(10);
	tstBST.add(15);
	tstBST.add(14);
	tstBST.add(5);
	tstBST.add(6);
	tstBST.add(4);
	tstBST.delete(6);
}

method benchmark(runner) {
	val size = 10000;
	val elems = makeArray(size);
	val tree = new EmptyBST;
	val rand = Random.new();
	var i = 0;
	nativeWhile{i < size} {
		val elem = rand.nextInt();
		elems.set(i, elem);
		i = i + 1;
	};
	i = 0;
	runner.startTimer();
	nativeWhile{i < size} {
		tree.add(elems.get(i));
		i = i + 1;
	};
	i = 0;
	nativeWhile{i < size} {
		tree.delete(elems.get(i));
		i = i + 1;
	};
	runner.stopTimer();
}