package plaid.compiler.passes;

import plaid.ast.parsed.*;
import plaid.compiler.DEBUG;
import plaid.compiler.WARNING;
import plaid.compiler.DEBUG_PRIO_HIGH;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.DEBUG_PRIO_LOW;
import plaid.compiler.Pass;
import plaid.compiler.CompilerConfiguration;
import plaid.compiler.Reporter;

import plaid.ast.util.makeStringFromQualifiedIdentifier;
import plaid.ast.util.makeTokenForQualifiedIdentifier;

import plaid.lang.math.min;
import plaid.lang.math.max;

import plaid.collections.makeLinkedList;

state ImportCheckPass case of Pass {
    var shared Resolver resolver;
    var shared Reporter reporter;

    method immutable Boolean run(unique Job job) {
        this.resolver = job.resolver;
        this.reporter = job.reporter;
        match (job.ast) {
            case Some {
                match (job.ast.value) {
                    case ParsedCompilationUnit {                        
                        DEBUG(DEBUG_PRIO_HIGH, "<ImportCheckPass> started");
                        checkImports(job.ast.value.imports, reporter, job.source.path);
                        DEBUG(DEBUG_PRIO_HIGH, "<ImportCheckPass> finished");
                        true
                    }
                    default { false }
                }
            }
            default { false }
        }
    }

    method immutable Boolean checkImports(immutable List imports, 
                                          unique Reporter reporter,
                                          immutable String sourceFile) {
        val unique LinkedList names = makeLinkedList(); 
        imports.do(fn (imp) => {
            if ( !imp.star ) {
                // check that we do not import the same name twice
                names.do( fn (name) => {
                    val impName = imp.qualifiedIdentifier.identifiers.get(imp.qualifiedIdentifier.identifiers.size() - 1);
                    if ( impName == name ) {
                        ERROR("<ImportCheckPass> Cannot import the same name '" + impName + "'");
                        val token = makeTokenForQualifiedIdentifier(imp.qualifiedIdentifier);
                        reporter.warningToken(java.io.File.new(sourceFile), 
                                              token,
                                              "Cannot import the same name '" + impName + "'");
                    }
                });
                names.add(imp.qualifiedIdentifier.identifiers.get(imp.qualifiedIdentifier.identifiers.size() - 1));
                
                // check that we can actually resolve the import
                val fqn = makeStringFromQualifiedIdentifier(imp.qualifiedIdentifier);
                val optSymbol = resolver.lookup(fqn);
                match (optSymbol) {
                    case None {
                        ERROR("<ImportCheckPass> Cannot resolve '" + fqn + "'");
                        val token = makeTokenForQualifiedIdentifier(imp.qualifiedIdentifier);
                        reporter.warningToken(java.io.File.new(sourceFile), 
                                              token,
                                              "Cannot resolve import '" + fqn  + "'");

                    }
                    default {}
                }
            };            
        });
    }
}