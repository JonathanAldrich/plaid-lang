package plaid.compiler.passes;

import plaid.lang.math.min;
import plaid.lang.math.max;

import plaid.ast.parsed.LeafVisitor;
import plaid.ast.parsed.BlockExpr;
import plaid.ast.parsed.Dereference;
import plaid.ast.parsed.DestructiveDereference;
import plaid.ast.parsed.EmptyExpr;
import plaid.ast.util.makeStringFromQualifiedIdentifier;
import plaid.ast.util.EMPTY_TOKEN;

import plaid.compiler.ERROR;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_HIGH;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.DEBUG_PRIO_LOW;
import plaid.compiler.Pass;
import plaid.compiler.Reporter;
import plaid.compiler.Context;
import plaid.compiler.context.TopLevelContext;
import plaid.compiler.context.LocalContext;
import plaid.compiler.context.ImportContext;
import plaid.compiler.context.StdLibContext;
import plaid.compiler.context.PackageContext;
import plaid.compiler.context.GlobalContext;

import plaid.compiler.resolver.ClasspathResolver;


import plaid.compiler.Symbol;
import plaid.compiler.symbol.VariableSymbol;
import plaid.compiler.symbol.SymbolFactory;
import plaid.compiler.symbol.TopSymbol;
import plaid.compiler.symbol.ThisSymbol;
import plaid.compiler.symbol.StateSymbol;
import plaid.compiler.symbol.StateValSymbol;

import java.util.Map;
import java.util.IdentityHashMap;


/*
 * Expands the left most case of a dot
 */
state NameExpanderPass case of Pass = LeafVisitor with  {

    val unique Stack stack = new Stack;
    val unique Map map = IdentityHashMap.new();
    val immutable SymbolFactory sf = new SymbolFactory;
    var immutable String sourceFile = "";
    var shared Reporter reporter;
    val shared ClasspathResolver resolver;
    val unique Stack currentState = new Stack;
    var shared Symbol packageSymbol = new TopSymbol;
        

    method immutable Boolean run(unique Job job, unique Reporter reporter) {
        match (job.ast) {
            case Some {
                DEBUG(DEBUG_PRIO_HIGH, "<NameExpanderPass> started");
                this.sourceFile = job.source.getPath();
                this.reporter = reporter;
                this.stack.push(new TopLevelContext);

                // add global stack 
                val globalCtx = new GlobalContext {
                     parent = this.stack.peek().value; 
                     resolver = this.resolver;
                };
                this.stack.push(globalCtx);

                job.ast.value.accept(this);
                DEBUG(DEBUG_PRIO_HIGH, "<NameExpanderPass> finished");
                true
            }
            default { 
                ERROR("<NameExpanderPass> AST invalid");
                false 
            }
        }
    }

    
    method immutable Option getQualifiedIdentifierFromDereference(immutable Dereference dref) {
        match (dref.left) {
            case Identifier {
                val ids = makeEmptyList();
                ids.add(dref.left);
                ids.add(dref.right);
                makeSome(new QualifiedIdentifier {
                    token = EMPTY_TOKEN;
                    identifiers = ids;
                })
            }
            case Dereference {
                val leftQIOpt = getQualifiedIdentifierFromDereference(dref.left);
                match (leftQIOpt) {
                    case Some {
                        val ids = makeEmptyList();
                        leftQIOpt.value.identifiers.map( fn (id) => ids.add(id) );
                        ids.add(dref.right);
                        makeSome(new QualifiedIdentifier {
                            token = EMPTY_TOKEN;
                            identifiers = ids;
                        })
                    }
                    case None { NONE }
                }                
            }
            default {
                NONE
            }
        }
    }

    
    method immutable Integer resolveQualifiedIdentifier(shared Context ctx,
                                                        immutable QualifiedIdentifier qi) {
        var currentSymbol = this.sf.makeTopSymbol();                                            
        var count = 0;
        var stop = false;
        qi.identifiers.map(fn (id) => {
            if ( stop == false ) {
                val symbolOpt = ctx.find(id.name);
                match ( symbolOpt ) {
                    case Some {
                        currentSymbol = symbolOpt.value;
                        this.map.put(id, currentSymbol);
                        count = count + 1;
                    } 
                    case None {
                        stop = true;
                    }
                }
            }
        });

        if ( qi.identifiers.length() == count ) {
            this.map.put(qi, currentSymbol);
        };

        count;
    }


	override method void visitAbstractFieldDecl(immutable AbstractFieldDecl node) {
		node.specifier.accept(this);
		node.fieldType.accept(this);
		node.name.accept(this);
		node.modifiers.map(fn (item) => { item.accept(this); item });
	}
    

	override method void visitAssignment(immutable Assignment node) {
		//node.target.accept(this);
		//node.field.accept(this);
        match ( node.target ) {
            case EmptyExpr {
                node.field.accept(this);
            }
            default {
                node.target.accept(this);
            }
        };
		node.value.accept(this);
	}

	override method void visitBlockExpr(immutable BlockExpr node) {
        val shared Context ctxt = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(ctxt);

		node.statements.map(fn (item) => { item.accept(this); item });

        this.stack.pop();
	}


	override method void visitCompilationUnit(immutable CompilationUnit node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<NameExpanderPass> visit CompilationUnit");

        
        var currentSymbol = this.sf.makeTopSymbol();
        node.packageName.identifiers.map( fn (id) => {
            val currentSymbolOpt = this.stack.peek().value.findInSymbol(currentSymbol, id.name);
            match (currentSymbolOpt) {
                case Some {
                    currentSymbol = currentSymbolOpt.value;                    
                }
                case None {
                    currentSymbol = this.sf.makePackageSymbol(id.name, this.sf.makeTopSymbol());
                    val fqn = makeStringFromQualifiedIdentifier(currentSymbol.getQualifiedIdentifier());
                    this.resolver.define(fqn, currentSymbol);
                }
            };
            this.map.put(id, currentSymbol);
        });
        this.map.put(node.packageName, currentSymbol);
        this.packageSymbol = currentSymbol;


        val stdCtx = new StdLibContext {
           parent = this.stack.peek().value; 
           resolver = this.resolver;
        };
        this.stack.push(stdCtx);
        
        val packageString = makeStringFromQualifiedIdentifier(node.packageName);
        val shared PackageContext pkgCtx = new PackageContext {
           parent = this.stack.peek().value; 
           packageName = packageString;
           resolver = this.resolver;
        };
        this.stack.push(pkgCtx);
        
        val shared ImportContext impCtx = new ImportContext{ 
            parent = this.stack.peek().value; 
            imports = node.imports;
            resolver = this.resolver;
        };
        this.stack.push(impCtx);
        

		//node.packageName.accept(this);
		//node.imports.map(fn (item) => { item.accept(this); item });
		node.decls.map(fn (item) => { item.accept(this); item });

        this.stack.pop();
	}


	override method void visitConcreteFieldDecl(immutable ConcreteFieldDecl node) {
		//node.name.accept(this);
		node.expression.accept(this);
		node.specifier.accept(this);
		node.fieldType.accept(this);
		node.modifiers.map(fn (item) => { item.accept(this); item });
	}


    override method void visitConcreteMethodDecl(immutable ConcreteMethodDecl node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<NameExpanderPass> visit ConcreteMethodDecl");

        val shared Context ctxt = new LocalContext{ parent = this.stack.peek().value; };
        this.stack.push(ctxt);


        // add arguments to context
        node.arguments.map( fn (arg) => {
            val shared VariableSymbol mySymbol = this.sf.makeVariableSymbol(arg.name.name, node);
            this.map.put(arg.name, mySymbol);
            val ctx = this.stack.peek().value;
            ctx.put(arg.name.name, mySymbol);
            arg
        });
        
        node.modifiers.map(fn (item) => { item.accept(this); item });
        node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
        node.returnType.accept(this);
        //node.arguments.map(fn (item) => { item.accept(this); item });
        node.env.map(fn (item) => { item.accept(this); item });
        //node.name.accept(this);

        //node.body.accept(this);
        node.body.statements.map( fn (stmt) => { stmt.accept(this); stmt });
        
        this.stack.pop();
    }


  	override method void visitConcreteStateDecl(immutable ConcreteStateDecl node) {
        match (this.currentState.peek() ) {
            case Some {
                 // inner state
                 val stateSymbol = this.sf.makeStateSymbol(node.name.name, node, this.currentState.peek().value);
                 this.currentState.push(stateSymbol);
                 this.map.put(node.name, stateSymbol);
         
                 val ctx = this.stack.peek().value;
                 ctx.put(node.name.name, stateSymbol);
            }
            case None {
                // outer state
                val unique Option stateSymbol = this.stack.peek().value.find(node.name.name);
                match (stateSymbol) {
                    case None {
                        ERROR("<NameExpanderPass> Cannot find symbol for state '" + node.name.name + "'");
                    }
                    case Some {
                        this.currentState.push(stateSymbol.value);
                        this.map.put(node.name, stateSymbol);
                    }
                };
            }
        };

        // create this and add new context
        val stateCtx = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(stateCtx);
        val shared ThisSymbol thisSymbol = this.sf.makeThisSymbol(this.currentState.peek().value);
        stateCtx.put("this", thisSymbol);


		node.caseOf.accept(this);
		node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
		node.metaCaseOfArgs.map(fn (item) => { item.accept(this); item });
		node.name.accept(this);
		node.modifiers.map(fn (item) => { item.accept(this); item });
		node.stateBinding.accept(this);

        this.currentState.pop();
        this.stack.pop();
	}


    override method void visitConcreteStateValDecl(immutable ConcreteStateValDecl node) {
        val shared StateValSymbol mySymbol = this.sf.makeStateValSymbol(node.name.name, node);
        this.map.put(node.name, mySymbol);
        val ctx = this.stack.peek().value;
        ctx.put(node.name.name, mySymbol);

        // create this and add new context
        val stateCtx = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(stateCtx);
        val shared ThisSymbol thisSymbol = this.sf.makeThisSymbol(mySymbol);
        stateCtx.put("this", thisSymbol);

        node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
        //node.name.accept(this);
        node.modifiers.map(fn (item) => { item.accept(this); item });
        node.stateBinding.accept(this);

        this.stack.pop();        
    }  


	override method void visitIdentifier(immutable Identifier node) {
        val symbol = this.stack.peek().value.find(node.name);
        match (symbol) {
            case Some {
               this.map.put(node, symbol.value);
           }
           case None {
               this.reporter.errorToken(java.io.File.new(this.sourceFile), node.token, "Cannot resolve '" + node.name + "'");
           }
       }
	}
    

	override method void visitDereference(immutable Dereference node) {
        /*
        val qiOpt = getQualifiedIdentifierFromDereference(node);
        match (qiOpt) {
            case Some {
                DEBUG(DEBUG_PRIO_HIGH, "<NameExpanderPass> Found potential QI: " + makeStringFromQualifiedIdentifier(qiOpt.value));
                val immutable Integer resolvedCount = resolveQualifiedIdentifier(this.stack.peek().value, qiOpt.value);
                DEBUG(DEBUG_PRIO_HIGH, "<NameExpanderPass>   resolved  " + resolvedCount + " parts");
                if ( resolvedCount == 0 ) {
                    //val mostLeftId = qiOpt.value.identifiers.get(0);
                    //this.reporter.errorToken(java.io.File.new(this.sourceFile), mostLeftId.token, "Cannot resolve '" + mostLeftId.name + "'");
                    node.left.accept(this);
                };
            }
            case None {
                node.left.accept(this);
            }
        };
        */
		node.left.accept(this);
		//node.right.accept(this);
	}


	override method void visitDestructiveDereference(immutable Dereference node) {
		node.left.accept(this);
		//node.right.accept(this);
	}


	override method void visitInfixOperatorExpr(immutable InfixOperatorExpr node) {
		node.left.accept(this);
		node.right.accept(this);
		//node.operator.accept(this);
	}

	override method void visitLambda(immutable Lambda node) {
        val shared Context ctxt = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(ctxt);

        // add arguments to context
        node.arguments.map( fn (arg) => {
            val shared VariableSymbol mySymbol = this.sf.makeVariableSymbol(arg.name.name, node);
            this.map.put(arg.name, mySymbol);
            val ctx = this.stack.peek().value;
            ctx.put(arg.name.name, mySymbol);
            arg
        });

        //node.arguments.map(fn (item) => { item.accept(this); item });
        node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
        node.env.map(fn (item) => { item.accept(this); item });

        // if we have a block expression as body we have to bypass it to 
        // avoid that we create an extra context
        match (node.body) {
            case BlockExpr {
                node.body.statements.map( fn (stmt) => { stmt.accept(this); stmt } );
            }
            default {
                node.body.accept(this);
            }
        };
        
        this.stack.pop();
	}

	override method void visitQualifiedIdentifier(immutable QualifiedIdentifier node) {
		val resolveCount = resolveQualifiedIdentifier(this.stack.peek().value, node);
        ifElse ( resolveCount == node.identifiers.length() ) {
             DEBUG(DEBUG_PRIO_MEDIUM, "<NameExpanderPass> Resolved '" + makeStringFromQualifiedIdentifier(node) +"'");
        }{
            ERROR("Failed to resolve '" + makeStringFromQualifiedIdentifier(node) + "'");
            val first = node.identifiers.car();
            val last  = node.identifiers.get(node.identifiers.length() - 1);
            val beginLine   = min(first.token.beginLine, last.token.beginLine);
            val endLine     = max(first.token.endLine, last.token.endLine);
            val beginColumn = min(first.token.beginColumn, last.token.beginColumn);
            val endColumn   = max(first.token.endColumn, last.token.endColumn);
            this.reporter.error(java.io.File.new(this.sourceFile), 
                                beginLine,
                                beginColumn,
                                endLine,
                                endColumn,
                               "Cannot resolve '" + makeStringFromQualifiedIdentifier(node) + "'");
        }
	}


    override method void visitVarDecl(immutable VarDecl node) {

        node.specifier.accept(this);
        node.varType.accept(this);
                //node.id.accept(this);
        node.expr.accept(this);
        
        val shared VariableSymbol mySymbol = this.sf.makeVariableSymbol(node.id.name, node);
        val ctx = this.stack.peek().value;
        val result = ctx.put(node.id.name, mySymbol);
        ifElse ( result ) {            
            this.map.put(node.id, mySymbol);
        }{
            ERROR("Name "+ node.id.name +" already declared.");
        }
    }
}