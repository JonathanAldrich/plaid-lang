package plaid.compiler.passes;

import plaid.ast.parsed.LeafVisitor;
import plaid.ast.parsed.BlockExpr;
import plaid.ast.util.makeStringFromQualifiedIdentifier;

import plaid.compiler.ERROR;
import plaid.compiler.Pass;
import plaid.compiler.Reporter;
import plaid.compiler.Context;
import plaid.compiler.context.TopLevelContext;
import plaid.compiler.context.LocalContext;
import plaid.compiler.context.ImportContext;
import plaid.compiler.context.StdLibContext;
import plaid.compiler.context.PackageContext;

import plaid.lang.Boolean;

import plaid.compiler.Symbol;
import plaid.compiler.symbol.VariableSymbol;
import plaid.compiler.symbol.SymbolFactory;
import plaid.compiler.symbol.ThisSymbol;
import plaid.compiler.symbol.StateSymbol;
import plaid.compiler.symbol.StateValSymbol;

import java.util.Map;
import java.util.IdentityHashMap;

state NameExpanderPass case of Pass  = LeafVisitor with  {

    val unique Stack stack = new Stack;
    val unique Map map = IdentityHashMap.new();
    val immutable SymbolFactory sf = new SymbolFactory;
    var immutable String sourceFile ="";
    var shared Reporter reporter;
    val shared ClasspathResolver resolver;    
        

    method immutable Boolean run(unique Job job, unique Reporter reporter) {
        match (job.ast) {
            case Some {
                this.sourceFile = job.source.getPath();
                this.reporter = reporter;
                this.stack.push(new TopLevelContext);
                job.ast.value.accept(this);
                true
            }
            default { false }
        }
    }
    
	override method void visitBlockExpr(immutable BlockExpr node) {
        //DEBUG("  NameExpanderPass -> visit BlockExpr");
        val shared Context ctxt = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(ctxt);

		node.statements.map(fn (item) => { item.accept(this); item });

        this.stack.pop();
	}


	override method void visitCompilationUnit(immutable CompilationUnit node) {
        val stdCtx = new StdLibContext {
           parent = this.stack.peek().value; 
           resolver = resolver;
        };
        this.stack.push(stdCtx);
        
        val packageString = makeStringFromQualifiedIdentifier(node.packageName);
        val shared PackageContext pkgCtx = new PackageContext {
           parent = this.stack.peek().value; 
           packageName = packageString;
           resolver = resolver;
        };
        this.stack.push(pkgCtx);
        
        val shared ImportContext impCtx = new ImportContext{ 
            parent = this.stack.peek().value; 
            imports = node.imports;
            resolver = resolver;
        };
        this.stack.push(impCtx);

		//node.packageName.accept(this);
		//node.imports.map(fn (item) => { item.accept(this); item });
		node.decls.map(fn (item) => { item.accept(this); item });

        this.stack.pop();
	}

	override method void visitConcreteFieldDecl(immutable ConcreteFieldDecl node) {
		node.expression.accept(this);
		node.specifier.accept(this);
		node.fieldType.accept(this);
		//node.name.accept(this);
		node.modifiers.map(fn (item) => { item.accept(this); item });
	}


    override method void visitConcreteMethodDecl(immutable ConcreteMethodDecl node) {
        //DEBUG("  NameExpanderPass -> visit ConcreteMethodDecl");

        val shared Context ctxt = new LocalContext{ parent = this.stack.peek().value; };
        this.stack.push(ctxt);

        // add arguments to context
        node.arguments.map( fn (arg) => {
            val shared VariableSymbol mySymbol = sf.makeVariableSymbol(arg.name.name, node);
            this.map.put(arg.name, mySymbol);
            val ctx = this.stack.peek().value;
            ctx.put(arg.name.name, mySymbol);
            arg
        });
        
        node.modifiers.map(fn (item) => { item.accept(this); item });
        node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
        node.returnType.accept(this);
        //node.arguments.map(fn (item) => { item.accept(this); item });
        node.env.map(fn (item) => { item.accept(this); item });
        //node.name.accept(this);

        //node.body.accept(this);
        node.body.statements.map( fn (stmt) => { stmt.accept(this); stmt });
        
        this.stack.pop();
    }

	override method void visitConcreteStateDecl(immutable ConcreteStateDecl node) {
        //DEBUG("  NameExpanderPass -> visit ConcreteStateValDecl");
        val shared StateSymbol mySymbol = sf.makeStateSymbol(node.name.name, node);
        this.map.put(node.name, mySymbol);
        val ctx = this.stack.peek().value;
        ctx.put(node.name.name, mySymbol);

        // create this and add new context
        val stateCtx = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(stateCtx);
        val shared ThisSymbol thisSymbol = sf.makeThisSymbol(mySymbol);
        stateCtx.put("this", thisSymbol);

		node.caseOf.accept(this);
		node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
		node.metaCaseOfArgs.map(fn (item) => { item.accept(this); item });
		node.name.accept(this);
		node.modifiers.map(fn (item) => { item.accept(this); item });
		node.stateBinding.accept(this);

        this.stack.pop();
	}

    override method void visitConcreteStateValDecl(immutable ConcreteStateValDecl node) {
        //DEBUG("  NameExpanderPass -> visit ConcreteStateValDecl");
        val shared StateValSymbol mySymbol = sf.makeStateValSymbol(node.name.name, node);
        this.map.put(node.name, mySymbol);
        val ctx = this.stack.peek().value;
        ctx.put(node.name.name, mySymbol);

        // create this and add new context
        val stateCtx = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(stateCtx);
        val shared ThisSymbol thisSymbol = sf.makeThisSymbol(mySymbol);
        stateCtx.put("this", thisSymbol);

        node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
        //node.name.accept(this);
        node.modifiers.map(fn (item) => { item.accept(this); item });
        node.stateBinding.accept(this);

        this.stack.pop();        
    }  

	override method void visitIdentifier(immutable Identifier node) {
        val symbol = this.stack.peek().value.find(node.name);
        match (symbol) {
            case Some {
               this.map.put(node, symbol.value);
           }
           case None {
               reporter.errorToken(java.io.File.new(this.sourceFile), node.token, "Cannot resolve '" + node.name + "'");
           }
       }
	}
    
	override method void visitDereference(immutable Dereference node) {
		node.left.accept(this);
		//node.right.accept(this);
	}


	override method void visitLambda(immutable Lambda node) {
        //DEBUG("  NameExpanderPass -> visit Lambda");
       
        val shared Context ctxt = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(ctxt);

        // add arguments to context
        node.arguments.map( fn (arg) => {
            val shared VariableSymbol mySymbol = sf.makeVariableSymbol(arg.name.name, node);
            this.map.put(arg.name, mySymbol);
            val ctx = this.stack.peek().value;
            ctx.put(arg.name.name, mySymbol);
            arg
        });

        //node.arguments.map(fn (item) => { item.accept(this); item });
        node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
        node.env.map(fn (item) => { item.accept(this); item });

        // if we have a block expression as body we have to bypass it to 
        // avoid that we create an extra context
        match (node.body) {
            case BlockExpr {
                node.body.statements.map( fn (stmt) => { stmt.accept(this); stmt } );
            }
            default {
                node.body.accept(this);
            }
        };
        
        this.stack.pop();
	}

    override method void visitVarDecl(immutable VarDecl node) {
        //DEBUG("  NameExpanderPass -> visit Lambda");

        node.specifier.accept(this);
        node.varType.accept(this);
        //node.id.accept(this);
        node.expr.accept(this);
        
        val shared VariableSymbol mySymbol = this.sf.makeVariableSymbol(node.id.name, node);
        val ctx = this.stack.peek().value;
        val result = ctx.put(node.id.name, mySymbol);
        ifElse ( result ) {            
            this.map.put(node.id, mySymbol);
        }{
            ERROR("Name "+ node.id.name +" already declared.");
        }
    }
}