package plaid.compiler.passes;

import plaid.ast.parsed.ParsedRewriteLeafVisitor;
import plaid.ast.util.*;

import plaid.compiler.ERROR;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.Pass;

import plaid.compiler.symbolForAST;
import plaid.compiler.haveSymbolForAST;
import plaid.compiler.addSymbolForAST;

import plaid.compiler.symbol.*;
import plaid.compiler.*;
import plaid.compiler.types.*;

import plaid.ast.parsed.*;

import plaid.collections.makeLinkedList;

state TypeResolutionPass case of Pass = ParsedRewriteLeafVisitor with  {
    val unique Map symbolToStructureMap = java.util.IdentityHashMap.new();
    var unique SymbolFactory sf = new SymbolFactory;
    var immutable Source sourceFile;
    var shared Resolver resolver;
    var shared Reporter reporter;
    var hasErrors = false;

    method immutable Boolean run(unique Job job) {
        match (job.ast) {
            case Some {
                DEBUG(DEBUG_PRIO_HIGH, "<TypeResolutionPass> started");
                this.sourceFile = job.source.path;
                this.reporter   = job.reporter;
                this.resolver   = job.resolver;

                //val viewer1 = new ParsedASTViewerVisitor{ override val title = "[BEFORE]" + job.source.path.toString();};
                //job.ast.value.accept(viewer1);

                job.ast = makeSome(job.ast.value.rewrite(this));

                //val viewer2 = new ParsedASTViewerVisitor{ override val title = " [AFTER]" + job.source.path.toString();};
                //job.ast.value.accept(viewer2);

                DEBUG(DEBUG_PRIO_HIGH, "<TypeResolutionPass> finished");
                !this.hasErrors;
            }
            default { 
                ERROR("<TypeResolutionPass> AST invalid");
                false 
            }
        }
    }

    method void setStructureForSymbol(shared Symbol sym, shared Structure struct) {
        this.symbolToStructureMap.put(sym, struct);
    }

    method unique Option getStructureForSymbol(shared Symbol sym) {
        ifElse (this.symbolToStructureMap.containsKey(sym) ) {
            makeSome(this.symbolToStructureMap.get(sym))
        }{
            //ABORT("Cannot find structure for symbol. " + sym.toString());
            new None
        }
    }


    override method void LOG(immutable String msg) {
        DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass> " + msg);
    }

	override method immutable ParsedAbstractFieldDecl rewriteParsedAbstractFieldDecl(immutable ParsedAbstractFieldDecl node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> rewrite AbstractFieldDecl");

		val new_specifier = node.specifier.rewrite(this);
		val new_fieldType = node.fieldType.rewrite(this);
		val new_name = node.name.rewrite(this);
		val new_modifiers = makeLinkedList();
		node.modifiers.map(fn (item) => { new_modifiers.add(item.rewrite(this)) });

		val new_node = new ParsedAbstractFieldDecl{
			val specifier = new_specifier;
			val fieldType = new_fieldType;
			val name = new_name;
			val modifiers = new_modifiers;
			val token = node.token;
		};

        // update symbol
        val symbol = symbolForAST(node);
        match (symbol) {
            case Some {
                match (symbol.value) {
                    case FieldSymbol {
                        symbol.value.updateDeclaration(new_node);
                    }
                    default {
                        ABORT("Found invalid symbol for state declaration.");
                    }
                }
            }
            case None {
                ABORT("Cannot find symbol for state declaration.");
            }
        };

        new_node
	}


	override method immutable ParsedArgumentExpr rewriteParsedArgumentExpr(immutable ParsedArgumentExpr node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> rewrite ArgumentExpression");

     	// create new object
		val new_node = new ParsedArgumentExpr{
			val args = node.args.map(fn (item) => item.rewrite(this) );
			val token = node.token;
		};

        ifElse ( new_node.args.size() == 0 ) {
            addStructureForAST(new_node, TOPSTRUCT);
        }{
            ifElse ( new_node.args.size() == 1 ) {
                val elemStruc = structureForAST(new_node.args.get(0));
                match (elemStruc) {
                    case Some {
                        addStructureForAST(new_node, elemStruc.value);
                    }
                    case None {
                        val msg = "Cannot find type for '" + new_node.args.get(0) + "'";
                        //this.reporter.errorToken(java.io.File.new(this.sourceFile),  new_node.args.get(0).token, msg);
                        this.reporter.report();
                        ABORT(msg);            
                    }
                }
            }{
                val msg = "No tuple support yet.";
                this.reporter.errorToken(java.io.File.new(this.sourceFile), new_node.token, msg);
                this.reporter.report();
                ABORT(msg);            
            }
        };

        new_node	
	}


	override method immutable ParsedApplication rewriteParsedApplication(immutable ParsedApplication node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> rewrite Application");
        match (node.function) {
            case ParsedIdentifier {
                // check for global method or variable with lambda
                val symbol = symbolForAST(node.function);
                match (symbol) {
                    case Some {
                        match (symbol.value) {
                            case VariableSymbol {
                                // check for lambda
                            }
                            case MethodSymbol {
                                // top-level method
                            }
                            default {
                                val msg = "'"+node.function.name+"' is neither a lambda nor a method.";
                                this.reporter.errorToken(java.io.File.new(this.sourceFile), node.funtion.token, msg);
                                this.reporter.report();
                                ABORT(msg);                        
                            }
                        }
                    } 
                    case None {
                        val msg = "Cannot find symbol information for '" + node.function.name +"'";
                        this.reporter.errorToken(java.io.File.new(this.sourceFile), node.funtion.token, msg);
                        this.reporter.report();
                        ABORT(msg);                        
                    }
                }
            }
            case ParsedDereference {
                // check that if dereference is a method
                DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass>    check dereference for possible method.");
                
                val new_function = node.function.left.rewrite(this);
                val receiverStruct = structureForAST(new_function);
                match (receiverStruct) {
                    case Some {
                        val signature = receiverStruct.value.getMember(node.function.right.name);
                        match (signature) {
                            case Some {
                                match (signature.value) {
                                    case FieldSignature {
                                         DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass>     Found field");
                                         val new_application = new ParsedApplication {
                                             val function   = new_function;
                                             val argument   = node.argument.rewrite(this);
                                             val staticArgs = node.staticArgs.map( fn (arg) => arg.rewrite(this) );
                                             val token      = node.token;
                                         };
                                         val fieldType = signature.value.getCurrentType();
                                         match (fieldType.structure) {
                                             case LambdaStructure {
                                                 DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>     Field contains Lambda ");
                                                 addStructureForAST(new_application, fieldType.structure.returnType.structure);
                                                 DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>       Lambda returns '" + fieldType.structure.returnType.toString() +"'");
                                             }
                                             default { 
                                                 val msg = "Cannot apply to '" + fieldType.structure +"'"; 
                                                 this.reporter.errorToken(java.io.File.new(this.sourceFile), node.left.token, msg);
                                                 this.reporter.report();
                                                 ABORT(msg);                                                 
                                             } 
                                         };
                                         
                                         new_application
                                    }
                                    case MethodSignature {
                                        DEBUG(DEBUG_PRIO_HIGH, "<TypeResolutionPass>     Found method call");
                                        val returnType = signature.value.returnType;
                                        
                                        val new_argument = node.argument.rewrite(this);
                                        val new_staticArgs = makeLinkedList();
                                        val new_methodId = node.function.right.rewrite(this);
                                        node.staticArgs.map( fn (item) => new_staticArgs.add( item.rewrite(this)) );
                                        val methodCall = new ParsedMethodCall {
                                            val argument = new_argument;
                                            val staticArgs = new_staticArgs;
                                            val receiver = new_function;
                                            val methodId = new_methodId;
                                            val token = node.function.token;
                                        };
                                        addStructureForAST(methodCall, returnType.structure);
                                        DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>       Method returns '" + returnType.toString()  +"'");
                                        methodCall
                                    }
                                    default {
                                        ABORT("FIXME3 " + signature.value.toString());
                                    }
                                }
                            }
                            case None { 
                                val msg = "Cannot find '" + node.function.right.name + "' in type " + receiverStruct.toString();
                                this.reporter.errorToken(java.io.File.new(this.sourceFile), node.function.left.token, msg);
                                this.reporter.report();
                                ABORT(msg);
                            }
                        }
                    }
                    case None {
                        val msg = "Cannot find type for '" + node.function.nodeName() + "'";
                        this.reporter.errorToken(java.io.File.new(this.sourceFile), node.left.token, msg);
                        this.reporter.report();
                        ABORT(msg);
                    }
                }
            }
            default {
                DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass>  Resolve standard function for application");
                val new_function   = node.function.rewrite(this);
		        val new_argument   = node.argument.rewrite(this);
		        val new_staticArgs = node.staticArgs.map( fn (item) => item.rewrite(this) );

		        // create new object
		        val new_node = new ParsedApplication {
			        val function   = new_function;
			        val argument   = new_argument;
			        val staticArgs = new_staticArgs;
			        val token      = node.token;
		        };

                val functionStruct = structureForAST(new_function);
                match ( functionStruct ) {
                    case Some {
                        match ( functionStruct.value ) {
                            case LambdaStructure { 
                                 val returnType = functionStruct.value.returnType;
                                 addStructureForAST(new_node, returnType.structure);
                            }
                            default {
                                val msg = "Cannot apply to non-lambda object " + functionStruct.value.toString() ;
                                this.reporter.errorToken(java.io.File.new(this.sourceFile), new_function.token, msg);
                                this.reporter.report();
                                ABORT(msg);                                  
                            }
                        }
                    }
                    case None {
                        val msg = "Cannot find type for '" + node.function.nodeName() + "'";
                        this.reporter.errorToken(java.io.File.new(this.sourceFile), node.left.token, msg);
                        this.reporter.report();
                        ABORT(msg);
                    }
                };

                new_node
            }
        }
	}


	override method immutable ParsedBlockExpr rewriteParsedBlockExpr(immutable ParsedBlockExpr node) {
		LOG("rewrite ParsedBlockExpr");
		// create new object
		val new_node = new ParsedBlockExpr{
			val statements= node.statements.map(fn (item) => { item.rewrite(this) });
			val token = node.token;
		};

        ifElse ( new_node.statements.size() == 0 ) {
            // empty expression => void 
            DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> empty BlockExpr -> void");
            addStructureForAST(new_node, VOID.structure);
        }{
            val lastStmt = new_node.statements.get(new_node.statements.size() - 1).value;
            val lastStmtStruct = structureForAST(lastStmt);
            match (lastStmtStruct) {
               case Some {
                   addStructureForAST(new_node, lastStmtStruct.value);
               }
               case None {
                   ABORT("<TypeResolutionPass> Cannot find strucuture of last statement." + new_node.toString());
               }
            }
        };
        
        new_node
	}

	override method immutable ParsedConcreteFieldDecl rewriteParsedConcreteFieldDecl(immutable ParsedConcreteFieldDecl node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> rewrite ConcreteFieldDecl");

		val new_expression = node.expression.rewrite(this);
		val new_specifier  = node.specifier.rewrite(this);
		val new_fieldType  = node.fieldType.rewrite(this);
		val new_name       = node.name.rewrite(this);
		val new_modifiers  = makeLinkedList();
		node.modifiers.map(fn (item) => { new_modifiers.add(item.rewrite(this)) });

		val new_node = new ParsedConcreteFieldDecl{
			val expression = new_expression;
			val specifier  = new_specifier;
			val fieldType  = new_fieldType;
			val name       = new_name;
			val modifiers  = new_modifiers;
			val token      = node.token;
		};

        // update symbol
        val symbol = symbolForAST(node);
        match (symbol) {
            case Some {
                match (symbol.value) {
                    case FieldSymbol {
                        symbol.value.updateDeclaration(new_node);
                    }
                    default {
                        ABORT("Found invalid symbol for state declaration.");
                    }
                }
            }
            case None {
                ABORT("Cannot find symbol for state declaration.");
            }
        };

        new_node
	}


	override method immutable ParsedConcreteMethodDecl rewriteParsedConcreteMethodDecl(immutable ParsedConcreteMethodDecl node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> rewrite ConcreteMethodDecl");

        // populate context with variable mappings 
        this.symbolToStructureMap.clear();

		val new_returnType = node.returnType.rewrite(this);
		val new_StaticArgsSpec = node.StaticArgsSpec.map(fn (item) => { item.rewrite(this) } );
		val new_arguments = node.arguments.map( fn (item) => { 
            val new_item = item.rewrite(this);
            val symbol = symbolForAST(item);
            match (symbol) {
                case Some {
                    match (symbol.value) {
                        case VariableSymbol {
                             symbol.value.updateDeclaration(new_item);
                             val struct = symbol.value.getStructure();
                             DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass>     add '" + symbol.value.name +"' to symbol context with structure " + struct.toString() );
                             setStructureForSymbol(symbol.value, struct);
                        }
                        default {
                            ABORT("Found invalid symbol for parameter.  " + symbol.value);
                        }
                    }
                }
                case None {
                    ABORT("Cannot find symbol for parameter.");
                }
            };

            new_item
        });

		val new_environment = node.environment.map(fn (item) => { 
            val new_item = item.rewrite(this); 
            
            val symbol = symbolForAST(item);
            match (symbol) {
                case Some {
                    match (symbol.value) {
                        case VariableSymbol {
                             symbol.value.updateDeclaration(new_item);
                             val struct = symbol.value.getStructure();
                             DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass>     add '" + symbol.value.name +"' to symbol context with structure " + struct.toString());
                             setStructureForSymbol(symbol.value, struct);
                        }
                        default {
                            ABORT("Found invalid symbol for parameter.  " + symbol.value);
                        }
                    }
                }
                case None {
                    ABORT("Cannot find symbol for parameter.");
                }
            };

            new_item
        });
		val new_name = node.name.rewrite(this);
		val new_modifiers = node.modifiers.map(fn (item) => { new_modifiers.add(item.rewrite(this)) });

		val new_body = node.body.rewrite(this);


		val new_node = new ParsedConcreteMethodDecl{
			val body = new_body;
			val returnType = new_returnType;
			val StaticArgsSpec = new_StaticArgsSpec;
			val arguments = new_arguments;
			val environment = new_environment;
			val name = new_name;
			val modifiers = new_modifiers;
			val token = node.token;
		};

        // update symbol
        val symbol = symbolForAST(node);
        match (symbol) {
            case Some {                
                match (symbol.value) {
                    case MethodSymbol {
                        symbol.value.updateDeclaration(new_node);
                    }
                    default {
                        ABORT("Found invalid symbol for state declaration.");
                    }
                }
            }
            case None {
                ABORT("Cannot find symbol for state declaration.");
            }
        };

        new_node
	}


    override method immutable ParsedConcreteStateDecl rewriteParsedConcreteStateDecl(immutable ParsedConcreteStateDecl node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> rewrite ParsedConcreteStateDecl");
        
		val new_stateBinding = node.stateBinding.rewrite(this);
		val new_caseOf = node.caseOf.rewrite(this);
		val new_StaticArgsSpec = makeLinkedList();
		node.StaticArgsSpec.map(fn (item) => { new_StaticArgsSpec.add(item.rewrite(this)) });
		val new_metaCaseOfArgs = makeLinkedList();
		node.metaCaseOfArgs.map(fn (item) => { new_metaCaseOfArgs.add(item.rewrite(this)) });
		val new_name = node.name.rewrite(this);
		val new_modifiers = makeLinkedList();
		node.modifiers.map(fn (item) => { new_modifiers.add(item.rewrite(this)) });

		val new_node = new ParsedConcreteStateDecl{
			val stateBinding = new_stateBinding;
			val caseOf = new_caseOf;
			val StaticArgsSpec = new_StaticArgsSpec;
			val metaCaseOfArgs = new_metaCaseOfArgs;
			val name = new_name;
			val modifiers = new_modifiers;
			val token = node.token;
		};

        // update symbol
        val symbol = symbolForAST(node);
        match (symbol) {
            case Some {                
                match (symbol.value) {
                    case StateSymbol {
                        symbol.value.updateDeclaration(new_node);
                    }
                    default {
                        ABORT("Found invalid symbol for state declaration.");
                    }
                }
            }
            case None {
                ABORT("Cannot find symbol for state declaration.");
            }
        };

        new_node
	}


	override method immutable ParsedConcreteStateValDecl rewriteParsedConcreteStateValDecl(immutable ParsedConcreteStateValDecl node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> rewrite statevaldecl");

		val new_stateBinding = node.stateBinding.rewrite(this);
		val new_StaticArgsSpec = makeLinkedList();
		node.StaticArgsSpec.map(fn (item) => { new_StaticArgsSpec.add(item.rewrite(this)) });
		val new_name = node.name.rewrite(this);
		val new_modifiers = makeLinkedList();
		node.modifiers.map(fn (item) => { new_modifiers.add(item.rewrite(this)) });

		val new_node = new ParsedConcreteStateValDecl{
			val stateBinding = new_stateBinding;
			val StaticArgsSpec = new_StaticArgsSpec;
			val name = new_name;
			val modifiers = new_modifiers;
			val token = node.token;
		};

        // update symbol
        val symbol = symbolForAST(node);
        match (symbol) {
            case Some {                
                match (symbol.value) {
                    case StateValSymbol {
                        symbol.value.updateDeclaration(new_node);
                    }
                    default {
                        ABORT("Found invalid symbol for state declaration.");
                    }
                }
            }
            case None {
                ABORT("Cannot find symbol for state declaration.");
            }
        };

        new_node
	}
 
	override method immutable ParsedDefaultCase rewriteParsedDefaultCase(immutable ParsedDefaultCase node) {
		LOG("rewrite ParsedDefaultCase");
		// create new object
		val new_node = new ParsedDefaultCase{
			val body = node.body.rewrite(this);
			val token = node.token;
		};

        val newNodeStruct = structureForAST(new_node.body);
        match ( newNodeStruct ) {
            case Some {
                addStructureForAST(new_node, newNodeStruct.value);
            }
            case None {
                ABORT("Cannot find structure for default case.");
            }
        };

        new_node
	}
   
	override method immutable ParsedDereference rewriteParsedDereference(immutable ParsedDereference node) {
        LOG("visit ParsedDereference");

		val new_node = new ParsedDereference{
			val left = node.left.rewrite(this);
			val right = node.right.rewrite(this);
			val token = node.token;
		};

        val leftStruct = structureForAST(new_node.left);
        match (leftStruct) {
            case Some {
                match (leftStruct.value) {
                    case NominalStructure {
                        val signature = leftStruct.value.getMember(node.right.name);
                        match ( signature ) {
                            case Some {
                                match (signature.value) {
                                    case MethodSignature {
                                        DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> Found a method signature for '" + node.right.name +"'");
                                    }
                                    case FieldSignature {
                                        DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> Found a field signature for '" + node.right.name +"'");
                                        addStructureForAST(new_node, signature.value.getCurrentType().structure);
                                    }
                                    default {
                                        ERROR("<TypeResolutionPass> Found unsupported signature.");
                                    }
                                }
                            }
                            case None {
                                val msg = "Type '" + leftStruct.value.toString() + "' has no member '" + new_node.right.name + "'" ;
                                this.reporter.errorToken(java.io.File.new(this.sourceFile), new_node.right.token, msg);
                                this.reporter.report();
                                ABORT(msg);
                            }
                        }
                    }
                    default {
                        val x = leftStruct.value; x = 1;
                        ABORT("Found invalid type! " + leftStruct.value.toString());
                    }
                }
            }
            case None {
                val msg = "Cannot find structure for left part of the dereference.";
                this.reporter.errorToken(java.io.File.new(this.sourceFile), new_node.token, msg);
                this.reporter.report();
                ABORT(msg);
            }
        };

        new_node
	}

   	override method immutable ParsedIdentifier rewriteParsedIdentifier(immutable ParsedIdentifier node) {
        LOG("rewrite ParsedIdentifier '" + node.name +"'");
		val new_node = new ParsedIdentifier{
			val name = node.name;
			val token = node.token;
		};

        // try to get symbol
        val symbol = symbolForAST(node);
        match ( symbol ) {
            case Some {
                // update symbol 
                LOG("  remap symbol for '" + node.name +"'");
                //delSymbolForAST(node);
                addSymbolForAST(new_node, symbol.value);

                // resolve type information if possible
                match (symbol.value) {
                    case OwningSymbol {
                        val idStruct = symbol.value.getStructure();
                        addStructureForAST(new_node, idStruct);
                    }
                    case VariableSymbol {
                        val structOpt = getStructureForSymbol(symbol.value);
                        match ( structOpt ) {
                            case Some {
                                addStructureForAST(new_node, structOpt.value);
                            }
                            case None {
                                val idStruct = symbol.value.getStructure();
                                addStructureForAST(new_node, idStruct);
                            }
                        }
                    }
                    default { 
                        DEBUG(DEBUG_PRIO_HIGH, "<TypeResolutionPass> Cannot  resolve type for '" + node.name +"'"); 
                    }
                }
            }
            case None { LOG("   no symbol to remap for '" + node.name +"'"); }
        };

        new_node
	}


	override method immutable ParsedInfixOperatorExpr rewriteParsedInfixOperatorExpr(immutable ParsedInfixOperatorExpr node) {
		LOG("rewrite ParsedInfixOperatorExpr");
		// create new object
        val new_left = node.left.rewrite(this);
        val new_right = node.right.rewrite(this);

        val leftStructOpt = structureForAST(new_left);
        match (leftStructOpt) {
            case Some {
                match (leftStructOpt.value) {
                    case NominalStructure {
                        val memberSignatureOpt = leftStructOpt.value.getMember(node.operator.name);
                        match (memberSignatureOpt) {
                            case Some {
                                match (memberSignatureOpt.value) {
                                    case MethodSignature {
                                        DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> replace Unary operator with method call");
                                        val returnType = memberSignatureOpt.value.returnType;

                                        val args = makeLinkedList();
                                        args.addLast(new_right);
                                        val new_node = new ParsedMethodCall {
                                            val argument = new ParsedArgumentExpr { val args = args; val token = EMPTY_TOKEN; };
                                            val staticArgs = makeLinkedList();
                                            val receiver = new_left;
                                            val methodId = node.operator;
                                            val token = node.token;
                                        };

                                        addStructureForAST(new_node, returnType.structure);
                                        new_node
                                    }
                                    default {
                                        ABORT("Operator definiton needs to be a method declaration.");
                                    }
                                }
                            }
                            case None {
                                ABORT("Cannot find operator definition '" + node.operator.name +"' in " + exprStructOpt.value.toString());
                            }
                        }
                    }
                    default {
                        ABORT("Cannot call method on non-nominal structure.");
                    }
                }
            }
            case None {
                ABORT("Cannot find structure of expression.");
            }
        };        
	}

	override method immutable ParsedMatch rewriteParsedMatch(immutable ParsedMatch node) {
		LOG("rewrite ParsedMatch");
		// create new object
		val new_node = new ParsedMatch{
			val expression = node.expression.rewrite(this);
			val caseList= node.caseList.map(fn (item) => { item.rewrite(this) });
			val token = node.token;
		};

        // compute the least upper bound of all cases
        val caseStructs = new_node.caseList.map( fn (item) => {
            val itemStruct = structureForAST(item);
            match (itemStruct) {
                case Some { itemStruct.value }
                case None { ABORT("Cannot find struct for match case.") }
            }
        });

        var lub = caseStructs.get(0).value;
        caseStructs.do(fn (struct) => {
           val lubOpt = lub.leastUpperBound(struct);
           match (lubOpt) {
               case Some {
                   lub = lubOpt.value
               }
               case None {
                   ABORT("Cannot compute least upper bound.");
               }
           }
        });

        addStructureForAST(new_node, lub);

        new_node;
	}

	override method immutable ParsedNewInstance rewriteParsedNewInstance(immutable ParsedNewInstance node) {
		LOG("rewrite ParsedNewInstance");
		// create new object
		val new_node = new ParsedNewInstance{
			val stateExpr = node.stateExpr.rewrite(this);
			val token = node.token;
		};

        val stateExprStruct = structureForAST(new_node.stateExpr);
        match (stateExprStruct) {
            case Some {
                addStructureForAST(new_node, stateExprStruct.value);
            }
            case None {
                ABORT("Cannot find type for new expression.");
            }
        };

        new_node 
	}

	override method immutable ParsedPatternCase rewriteParsedPatternCase(immutable ParsedPatternCase node) {
		LOG("rewrite ParsedPatternCase");
		// create new object
		val new_node = new ParsedPatternCase{
			val pattern = node.pattern.rewrite(this);
			val body = node.body.rewrite(this);
			val token = node.token;
		};

        val newNodeStruct = structureForAST(new_node.body);
        match ( newNodeStruct ) {
            case Some {
                addStructureForAST(new_node, newNodeStruct.value);
            }
            case None {
                ABORT("Cannot find structure for default case.");
            }
        };

        new_node
	}


	override method immutable ParsedQualifiedIdentifier rewriteParsedQualifiedIdentifier(immutable ParsedQualifiedIdentifier node) {
		LOG("visit ParsedQualifiedIdentifier");
		val new_node = new ParsedQualifiedIdentifier{
			val identifiers= node.identifiers.map(fn (item) => { item.rewrite(this) });
			val token = node.token;
		};
        
        val symbol = symbolForAST(node);
        match ( symbol ) {
            case None  {
                DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   no symbol to remap QualifiedIdentifier");
            }
            case Some {
                DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   remap symbol for QualifiedIdentifier");
                //delSymbolForAST(node);
                addSymbolForAST(new_node, symbol.value);
            }
        };

        new_node
	}

	override method immutable ParsedStateChange rewriteParsedStateChange(immutable ParsedStateChange node) {
		LOG("rewrite ParsedStateChange");
		// create new object
		val new_node = new ParsedStateChange{
			val expression = node.expression.rewrite(this);
			val stateExpr = node.stateExpr.rewrite(this);
			val token = node.token;
		};

        // state change has always type void
        addStructureForAST(new_node, VOID.structure);        

        // statechange variable 
        match ( new_node.expression ) {
            case ParsedIdentifier {
                ifElse ( node.expression.name == "this" ) {
                    val symbolOpt = symbolForAST(new_node.expression);
                    match (symbolOpt) {
                        case Some {
                            val structOpt = structureForAST(new_node.stateExpr);
                            match (structOpt) {
                                case Some {
                                     DEBUG(DEBUG_PRIO_MEDIUM,"<TypeResolutionPass>     set structure for '"+ new_node.expression.name +"' to '" + structOpt.value.toString() +"'" );
                                     setStructureForSymbol(symbolOpt.value, structOpt.value);
                                }
                                case None {
                                     ABORT("Cannot find structure for state expression");
                                }
                            }
                        }
                        case None {
                            ABORT("Cannot find symbol for 'this'.");
                        }
                    }
                }{
                    ABORT("Can only perform state change operation on 'this'.");
                }
            }
            default {
                ABORT("Can only perform state change operation on 'this'.");
            }
        };    

        new_node
	}


	override method immutable ParsedStateRef rewriteParsedStateRef(immutable ParsedStateRef node) {
		LOG("rewrite ParsedStateRef");
		// create new object
		val new_node = new ParsedStateRef{
			val stateExpr = node.stateExpr.rewrite(this);
			val specializations= node.specializations.map(fn (item) => { item.rewrite(this) });
			val token = node.token;
		};

        val stateExprStruct = structureForAST(new_node.stateExpr);
        match(stateExprStruct) {
            case Some {
                addStructureForAST(new_node, stateExprStruct.value);
            }
            case None {
                ABORT("Cannot find type of state reference.");
            }
        };

        new_node
	}


	override method immutable ParsedUnaryOperatorExpr rewriteParsedUnaryOperatorExpr(immutable ParsedUnaryOperatorExpr node) {
		LOG("rewrite ParsedUnaryOperatorExpr");
        val new_expression = node.expression.rewrite(this);
        val exprStructOpt = structureForAST(new_expression);
        match (exprStructOpt) {
            case Some {
                match (exprStructOpt.value) {
                    case NominalStructure {
                        val memberSignatureOpt = exprStructOpt.value.getMember(node.operator.name);
                        match (memberSignatureOpt) {
                            case Some {
                                match (memberSignatureOpt.value) {
                                    case MethodSignature {
                                        DEBUG(DEBUG_PRIO_MEDIUM, "<TypeResolutionPass> replace Unary operator with method call");
                                        val returnType = memberSignatureOpt.value.returnType;

                                        val new_node = new ParsedMethodCall {
                                            val argument = new ParsedArgumentExpr { val args = makeLinkedList(); val token = EMPTY_TOKEN; };
                                            val staticArgs = makeLinkedList();
                                            val receiver = new_expression;
                                            val methodId = node.operator;
                                            val token = node.token;
                                        };

                                        addStructureForAST(new_node, returnType.structure);
                                        new_node
                                    }
                                    default {
                                        ABORT("Operator definiton needs to be a method declaration.");
                                    }
                                }
                            }
                            case None {
                                ABORT("Cannot find operator definition '" + node.operator.name +"' in " + exprStructOpt.value.toString());
                            }
                        }
                    }
                    default {
                        ABORT("Cannot call method on non-nominal structure.");
                    }
                }
            }
            case None {
                ABORT("Cannot find structure of expression.");
            }
        };        
	}

  	override method immutable ParsedVarDecl rewriteParsedVarDecl(immutable ParsedVarDecl node) {
		val new_specifier = node.specifier.rewrite(this);
		val new_varType = node.varType.rewrite(this);
		val new_id = node.id.rewrite(this);
		val new_expr = node.expr.rewrite(this);

		val new_node = new ParsedVarDecl{
			val specifier = new_specifier;
			val varType = new_varType;
			val id = new_id;
			val expr = new_expr;
			val token = node.token;
		};        

        // try to get symbol
        val symbol = symbolForAST(node);
        match ( symbol ) {
            case Some {
                // update symbol 
                //delSymbolForAST(node);
                addSymbolForAST(new_node, VOID.structure);
                //delSymbolForAST(node.id);
                addSymbolForAST(new_node.id, symbol.value);
            }
            case None {
                ABORT("Cannot find symbol for variable declaration.");
            }
        };

        new_node
	}
}
