package plaid.compiler.passes;

import plaid.ast.parsed.LeafVisitor;

import plaid.compiler.ERROR;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.Pass;


import plaid.compiler.symbol.*;


state TypeResolutionPass case of Pass = LeafVisitor with  {
    var unique SymbolFactory sf = new SymbolFactory;
    var immutable Source sourceFile;
    var shared Resolver resolver;
    var shared Reporter reporter;
    var shared Map map;
    var hasErrors = false;

    method immutable Boolean run(unique Job job, unique Reporter reporter) {
        match (job.ast) {
            case Some {
                DEBUG(DEBUG_PRIO_HIGH, "<TypeResolutionPass> started");
                this.sourceFile = job.source.getPath();
                this.reporter = reporter;
                this.map = job.symbolMap;

                job.ast.value.accept(this);

                DEBUG(DEBUG_PRIO_HIGH, "<TypeResolutionPass> finished");
                !this.hasErrors;
            }
            default { 
                ERROR("<TypeResolutionPass> AST invalid");
                false 
            }
        }
    }


    method immutable Option findMemberInStateSymbol(shared StateSymbol stateSymbol, immutable String name) {
        DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>        find in state symbol");
        val memberSymbol = stateSymbol.getMember(name);                    
        match (memberSymbol) {
            case None {
                match (stateSymbol.declaration.caseOf) {
                    case EmptyQualifiedIdentifier {
                        DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>        no more parent to search in.");
                        NONE
                    }
                    default {
                        DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>        search parent for symbol");
                        ifElse ( this.map.containsKey(stateSymbol.declaration.caseOf) ) {
                            val parentStateSymbol = this.map.get(stateSymbol.declaration.caseOf);
                            findMemberInStateSymbol(parentStateSymbol, name);
                        }{
                            ERROR("<TypeResolutionPass>        Cannot find parent symbol.");
                            NONE
                        };
                    }
                };
            }
            case Some {
                memberSymbol
            }
        }
     }

    
    method immutable Option findMemberSymbol(shared NominalObjectType objType, immutable String name) {
        DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>       find member '" + name +"'");
        ifElse ( this.map.containsKey(objType.stateQi) ) {
            val typeSymbol = this.map.get(objType.stateQi);
            match (typeSymbol) {
                case StateSymbol {
                    findMemberInStateSymbol(typeSymbol, name);
                }
                default { NONE }
            }
        }{            
            DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>       could not find symbol for type <FIXME>.");
            NONE
        }
    }
    

    method immutable Option resolveDereference(immutable Deference dref,
                                               shared Symbol leftSymbol) {
        // check if we already                                        
        ifElse ( this.map.containsKey(dref) ) {
            this.map.get(dref)
        }{
            match (leftSymbol) {
                case PackageSymbol {
                    // if we have a package on the left side and haven't        
                    // resolved the right hand side in the NameExpanderPass
                    // this should be an error, but let's try gain anyway
                    val fqn = makeStringFromQualifiedIdentifier(leftSymbol.getQualifiedIdentifier()) + "." + dref.right.name;
                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   try to resolve '" + fqn +"'");
                    this.resolver.lookup(fqn);
                }
                case VariableSymbol {
                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   found variable");
                    match (leftSymbol.declaration.varType) {
                        case EmptyType {
                            DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>     with dynamic type");
                            var dynSymbol = this.sf.makeDynamicSymbol();
                            this.map.put(leftSymbol.declaration.varType, dynSymbol);
                            this.map.put(dref.right, dynSymbol);
                            makeSome(dynSymbol);
                        }
                        case NominalObjectType {
                            DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>     with object type");
                            val memberSymbolOpt = findMemberSymbol(leftSymbol.declaration.varType, dref.right.name);
                            match (memberSymbolOpt) {
                                case Some {
                                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>       found member");
                                    this.map.put(dref, memberSymbolOpt.value);
                                    memberSymbolOpt
                                }
                                case None {
                                    ERROR("<TypeResolutionPass>     State <FIXME> has no member '" + dref.right.name +"'");
                                    this.reporter.errorToken(java.io.File.new(this.sourceFile), dref.right.token, "State <FIXME> has no member  '" + dref.right.name + "'");                                    
                                    NONE
                                }
                            }
                        }
                        default { NONE }
                    }; 
                }
                case DynamicSymbol {
                    var dynSymbol = this.sf.makeDynamicSymbol();
                    this.map.put(leftSymbol.declaration.varType, dynSymbol);
                    this.map.put(dref.right, dynSymbol);
                    makeSome(dynSymbol);                    
                }
                case StateSymbol {
                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   found state symbol");
                    NONE
                }
                case FieldSymbol {
                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   found field symbol");
                    // get field type
                    match (leftSymbol.declaration.fieldType) {
                        case EmptyType {
                            DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>     with dynamic type");
                            var dynSymbol = this.sf.makeDynamicSymbol();
                            this.map.put(leftSymbol.declaration.fieldType, dynSymbol);
                            this.map.put(dref.right, dynSymbol);
                            makeSome(dynSymbol);
                        }
                        case NominalObjectType {
                            DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>     with object type");
                            val memberSymbolOpt = findMemberSymbol(leftSymbol.declaration.fieldType, dref.right.name);
                            match (memberSymbolOpt) {
                                case Some {
                                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>       found member");
                                    this.map.put(dref, memberSymbolOpt.value);
                                    memberSymbolOpt
                                }
                                case None {
                                    ERROR("<TypeResolutionPass>     State <FIXME> has no member '" + dref.right.name +"'");
                                    this.reporter.errorToken(java.io.File.new(this.sourceFile), dref.right.token, "State <FIXME> has no member  '" + dref.right.name + "'");                                    
                                    NONE
                                }
                            }
                        }
                        default { NONE }
                    }; 
                    NONE
                }
                case MethodSymbol {
                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   found method symbol");
                    NONE
                }
                default {
                    ERROR("<TypeResolutionPass> Found not supported symbol.");
                    NONE
                }
            }
        }                                               
    }
    
    method immutable Option resolveNode(immutable Node node)  {
        val leftSymbol = NONE;
        match (node) {
            case Identifier {
                DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   resolve Identifier");
                ifElse ( this.map.containsKey(node) ) {
                    makeSome(this.map.get(node));
                }{
                    NONE
                };
            }
            case Dereference {
                DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   resolve Dereference");
                val leftSymbolOpt = resolveNode(node.left);
                match (leftSymbolOpt) {
                    case Some {
                        resolveDereference(node, leftSymbolOpt.value);
                    }
                    case None { NONE }
                }
            }
            default {
                ERROR("<TypeResolutionPass> Found not supported AST node.");
            }
        }
    }

    override method void visitDereference(immutable Dereference node) {
        DEBUG(DEBUG_PRIO_HIGH, "<TypeResolutionPass> found dereference.");
        val symbolOpt = resolveNode(node);
    }
}
