package plaid.compiler.passes;

import plaid.ast.parsed.LeafVisitor;

import plaid.compiler.ERROR;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.Pass;

import plaid.compiler.symbolForAST;
import plaid.compiler.haveSymbolForAST;
import plaid.compiler.addSymbolForAST;

import plaid.compiler.symbol.*;


state TypeResolutionPass case of Pass = LeafVisitor with  {
    var unique SymbolFactory sf = new SymbolFactory;
    var immutable Source sourceFile;
    var shared Resolver resolver;
    var shared Reporter reporter;
    var hasErrors = false;

    method immutable Boolean run(unique Job job) {
        match (job.ast) {
            case Some {
                DEBUG(DEBUG_PRIO_HIGH, "<TypeResolutionPass> started");
                this.sourceFile = job.source.getPath();
                this.reporter = job.reporter;
                this.resolver = job.resolver;

                job.ast.value.accept(this);

                DEBUG(DEBUG_PRIO_HIGH, "<TypeResolutionPass> finished");
                !this.hasErrors;
            }
            default { 
                ERROR("<TypeResolutionPass> AST invalid");
                false 
            }
        }
    }


    method immutable Option findMemberInStateSymbol(shared StateSymbol stateSymbol, immutable Identifier id) {
        DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>        find '"+ id.name +"' in state symbol '" + makeStringFromQualifiedIdentifier(stateSymbol.getQualifiedIdentifier()) +"'");
        val memberSymbol = stateSymbol.getMember(id.name);                    
        match (memberSymbol) {
            case None {
                match (stateSymbol.declaration.caseOf) {
                    case EmptyQualifiedIdentifier {
                        DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>        no more parent to search in.");
                        NONE
                    }
                    default {
                        DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>        search parent for symbol");
                        ifElse ( haveSymbolForAST(stateSymbol.declaration.caseOf) ) {
                            val parentStateSymbol = symbolForAST(stateSymbol.declaration.caseOf).value;
                            findMemberInStateSymbol(parentStateSymbol, id);
                        }{
                            ERROR("<TypeResolutionPass>        Cannot find parent symbol.");
                            NONE
                        };
                    }
                };
            }
            case Some {
                memberSymbol
            }
        }
     }


    
    method immutable Option findInType(immutable Type typeNode,
                                       immutable Identifier id) {

         DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>     find '"+ id.name+"' in type");
         match (typeNode) {
             case EmptyType {
                 DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>     with dynamic type");
                 var dynSymbol = this.sf.makeDynamicSymbol();
                 addSymbolForAST(typeNode, dynSymbol);
                 addSymbolForAST(id, dynSymbol);
                 makeSome(dynSymbol);
             }
             case NominalObjectType {
                 DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>     with object type");
                 val memberSymbolOpt = findMemberSymbol(typeNode, id);
                 match (memberSymbolOpt) {
                     case Some {
                         DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>       found member");
                         //addSymbolForAST(dref, memberSymbolOpt.value);
                         memberSymbolOpt
                     }
                     case None {
                         var fqnState = makeStringFromQualifiedIdentifier(typeNode.stateQi);
                         ERROR("<TypeResolutionPass>     State '" + fqnState + "' has no member '" + id.name +"'");
                         if ( haveSymbolForAST(typeNode.stateQi) ) {
                             val stateSymbol = symbolForAST(typeNode.stateQi).value;
                             match (stateSymbol) {
                                 case StateSymbol {
                                     fqnState = makeStringFromQualifiedIdentifier(stateSymbol.getQualifiedIdentifier());
                                 }
                                 default {}
                             };
                         };
                         this.reporter.errorToken(java.io.File.new(this.sourceFile), id.token, "State '" + fqnState + "' has no member  '" + id.name + "'");
                         NONE
                     }
                 }
             }
             default { NONE }
         }; 
    }


    
    method immutable Option findMemberSymbol(shared NominalObjectType objType, immutable Identifier id) {
        DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>       find member '" + id.name +"' in symbol " + makeStringFromQualifiedIdentifier(objType.stateQi));
        ifElse ( haveSymbolForAST(objType.stateQi) ) {
            val typeSymbol = symbolForAST(objType.stateQi).value;
            match (typeSymbol) {
                case StateSymbol {
                    findMemberInStateSymbol(typeSymbol, id);
                }
                default { NONE }
            }
        }{            
            DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>       could not find symbol for type '" + makeStringFromQualifiedIdentifier(objType.stateQi) +"'");
            NONE
        }
    }

    
    method immutable Option resolveDereference(immutable Deference dref,
                                               shared Symbol leftSymbol) {
        // check if we already                                        
        ifElse ( haveSymbolForAST(dref) ) {
            symbolForAST(dref).value
        }{
            match (leftSymbol) {
                case PackageSymbol {
                    // if we have a package on the left side and haven't        
                    // resolved the right hand side in the NameExpanderPass
                    // this should be an error, but let's try gain anyway
                    val fqn = makeStringFromQualifiedIdentifier(leftSymbol.getQualifiedIdentifier()) + "." + dref.right.name;
                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   try to resolve '" + fqn +"'");
                    this.resolver.lookup(fqn);
                }
                case ThisSymbol {
                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   found variable 'this'");
                    findMemberInStateSymbol(leftSymbol.stateSymbol, dref.right)
                }
                case VariableSymbol {
                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   found variable '" + dref.left.name + "'");
                    findInType(leftSymbol.declaration.varType, dref.right)
                }
                case DynamicSymbol {
                    var dynSymbol = this.sf.makeDynamicSymbol();
                    addSymbolForAST(leftSymbol.declaration.varType, dynSymbol);
                    addSymbolForAST(dref.right, dynSymbol);
                    makeSome(dynSymbol);                    
                }
                case StateSymbol {
                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   found state symbol");
                    NONE
                }
                case FieldSymbol {
                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   found field symbol");
                    findInType(leftSymbol.declaration.fieldType, dref.right);
                }
                case MethodSymbol {
                    DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   found method symbol");
                    NONE
                }
                default {
                    ERROR("<TypeResolutionPass> Found not supported symbol.");
                    NONE
                }
            }
        }                                               
    }
    
    method immutable Option resolveNode(immutable Node node)  {
        val leftSymbol = NONE;
        match (node) {
            case Identifier {
                DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   resolve Identifier");
                ifElse ( haveSymbolForAST(node) ) {
                    makeSome(symbolForAST(node).value);
                }{
                    NONE
                };
            }
            case Dereference {
                DEBUG(DEBUG_PRIO_LOW, "<TypeResolutionPass>   resolve Dereference");
                val leftSymbolOpt = resolveNode(node.left);
                match (leftSymbolOpt) {
                    case Some {
                        resolveDereference(node, leftSymbolOpt.value);
                    }
                    case None { NONE }
                }
            }
            default {
                ERROR("<TypeResolutionPass> Found not supported AST node.");
            }
        }
    }

    override method void visitDereference(immutable Dereference node) {
        DEBUG(DEBUG_PRIO_HIGH, "<TypeResolutionPass> found dereference.");
        val symbolOpt = resolveNode(node);
    }
}
