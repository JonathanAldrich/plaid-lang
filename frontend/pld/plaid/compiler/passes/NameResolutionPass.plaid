package plaid.compiler.passes;

import plaid.lang.math.min;
import plaid.lang.math.max;

import plaid.collections.makeLinkedList;

import plaid.ast.parsed.*;
import plaid.ast.util.makeStringFromQualifiedIdentifier;
import plaid.ast.util.EMPTY_TOKEN;

import plaid.compiler.ERROR;
import plaid.compiler.WARNING;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_HIGH;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.DEBUG_PRIO_LOW;
import plaid.compiler.Pass;
import plaid.compiler.Reporter;
import plaid.compiler.Context;
import plaid.compiler.symbolForAST;
import plaid.compiler.haveSymbolForAST;
import plaid.compiler.addSymbolForAST;



import plaid.compiler.context.TopLevelContext;
import plaid.compiler.context.LocalContext;
import plaid.compiler.context.ImportContext;
import plaid.compiler.context.StdLibContext;
import plaid.compiler.context.PackageContext;
import plaid.compiler.context.GlobalContext;

import plaid.compiler.resolver.ClasspathResolver;

import plaid.compiler.Symbol;
import plaid.compiler.symbol.VariableSymbol;
import plaid.compiler.symbol.SymbolFactory;
import plaid.compiler.symbol.TopSymbol;
import plaid.compiler.symbol.ThisSymbol;
import plaid.compiler.symbol.StateSymbol;
import plaid.compiler.symbol.PackageSymbol;
import plaid.compiler.symbol.StateValSymbol;
import plaid.compiler.symbol.StateRefSymbol;
import plaid.compiler.symbol.DynamicSymbol;

import java.util.Map;
import java.util.IdentityHashMap;


/*
 * expands the left most case of a dot
 */
state NameResolutionPass case of Pass = ParsedLeafVisitor with  {

    val unique Stack stack = new Stack;
    val immutable SymbolFactory sf = new SymbolFactory;
    var immutable String sourceFile = "";
    var shared Reporter reporter;
    var shared ClasspathResolver resolver;
    val unique Stack currentState = new Stack;
    var shared Symbol packageSymbol = new TopSymbol;
    var hasErrors = false;
    var immutable String packageName = "";
        

    method immutable Boolean run(unique Job job) {
        this.reporter = job.reporter;
        this.resolver = job.resolver;
        match (job.ast) {
            case Some {
                DEBUG(DEBUG_PRIO_HIGH, "<NameResolutionPass> started for '" + job.source.path + "'");
                this.sourceFile = job.source.path;
                this.reporter = reporter;
                this.stack.push(new TopLevelContext);

                // add global stack 
                val globalCtx = new GlobalContext {
                     parent = this.stack.peek().value; 
                     resolver = this.resolver;
                };
                this.stack.push(globalCtx);

                job.ast.value.accept(this);

                DEBUG(DEBUG_PRIO_HIGH, "<NameResolutionPass> finished for '" + job.source.path + "'");
                !this.hasErrors
            }
            default { 
                ERROR("<NameResolutionPass> AST invalid");
                false 
            }
        }
    }

    override method void LOG(immutable String msg) {
        DEBUG(DEBUG_PRIO_LOW, "<NameResolutionPass> " + msg);
    }    


    method immutable Option getQualifiedIdentifierFromDereference(immutable Dereference dref) {
        match (dref.left) {
            case ParsedIdentifier {
                val ids = makeLinkedList();
                ids.addLast(dref.left);
                ids.addLast(dref.right);
                makeSome(new ParsedQualifiedIdentifier {
                    token = EMPTY_TOKEN;
                    identifiers = ids;
                })
            }
            case ParsedDereference {
                val leftQIOpt = this.getQualifiedIdentifierFromDereference(dref.left);
                match (leftQIOpt) {
                    case Some {
                        val ids = makeLinkedList();
                        leftQIOpt.value.identifiers.map( fn (id) => ids.addLast(id) );
                        ids.addLast(dref.right);
                        makeSome(new ParsedQualifiedIdentifier {
                            token = EMPTY_TOKEN;
                            identifiers = ids;
                        })
                    }
                    case None { NONE }
                }                
            }
            default {
                NONE
            }
        }
    }

    
    method immutable Integer resolveQualifiedIdentifier(shared Context ctx,
                                                        immutable QualifiedIdentifier qi,
                                                        immutable Boolean reportErrors) {        
        var stop = false;
        var count = qi.identifiers.size();

        if ( count == 1 ) {
            val symbol = ctx.find(qi.identifiers.get(0).value.name);
            match (symbol) {
                case Some { 
                     addSymbolForAST(qi.identifiers.get(0).value, symbol.value);
                     addSymbolForAST(qi, symbol.value);
                     count = 1
                }
                case None { count = 0 }
            };
            stop = true;
        };

        while { count  > 0 && !stop }{
             var fqn = qi.identifiers.get(0).value.name;
             var i = 1;
             while {i < count}{
                 fqn = fqn + "." + qi.identifiers.get(i).value.name; 
                 i = i + 1;
             };
              
             val symbolOpt = this.resolver.lookup(fqn);
             match ( symbolOpt ) {
                 case Some {
                     stop = true;
                     var resolvedFqn = qi.identifiers.get(0).value.name;
                     var symbol = this.resolver.lookup(resolvedFqn);
                     addSymbolForAST(qi.identifiers.get(0).value, symbol.value);
                     var x = 1;
                     while {x < count }{
                         resolvedFqn = resolvedFqn + "." + qi.identifiers.get(x).value.name;
                         symbol = this.resolver.lookup(resolvedFqn);
                         addSymbolForAST(qi.identifiers.get(x).value, symbol.value);                 
                         x = x + 1;
                     };
                     // check for class we should have found
                     ifElse ( count < qi.identifiers.size()  ) {
                         match (symbol.value) {
                             case PackageSymbol {
                                 WARNING("<NameResolutionPass> Cannot resolve '" + fqn + "." + qi.identifiers.get(count).value.name  + "'");
                                 val first = qi.identifiers.get(0).value;
                                 val last  = qi.identifiers.get(count).value;
                                 val beginLine   = min(first.token.beginLine, last.token.beginLine);
                                 val endLine     = max(first.token.endLine, last.token.endLine);
                                 val beginColumn = first.token.beginColumn;
                                 val endColumn   = last.token.endColumn;
                                 this.reporter.error(java.io.File.new(this.sourceFile), 
                                                     beginLine,
                                                     beginColumn,
                                                     endLine,
                                                     endColumn,
                                                     "Cannot resolve '" + fqn + "." + qi.identifiers.get(count).value.name  + "'");
                             }
                             default {}
                         }
                     }{
                         addSymbolForAST(qi, symbol.value);
                     };
                 } 
                 case None {}
             };

             if (!stop) {
                count = count - 1;
             }
        };

        count;
    }


	override method void visitParsedAbstractFieldDecl(immutable ParsedAbstractFieldDecl node) {
        DEBUG(DEBUG_PRIO_LOW, "<NameResolutionPass> visit ParsedAbstractFieldDecl");
        match (this.currentState.peek() ) {
            case Some {
                // member
                val fieldSymbol = this.sf.makeFieldSymbol(node.name.name, node, this.currentState.peek().value);
                addSymbolForAST(node, fieldSymbol);
                this.currentState.peek().value.addAbstractMember(fieldSymbol);
            }
            case None {
                // top level
                val fieldSymbol = this.sf.makeFieldSymbol(node.name.name, node, this.packageSymbol);
                addSymbolForAST(node, fieldSymbol);
            }
        };

		node.specifier.accept(this);
		node.fieldType.accept(this);
		//node.name.accept(this);
		node.modifiers.map(fn (item) => { item.accept(this); item });
	}
    

	override method void visitParsedAbstractMethodDecl(immutable ParsedAbstractMethodDecl node) {
        DEBUG(DEBUG_PRIO_LOW, "<NameResolutionPass> visit ParsedAbstractMethodDecl");
        match ( this.currentState.peek() ) {
            case Some {
                // member
                val methodSymbol = this.sf.makeMethodSymbol(node.name.name, node, this.currentState.peek().value);
                addSymbolForAST(node, methodSymbol);                
                this.currentState.peek().value.addAbstractMember(methodSymbol);
            }
            case None {
                // top level
                val methodSymbol = this.sf.makeMethodSymbol(node.name.name, node, this.packageSymbol);
                addSymbolForAST(node, methodSymbol);
            }
        };
		node.returnType.accept(this);
		node.StaticArgsSpec.do(fn (item) => { item.accept(this) });
		node.arguments.do(fn (item) => { item.argSpec.accept(this) });
		node.environment.do(fn (item) => { 
            val shared VariableSymbol mySymbol = this.sf.makeVariableSymbol(item.name.name, item);
            addSymbolForAST(item, mySymbol);
            addSymbolForAST(item.name, mySymbol);        
            item.argSpec.accept(this);
        });
		//node.name.accept(this);
		node.modifiers.map(fn (item) => { item.accept(this); item });
	}

	override method void visitParsedAbstractStateDecl(immutable ParsedAbstractStateDecl node) {
		LOG("visit ParsedAbstractStateDecl");

        match (this.currentState.peek() ) {
            case Some {
                 // inner state
                 val stateSymbol = this.sf.makeStateSybmbol(node.name.name, node, this.currentState.peek().value);
                 this.currentState.push(stateSymbol);
                 addSymbolForAST(node.name, stateSymbol);
                 addSymbolForAST(node, stateSymbol);
         
                 val ctx = this.stack.peek().value;
                 ctx.put(node.name.name, stateSymbol);
                 this.currentState.peek().value.addMember(stateSymbol);
            }
            case None {
                // top-level  state
                //val unique Option stateSymbol = this.stack.peek().value.find(node.name.name);
                val unique Option stateSymbol = this.resolver.lookup(this.packageName + "." + node.name.name);
                match (stateSymbol) {
                    case None {
                        ERROR("<NameResolutionPass> Cannot find symbol for state '" + node.name.name + "'");                        
                    }
                    case Some {
                        this.currentState.push(stateSymbol.value);
                        addSymbolForAST(node.name, stateSymbol.value);
                        addSymbolForAST(node, stateSymbol.value);
                    }
                };
            }
        };

		node.caseOf.accept(this);
		node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
		node.metaCaseOfArgs.map(fn (item) => { item.accept(this); item });
		node.name.accept(this);
		node.modifiers.map(fn (item) => { item.accept(this); item });

        this.currentState.pop();
	}


	override method void visitParsedAssignment(immutable ParsedAssignment node) {
        DEBUG(DEBUG_PRIO_LOW, "<NameResolutionPass> visit ParsedAssignment");
		//node.target.accept(this);
		//node.field.accept(this);
        match ( node.target ) {
            case EmptyExpr {
                node.field.accept(this);
            }
            default {
                node.target.accept(this);
            }
        };
		node.value.accept(this);
	}

	override method void visitParsedBlockExpr(immutable ParsedBlockExpr node) {
        val shared Context ctxt = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(ctxt);

		node.statements.map(fn (item) => { item.accept(this); item });

        this.stack.pop();
	}


	override method void visitParsedCompilationUnit(immutable ParsedCompilationUnit node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<NameResolutionPass> visit CompilationUnit");

        this.packageName = makeStringFromQualifiedIdentifier(node.packageName);
        
        var currentSymbol = this.sf.makeTopSymbol();
        node.packageName.identifiers.map( fn (id) => {
            val currentSymbolOpt = this.stack.peek().value.findInSymbol(currentSymbol, id.name);
            match (currentSymbolOpt) {
                case Some {
                    currentSymbol = currentSymbolOpt.value;                    
                }
                case None {
                    currentSymbol = this.sf.makePackageSymbol(id.name, this.sf.makeTopSymbol());
                    val fqn = makeStringFromQualifiedIdentifier(currentSymbol.getQualifiedIdentifier());
                    this.resolver.define(fqn, currentSymbol);
                }
            };
            addSymbolForAST(id, currentSymbol);
        });
        addSymbolForAST(node.packageName, currentSymbol);
        this.packageSymbol = currentSymbol;


        val stdCtx = new StdLibContext {
           parent = this.stack.peek().value; 
           resolver = this.resolver;
        };
        this.stack.push(stdCtx);
        
        val packageString = makeStringFromQualifiedIdentifier(node.packageName);
        val shared PackageContext pkgCtx = new PackageContext {
           parent = this.stack.peek().value; 
           packageName = packageString;
           resolver = this.resolver;
        };
        this.stack.push(pkgCtx);
        
        val shared ImportContext impCtx = new ImportContext{ 
            parent = this.stack.peek().value; 
            imports = node.imports;
            resolver = this.resolver;
        };
        this.stack.push(impCtx);
        

		//node.packageName.accept(this);
		//node.imports.map(fn (item) => { item.accept(this); item });
		node.decls.map(fn (item) => { item.accept(this); item });
        
        impCtx.reportUnusedImports(this.reporter, this.sourceFile);

        this.stack.pop();
	}


	override method void visitParsedConcreteFieldDecl(immutable ParsedConcreteFieldDecl node) {
        DEBUG(DEBUG_PRIO_LOW, "<NameResolutionPass> visit ParsedConcreteFieldDecl");
        match (this.currentState.peek() ) {
            case Some {
                // member
                val fieldSymbol = this.sf.makeFieldSymbol(node.name.name, node, this.currentState.peek().value);
                addSymbolForAST(node, fieldSymbol);
                this.currentState.peek().value.addMember(fieldSymbol);
            }
            case None {
                // top level
                val fieldSymbol = this.resolver.lookup(this.packageName + "." + node.name.name);
                match (fieldSymbol) {
                    case Some {
s                        addSymbolForAST(node, fieldSymbol.value);
                    }
                    case None {
                        ERROR("<NameResolutionPass> Cannot find symbol for top-level method '" + this.packageName + "." + node.name.name + "'");
                    }
                }
            }
        };
		//node.name.accept(this);
		node.expression.accept(this);
		node.specifier.accept(this);
		node.fieldType.accept(this);
		//node.modifiers.map(fn (item) => { item.accept(this); item });
	}


    override method void visitParsedConcreteMethodDecl(immutable ParsedConcreteMethodDecl node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<NameResolutionPass> visit ConcreteMethodDecl");

        match (this.currentState.peek() ) {
            case Some {
                // member
                val methodSymbol = this.sf.makeMethodSymbol(node.name.name, node, this.currentState.peek().value);
                addSymbolForAST(node, methodSymbol);
                addSymbolForAST(node.name, methodSymbol);
                this.currentState.peek().value.addMember(methodSymbol);
            }
            case None {
                // top level
                //val methodSymbol = this.sf.makeMethodSymbol(node.name.name, node, this.packageSymbol);
                val methodSymbol = this.resolver.lookup(this.packageName + "." + node.name.name);
                match (methodSymbol) {
                    case Some {
                        addSymbolForAST(node, methodSymbol.value);
                    }
                    case None {
                        ERROR("<NameResolutionPass> Cannot find symbol for top-level method '" + this.packageName + "." + node.name.name + "'");
                    }
                }
            }
        };


        val shared Context ctxt = new LocalContext{ parent = this.stack.peek().value; };
        this.stack.push(ctxt);


        // add arguments to context
        node.arguments.do( fn (arg) => {
            DEBUG(DEBUG_PRIO_MEDIUM, "<NameResolutionPass>     add parameter entry '" + arg.name.name +"'");
            val shared VariableSymbol mySymbol = this.sf.makeVariableSymbol(arg.name.name, arg);
            addSymbolForAST(arg, mySymbol);
            val ctx = this.stack.peek().value;
            ctx.put(arg.name.name, mySymbol);
            arg.argSpec.accept(this);
        });

        node.modifiers.do(fn (item) => { item.accept(this)  });
        node.StaticArgsSpec.do(fn (item) => { item.accept(this) });
        node.returnType.accept(this);
        node.environment.do(fn (item) => { 
            DEBUG(DEBUG_PRIO_MEDIUM, "<NameResolutionPass>     add environment entry '" + item.name.name +"'");
            val shared VariableSymbol mySymbol = this.sf.makeVariableSymbol(item.name.name, item);
            addSymbolForAST(item, mySymbol);            
            item.argSpec.accept(this);

            // add this to the context
            if ( item.name.name == "this") {
                val ctx = this.stack.peek().value;
                ctx.put(item.name.name, mySymbol);  
            };
         });
        //node.name.accept(this);

        //node.body.accept(this);
        node.body.statements.do( fn (stmt) => { stmt.accept(this) });
        
        this.stack.pop();
    }


  	override method void visitParsedConcreteStateDecl(immutable ParsedConcreteStateDecl node) {
        DEBUG(DEBUG_PRIO_LOW, "<NameResolutionPass> visit ParsedConcreteStateDecl");
        match (this.currentState.peek() ) {
            case Some {
                 // inner state
                 val stateSymbol = this.sf.makeStateSybmbol(node.name.name, node, this.currentState.peek().value);
                 this.currentState.push(stateSymbol);
                 addSymbolForAST(node.name, stateSymbol);
                 addSymbolForAST(node, stateSymbol);
         
                 val ctx = this.stack.peek().value;
                 ctx.put(node.name.name, stateSymbol);
                 this.currentState.peek().value.addMember(stateSymbol);
            }
            case None {
                // top-level  state
                //val unique Option stateSymbol = this.stack.peek().value.find(node.name.name);
                val unique Option stateSymbol = this.resolver.lookup(this.packageName + "." + node.name.name);
                match (stateSymbol) {
                    case None {
                        ERROR("<NameResolutionPass> Cannot find symbol for state '" + node.name.name + "'");                        
                    }
                    case Some {
                        this.currentState.push(stateSymbol.value);
                        addSymbolForAST(node.name, stateSymbol.value);
                        addSymbolForAST(node, stateSymbol.value);
                    }
                };
            }
        };

        // create this and add new context
        val stateCtx = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(stateCtx);
        //val shared ThisSymbol thisSymbol = this.currentState.peek().value.getThisSymbol();
        //stateCtx.put("this", thisSymbol);


		node.caseOf.accept(this);
		node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
		node.metaCaseOfArgs.map(fn (item) => { item.accept(this); item });
		node.name.accept(this);
		node.modifiers.map(fn (item) => { item.accept(this); item });
		node.stateBinding.accept(this);

        this.currentState.pop();
        this.stack.pop();
	}


    override method void visitParsedConcreteStateValDecl(immutable ParsedConcreteStateValDecl node) {
        val shared StateValSymbol mySymbol = this.sf.makeStateValSymbol(node.name.name, node);
        addSymbolForAST(node.name, mySymbol);
        val ctx = this.stack.peek().value;
        ctx.put(node.name.name, mySymbol);

        // create this and add new context
        val stateCtx = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(stateCtx);
        val shared ThisSymbol thisSymbol = this.sf.makeThisSymbol(mySymbol);
        stateCtx.put("this", thisSymbol);

        node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
        //node.name.accept(this);
        node.modifiers.map(fn (item) => { item.accept(this); item });
        node.stateBinding.accept(this);

        this.stack.pop();        
    }  


	override method void visitParsedIdentifier(immutable ParsedIdentifier node) {
        val symbol = this.stack.peek().value.find(node.name);
        match (symbol) {
            case Some {
               DEBUG(DEBUG_PRIO_LOW, "<NameResolutionPass> Found symbol for '" + node.name + "'");
               addSymbolForAST(node, symbol.value);
           }
           case None {
               this.reporter.errorToken(java.io.File.new(this.sourceFile), node.token, "Cannot resolve '" + node.name + "'");
           }
       }
	}
    

	override method void visitParsedDereference(immutable ParsedDereference node) {
        DEBUG(DEBUG_PRIO_LOW, "<NameResolutionPass> visit ParsedDereference");
        val qiOpt = this.getQualifiedIdentifierFromDereference(node);
        match (qiOpt) {
            case Some {
                DEBUG(DEBUG_PRIO_HIGH, "<NameResolutionPass> Found potential QI: " + makeStringFromQualifiedIdentifier(qiOpt.value));
                // check if left most can be resolved before we try to resolve the whole QI
                DEBUG(DEBUG_PRIO_MEDIUM, "<NameResolutionPass>   check if left most identifier '"+qiOpt.value.identifiers.get(0).value.name+"' can be resolved");
                val symbol = this.stack.peek().value.find(qiOpt.value.identifiers.get(0).value.name);
                match (symbol) {
                    case None {
                        DEBUG(DEBUG_PRIO_MEDIUM, "<NameResolutionPass>   left most identifier cannot be resolved, try to resolve whole QualifiedIdentifier");
                        val immutable Integer resolvedCount = this.resolveQualifiedIdentifier(this.stack.peek().value, qiOpt.value, true);
                        DEBUG(DEBUG_PRIO_HIGH, "<NameResolutionPass>   resolved  " + resolvedCount + " parts");
                        if ( resolvedCount == 0 ) {
                            //val mostLeftId = qiOpt.value.identifiers.get(0);
                            //this.reporter.errorToken(java.io.File.new(this.sourceFile), mostLeftId.token, "Cannot resolve '" + mostLeftId.name + "'");
                        node.left.accept(this);
                        };
                    }
                    case Some {
                        node.left.accept(this);
                    }
                }
            }
            case None {
                node.left.accept(this);
            }
        };
        
		//node.left.accept(this);
		//node.right.accept(this);
	}


	override method void visitParsedDestructiveDereference(immutable ParsedDereference node) {
		node.left.accept(this);
		//node.right.accept(this);
	}


	override method void visitParsedInfixOperatorExpr(immutable ParsedInfixOperatorExpr node) {
		node.left.accept(this);
		node.right.accept(this);
		//node.operator.accept(this);
	}

	override method void visitParsedLambda(immutable ParsedLambda node) {
        DEBUG(DEBUG_PRIO_LOW, "<NameResolutionPass> visit ParsedLambda");
        val shared Context ctxt = new LocalContext{ parent = this.stack.peek().value;};
        this.stack.push(ctxt);

        // add arguments to context
        node.arguments.map( fn (arg) => {
            val shared VariableSymbol mySymbol = this.sf.makeVariableSymbol(arg.name.name, node);
            addSymbolForAST(arg.name, mySymbol);
            val ctx = this.stack.peek().value;
            ctx.put(arg.name.name, mySymbol);
            arg
        });

        //node.arguments.map(fn (item) => { item.accept(this); item });
        node.StaticArgsSpec.map(fn (item) => { item.accept(this); item });
        node.environment.map(fn (item) => { item.accept(this); item });

        // if we have a block expression as body we have to bypass it to 
        // avoid that we create an extra context
        match (node.body) {
            case ParsedBlockExpr {
                node.body.statements.map( fn (stmt) => { stmt.accept(this); stmt } );
            }
            default {
                node.body.accept(this);
            }
        };
        
        this.stack.pop();
	}


	override method void visitParsedLambdaType(immutable ParsedLambdaType node) {
		node.metaTypes.map(fn (item) => { item.accept(this); item });
		node.argTypes.map(fn (item) => { item.accept(this); item });
		node.env.map(fn (item) => { item.accept(this); item });
		node.returnType.accept(this);

        val lambdaTypeSymbol = sf.makeLambdaTypeSymbol(node);
        addSymbolForAST(node, lambdaTypeSymbol);
	}

	override method void visitParsedQualifiedIdentifier(immutable ParsedQualifiedIdentifier node) {
        DEBUG(DEBUG_PRIO_LOW, "<NameResolutionPass> visit ParsedQualifiedIdentifier");
        val resolveCount = this.resolveQualifiedIdentifier(this.stack.peek().value, node, false);
        ifElse ( resolveCount == node.identifiers.size() ) {
            DEBUG(DEBUG_PRIO_MEDIUM, "<NameResolutionPass> Resolved '" + makeStringFromQualifiedIdentifier(node) +"'");
            if ( !haveSymbolForAST(node) ) {
                ABORT("QI not in cache !!!!!");
            };
        }{
            ERROR("Failed to resolve '" + makeStringFromQualifiedIdentifier(node) + "'");
            val first = node.identifiers.get(0).value;
            val last  = node.identifiers.get(node.identifiers.size() - 1).value;
            val beginLine   = min(first.token.beginLine, last.token.beginLine);
            val endLine     = max(first.token.endLine, last.token.endLine);
            val beginColumn = min(first.token.beginColumn, last.token.beginColumn);
            val endColumn   = max(first.token.endColumn, last.token.endColumn);
            this.reporter.error(java.io.File.new(this.sourceFile), 
                                beginLine,
                                beginColumn,
                                endLine,
                                endColumn,
                               "Cannot resolve '" + makeStringFromQualifiedIdentifier(node) + "'");
        }
	}


	override method void visitParsedStateRef(immutable ParsedStateRef node) {
        val shared StateRefSymbol stateRefSymbol = this.sf.makeStateRefSymbol(node);
        this.currentState.push(stateRefSymbol);

		node.stateExpr.accept(this);
		node.specializations.map(fn (item) => { item.accept(this); item });

        this.currentState.pop();
	}

	override method void visitParsedUnaryOperatorExpr(immutable ParsedUnaryOperatorExpr node) {
		node.expression.accept(this);
		//node.operator.accept(this);
	}

    override method void visitParsedVarDecl(immutable ParsedVarDecl node) {
        DEBUG(DEBUG_PRIO_LOW, "<NameResolutionPass> visit ParsedVarDecl");

        node.specifier.accept(this);
        node.varType.accept(this);
        //node.id.accept(this);
        node.expr.accept(this);
        
        val shared VariableSymbol mySymbol = this.sf.makeVariableSymbol(node.id.name, node);
        val ctx = this.stack.peek().value;
        val result = ctx.put(node.id.name, mySymbol);
        ifElse ( result ) {
            addSymbolForAST(node.id, mySymbol);
            addSymbolForAST(node, mySymbol);
        }{
            ERROR("<NameResolutionPass> Variable '"+ node.id.name +"' already declared.");
            val otherSymbol = ctx.find(node.id.name);
            match (otherSymbol) {
                case Some {
                   val otherDecl = otherSymbol.value.declaration;
                   this.reporter.errorToken(java.io.File.new(this.sourceFile), node.id.token, "Variable '" +  node.id.name + "' already declared in line " + otherDecl.token.beginLine);
                }
                case None {
                   this.reporter.errorToken(java.io.File.new(this.sourceFile), node.id.token, "Variable '" + node.id.name + "' already declared.");
                }
            };
            this.hasErrors = true;
        }
    }
}
