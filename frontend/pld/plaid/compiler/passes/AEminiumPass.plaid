package plaid.compiler.passes;

import plaid.ast.parsed.ParsedLeafVisitor;
import plaid.ast.util.makeStringFromQualifiedIdentifier;

import plaid.compiler.ERROR;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.Pass;

import plaid.compiler.*;

import plaid.compiler.typechecker.*;

state AEminiumPass case of Pass = ParsedLeafVisitor with {
  var hasErrors = false;
    
    method immutable Boolean run(unique Job job) {
        match (job) {
          case UserJob {
              match (job.ast) {
                  case Some {
                    ifElse ( AEMINIUM_MODE()  ) {
                        DEBUG(DEBUG_PRIO_HIGH, "<AEminiumPass> started");
                    
                        job.ast.value.accept(this);
                
                        DEBUG(DEBUG_PRIO_HIGH, "<AEminiumPass> finished");
                        !this.hasErrors;
                    }{
                        true
                    }
                  }
                  default {
                    ERROR("<AEminiumPass> AST invalid");
                      false
                  }
              }
          }
          case CompilerJob {
              DEBUG(DEBUG_PRIO_HIGH, "<AEminiumPass> skip CompilerJob");
              true
          }
        }
    }
    
    override method void LOG(immutable String msg) {
        DEBUG(DEBUG_PRIO_LOW, "<AEminiumPass> " + msg);
    }
    
    override method void visitParsedConcreteMethodDecl(immutable ParsedConcreteMethodDecl node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<AEminiumPass> found Method Declaration '" + node.name.name + "'");
    
    }
}