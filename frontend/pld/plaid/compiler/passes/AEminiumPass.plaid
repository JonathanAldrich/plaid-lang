package plaid.compiler.passes;

import plaid.ast.parsed.ParsedLeafVisitor;
import plaid.ast.util.makeStringFromQualifiedIdentifier;

import plaid.compiler.ERROR;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.Pass;

import plaid.compiler.*;
import plaid.compiler.typechecker.*;
import plaid.compiler.aeminium.*;
import plaid.compiler.permissions.*;

state AEminiumPass case of Pass = ParsedLeafVisitor with {
    var hasErrors = false;
    
    method immutable Boolean run(unique Job job) {
        match (job) {
          case UserJob {
              match (job.ast) {
                  case Some {
                    ifElse ( AEMINIUM_MODE()  ) {
                        DEBUG(DEBUG_PRIO_HIGH, "<AEminiumPass> started");
                    
                        job.ast.value.accept(this);
                
                        DEBUG(DEBUG_PRIO_HIGH, "<AEminiumPass> finished");
                        !this.hasErrors;
                    }{
                        true
                    }
                  }
                  default {
                    ERROR("<AEminiumPass> AST invalid");
                      false
                  }
              }
          }
          case CompilerJob {
              DEBUG(DEBUG_PRIO_HIGH, "<AEminiumPass> skip CompilerJob");
              true
          }
        }
    }
    
    override method void LOG(immutable String msg) {
        //DEBUG(DEBUG_PRIO_LOW, "<AEminiumPass> " + msg);
    }
    
    override method void visitParsedConcreteMethodDecl(immutable ParsedConcreteMethodDecl node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<AEminiumPass> found Method Declaration '" + node.name.name + "'");
        
        // get dependency information for 
        val unique DependencyInformationCollector dic = new DependencyInformationCollector;
        node.accept(dic);
        val unique Set infos = dic.getNodes();
        DEBUG(DEBUG_PRIO_MEDIUM, "<AEminiumPass>     found " + infos.size() + " information nodes");
        
        
        //remove join-split connections
        val unique Set joinSplitFree = removeNonsenseJoinSplit(infos);
        dumpGraph(node, "JOIN-SPLIT");
        
        // remove split-split connections
        val unique Set splitSplitFree = removeSplitSplit(joinSplitFree);
        dumpGraph(node, "SPLIT-SPLIT");
        
        // remove join-join connections
        val unique Set joinJoinFree = removeJoinJoin(splitSplitFree);
        dumpGraph(node, "JOIN-JOIN");
    }
    
    /***********************************************************************
     **                   optimization functions                          **
     ***********************************************************************/
    
    
    method void removeDependencyInformation(shared DependencyInformation depInfo)  {
        DEBUG(DEBUG_PRIO_HIGH, "<AEminiumPass> REMOVE " + depInfo.toString() );
        
        // remove node from dependents 
        val rdepsIt = depInfo.rdeps.iterator();
        while { rdepsIt.hasNext() }{
            val shared DepenendencyInformation rdep = rdepsIt.next();
            
            // remove depInfo from rdep
            rdep.deps.remove(depInfo);
            
            // connect to deps of DepInfo
            val depsIt = depInfo.deps.iterator();
            while { depsIt.hasNext() }{
                val shared DependencyInformation dep = depsIt.next();
                
                // remove depInfo from dep
                dep.rdeps.remove(depInfo);
                
                // add connection between rdep -> dep
                addDependency(rdep, dep);
            }
        }
    }
 
    method shared JoinInformation findNextJoin(shared SplitInformation splitInfo) {
        val joins = getJoinInformation(splitInfo.rdeps);
        ifElse ( joins.size() > 0 ) {
            if ( joins.size() != 1 ) { ABORT("<AEminiumPass> found too many joins.") };
            joins.iterator().next()
        }{
            val splits = getSplitInformation(splitInfo.rdeps);
            ifElse ( splits.size() > 0 ) {
                if ( splits.size() != 1 ) { ABORT("<AEminiumPass> found too many splits.") };
                findNextJoin(splits.iterator().next());
            }{
                ABORT("<AEminiumPass> couldn't find split information to continue");
            }
        }
    }
 
    method void fixNonsenseJoinSplit(shared JoinInformation upperJoin,
                                     shared SplitInformation splitInfo,
                                     shared JoinInformation lowerJoin) {
        val depsIt = upperJoin.deps.iterator();
        while { depsIt.hasNext() }{
            val depNext = depsIt.next();
            depNext.rdeps.remove(upperJoin);
            addDependency(lowerJoin, depNext);
        };
        
        val upperSplit = getSplitInformation(upperJoin.deps).iterator().next();
        val splitsIt = splitInfo.rdeps.iterator();
        while {splitsIt.hasNext()}{
            val splitNext = splitsIt.next();
            splitNext.deps.remove(splitInfo);
            
            addDependency(splitNext, upperSplit);
        }
    }
                                     
 
    method unique Set removeNonsenseJoinSplit(unique Set infos) {
        val unique Set result = java.util.HashSet.new();
        
        val it = infos.iterator();
        while { it.hasNext() }{
            val shared DependencyInformation depInfo = it.next();
            
            match (depInfo) {
                case SplitInformation {                    
                    ifElse ( depInfo.deps.size() == 1 ) {
                        val shared DependencyInformation upperJoin = depInfo.deps.iterator().next();
                        match (upperJoin) {
                            case JoinInformation {
                                if ( depInfo.permOut == upperJoin.permIn ) {
                                   DEBUG(DEBUG_PRIO_HIGH, "<AEminiumMode> Found nonsense join/split");
                                   val splitInfo = depInfo; 
                                   val lowerJoin = findNextJoin(splitInfo);
                                   fixNonsenseJoinSplit(upperJoin, splitInfo, lowerJoin);
                               }
                            }
                            default { result.add(depInfo) }
                        }
                    }{
                        result.add(depInfo);
                    }                
                }
                default { result.add(depInfo) }
            }
        };
        
        result
    }
    
    
    method void fixSplitSplit(shared DependencyInformation splitInfo) {
        removeDependencyInformation(splitInfo);
    }

    method void fixJoinJoin(shared DependencyInformation splitInfo) {
        removeDependencyInformation(splitInfo);
    }
    
    method immutable Permission simplePermission(immutable Permission perm) {
        match (perm){
            case ImmutablePermission { perm }
            case SharedPermission    { perm }
            case UniquePermission    { perm }
            case NonePermission      { perm }
            case LocalPermission     { perm.thePerm }
            case BorrowedPermission  { perm.thePerm }
            default                  { ABORT("<AEminiumPass> found not supported permission: " + perm.toString()) }
        }        
    }

    method unique Set removeSplitSplit(unique Set infos) {
        val unique Set result = java.util.HashSet.new();
        
        val it = infos.iterator();
        while { it.hasNext() }{
            val shared DependencyInformation depInfo = it.next();
            
            match (depInfo) {
                case SplitInformation {                    
                    ifElse ( simplePermission(depInfo.permIn) == simplePermission(depInfo.permOut) ) {
                        val upperSplits = getSplitInformation(depInfo.deps);
                        ifElse ( upperSplits.size() > 0) {
                            DEBUG(DEBUG_PRIO_HIGH, "<AEminiumPass> found split hierarchy ");
                            if ( upperSplits.size() != 1 ) { ABORT("<AEminiumPass> cannot have more than one split") };
                            fixSplitSplit(depInfo);                            
                        }{
                            result.add(depInfo)
                        }
                    }{
                        result.add(depInfo);
                    }
                }
                default { result.add(depInfo) }
            }
        };
        
        result      
    }
    
    method unique Set removeJoinJoin(unique Set infos) {
        val unique Set result = java.util.HashSet.new();
        
        val it = infos.iterator();
        while { it.hasNext() }{
            val shared DependencyInformation depInfo = it.next();
            
            match (depInfo) {
                case JoinInformation {                    
                    ifElse ( simplePermission(depInfo.permIn) == simplePermission(depInfo.permOut) ) {
                        val lowerJoins = getJoinInformation(depInfo.rdeps);
                        ifElse ( lowerJoins.size() > 0) {
                            DEBUG(DEBUG_PRIO_HIGH, "<AEminiumPass> found join hierarchy ");
                            if ( lowerJoins.size() != 1 ) { ABORT("<AEminiumPass> cannot have more than one split") };
                            fixJoinJoin(depInfo);                            
                        }{
                            result.add(depInfo)
                        }
                    }{
                        result.add(depInfo);
                    }
                }
                default { result.add(depInfo) }
            }
        };
        
        result      
    }
}