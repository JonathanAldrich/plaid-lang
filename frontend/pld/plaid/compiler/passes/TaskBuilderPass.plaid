package plaid.compiler.passes;

import plaid.ast.parsed.ParsedLeafVisitor;
import plaid.ast.util.makeStringFromQualifiedIdentifier;

import plaid.compiler.ERROR;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.Pass;

import plaid.compiler.*;
import plaid.compiler.typechecker.*;
import plaid.compiler.aeminium.*;
import plaid.compiler.aeminium.tasks.*;
import plaid.compiler.permissions.*;
import plaid.compiler.util.*;

import plaid.ast.parsed.*;

import plaid.lang.math.*;

state TaskBuilderPass case of Pass = ParsedLeafVisitor with {
    var hasErrors = false;
    var immutable Boolean USE_SARKAR = true;
    
    method immutable Boolean run(unique Job job) {
        match (job) {
          case UserJob {
              match (job.ast) {
                  case Some {
                    ifElse ( AEMINIUM_MODE()  ) {
                        DEBUG(DEBUG_PRIO_HIGH, "<TaskBuilderPass> started");
                    
                        job.ast.value.accept(this);
                
                        DEBUG(DEBUG_PRIO_HIGH, "<TaskBuilderPass> finished");
                        !this.hasErrors;
                    }{
                        true
                    }
                  }
                  default {
                      ERROR("<TaskBuilderPass> AST invalid");
                      false
                  }
              }
          }
          case CompilerJob {
              DEBUG(DEBUG_PRIO_HIGH, "<AEminiumPass> skip CompilerJob");
              true
          }
        }
    }
    
    override method void LOG(immutable String msg) {
        //DEBUG(DEBUG_PRIO_LOW, "<TaskBuilderPass> " + msg);
    }
    
    override method void visitParsedConcreteMethodDecl(immutable ParsedConcreteMethodDecl node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> found Method Declaration '" + node.name.name + "'");

	    val shared Symbol methSymbol = match (symbolForAST(node)) {
	        case Some  { symbolForAST(node).value }
	        case None  { ABORT("<TaskBuilderPass> cannot find symbol for " + node.nodeName()) }
	    };
	    val name = methSymbol.name;
	    val path = symbolToString(methSymbol);
        
        
        ifElse ( typecheckingEnabled(node) ) {         
            // get dependency information for 
            val unique DependencyInformationCollector dic = new DependencyInformationCollector;
            node.accept(dic);
            val shared Set infos = dic.getNodes();
            DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass>     found " + infos.size() + " dependency information nodes");
            
            val unique LinkedList ops = makeLinkedList();
            ops.addLast( fn (depInfos) => {
                 val result = this.removeSplitAndJoinDependencies(depInfos);
                 dumpGraph(node, "DEL-SPLIT-JOIN");
                 result
            });
            ops.addLast( fn (depInfos) => {
                 val result = this.removeArguments(depInfos);
                 dumpGraph(node, "DEL-ARGS");
                 result
            });
            ops.addLast( fn (depInfos) => {
                 val result = this.removeLiterals(depInfos);
                 dumpGraph(node, "DEL-LITERALS");
                 result
            });
            ops.addLast( fn (depInfos) => {
                 val result = this.removeIds(depInfos);
                 dumpGraph(node, "DEL-ID");
                 result
            });
            ops.addLast( fn (depInfos) => {
                 val result = this.removeFieldRestores(depInfos);
                 dumpGraph(node, "DEL-FIELD-RESTORES");
                 result
            });
            ops.addLast( fn (depInfos) => {
                 val result = this.removeDereferences(depInfos);
                 dumpGraph(node, "DEL-DREF");
                 result
            });
            ops.addLast( fn (depInfos) => {
                 val result = this.removeTransitiveDependencies(depInfos);
                 dumpGraph(node, "DEL-TRANS");
                 result
            });          
            // execute ops
            var unique Set nodes = infos; 
            ops.do( fn (op) => {
                nodes = op(nodes);
            });
            
            // dump final graph
            dumpGraph(node, "TASK-FINAL");
            
            // compute tasks
            val tasks = computeTasks(path, nodes);
            
            // dump task graph
            //dumpTaskGraph(path, "TASK-ORIGIN", tasks);
        }{
            DEBUG(DEBUG_PRIO_HIGH, "<TaskBuilderPass> SKIP method " + node.name.name);
        }
    }
    
    
    method immutable Boolean hasTransitiveDependency(shared DependencyInformation depInfo, shared Set deps) {
        val it = deps.iterator();
        var result = false;
        
        while { it.hasNext() && result == false }{
            val curInfo = it.next();
            ifElse ( curInfo == depInfo ) {
                result = true
            }{
                //printLine("check for trans dep " + curInfo.toString() );
                if ( result == false ) {
                    result = hasTransitiveDependency(depInfo, curInfo.deps)
                }
            };
        };
        
        result
    }
    
    method void removeTransitiveDependencies(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeTransitiveDependencies");
        
        val it = infos.iterator();
        while { it.hasNext() }{
            val curInfo = it.next(); 
            val depsIt =  curInfo.deps.iterator();
            
            // find deps that have transitive dependencies
            val removeSet = java.util.HashSet.new();
            while { depsIt.hasNext() }{
                val nextDep = depsIt.next();
                
                val depSet = java.util.HashSet.new();
                depSet.addAll(curInfo.deps);
                depSet.remove(nextDep);
                
                if ( hasTransitiveDependency(nextDep, depSet) ) {
                    DEBUG(DEBUG_PRIO_LOW, "<TaskBuilderPass> remove dependency " + curInfo.toString() + " -> " + nextDep.toString() );
                    removeSet.add(nextDep);
                };
            };
            
            // remove found edges
            if ( removeSet.size() > 0 ) {
                val removeIt = removeSet.iterator();
                
                while { removeIt.hasNext() }{
                    removeDependency(curInfo, removeIt.next());
                }
            };
        }; 
        
        infos
    }
    
    method void removeSplitAndJoinDependencies(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeSplitAndJoinDependencies");
        val result = java.util.HashSet.new();
        val it = infos.iterator();
        
        while { it.hasNext() }{
            val nextInfo = it.next();
            match (nextInfo) {
                case JoinInformation  { removeDependencyInformation(nextInfo) }
                case SplitInformation { removeDependencyInformation(nextInfo) }
                default{ result.add(nextInfo) }
            }
        };
        
        result
    }
    
    method void removeArguments(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeArguments");
        val result = java.util.HashSet.new();
        val it = infos.iterator();
        
        while { it.hasNext() }{
            val nextInfo = it.next();
            match (nextInfo) {
                case ASTInformation {
                    match (nextInfo.node) {
                        case ParsedArg {
                            removeDependencyInformation(nextInfo) 
                        }
                        default { result.add(nextInfo) } 
                    }
                }
                default{ result.add(nextInfo) }
            }
        };
        
        result
    }
 
    method void removeLiterals(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeLiterals");
        val result = java.util.HashSet.new();
        val it = infos.iterator();
        
        while { it.hasNext() }{
            val nextInfo = it.next();
            match (nextInfo) {
                case ASTInformation {
                    match (nextInfo.node) {
                        case ParsedLiteral {
                            removeDependencyInformation(nextInfo) 
                        }
                        default { result.add(nextInfo) } 
                    }
                }
                default{ result.add(nextInfo) }
            }
        };
        
        result
    }   

    method void removeIds(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeSplitAndJoinDependencies");
        val result = java.util.HashSet.new();
        val it = infos.iterator();
        
        while { it.hasNext() }{
            val nextInfo = it.next();
            match (nextInfo) {
                case ASTInformation {
                    match (nextInfo.node) {
                        case ParsedIdentifier {
                            removeDependencyInformation(nextInfo) 
                        }
                        default { result.add(nextInfo) } 
                    }
                }
                default{ result.add(nextInfo) }
            }
        };
        
        result
    }
    
    method void removeFieldRestores(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeFieldRestores");
        val result = java.util.HashSet.new();
        val it = infos.iterator();
        
        while { it.hasNext() }{
            val nextInfo = it.next();
            match (nextInfo) {
                case FieldRestoreInformation {
                    removeDependencyInformation(nextInfo) 
                }
                default{ result.add(nextInfo) }
            }
        };
        
        result
    }
    
    method void removeDereferences(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeDereferences");
        val result = java.util.HashSet.new();
        val it = infos.iterator();
        
        while { it.hasNext() }{
            val nextInfo = it.next();
            match (nextInfo) {
                case ASTInformation {
                    match (nextInfo.node) {
                        case ParsedDereference {
                            removeDependencyInformation(nextInfo) 
                        }
                        default { result.add(nextInfo) } 
                    }
                }
                default{ result.add(nextInfo) }
            }
        };
        
        result
    }   

    /************************************************************************
     **                           Task Builder                             ** 
     ************************************************************************/
    
    method void connectTasks(shared Task from, shared Task to) {
        //DEBUG(DEBUG_PRIO_LOW,"<TaskBulderPass> create connection " + from.toString() + " -> " + to.toString());
        from.deps.add(to);
        to.rdeps.add(from);
    }
    
    method unique Set/*Task*/ createTaskGraph(shared Set infos) {
         val infoToTask = java.util.IdentityHashMap.new();
         
         // create tasks
         val createIt = infos.iterator();
         while { createIt.hasNext() }{
             val nextInfo = createIt.next();
             val task = makeTask();
             task.infos.add(nextInfo);
             infoToTask.put(nextInfo, task);
             DEBUG(DEBUG_PRIO_LOW, "<TaskBuilder> create task " + task.toString() + " for " + task.infos.iterator().next().toString());
         };
         
         // setup connections 
         val connectIt = infos.iterator();
         while { connectIt.hasNext() }{
             val curInfo = connectIt.next();
             val curTask = infoToTask.get(curInfo);
             
             // connect dependencies
             val depsIt = curInfo.deps.iterator();
             while { depsIt.hasNext() }{
                 val depInfo = depsIt.next();
                 val depTask = infoToTask.get(depInfo);
                 connectTasks(curTask, depTask);  
             };
             
             // connect reverse dependencies (not necessary??)
             val rdepsIt = curInfo.rdeps.iterator();
             while { rdepsIt.hasNext() }{
                 val rdepInfo = rdepsIt.next();
                 val rdepTask = infoToTask.get(rdepInfo);
                 connectTasks(rdepTask, curTask);  
             };
         }; 

         
         // create task set
         val result = java.util.HashSet.new();
         result.addAll(infoToTask.values());
         result
    }

     method immutable Integer computeMinimimPathNodeWithoutEdge(shared Task task,
                                                                shared Task edgeFrom,
                                                                shared Task edgeTo) {
        var length = match ( task.rdeps.size() == 0 ) {
            case True {
                // check if we are the end of the connection 
                ifElse (task == edgeTo) {
                    task.getWeight() + edgeFrom.getWeight()
                }{
                    task.getWeight()
                }
            }
            case False { 1000000000 }
        };
        
        val it = task.rdeps.iterator();
        while { it.hasNext() }{
            val curTask = it.next();
            
            val immutable Integer curTaskLength = computeMinimimPathNodeWithoutEdge(curTask, edgeFrom, edgeTo);
            
            //printLine("curTaskLength = " + curTaskLength);
            
            ifElse ( task == edgeFrom ) {
                ifElse ( curTask == edgeTo) {
                    val curLength = curTaskLength;
                    //printLine("curLength = " + curLength);
                    length = min(length, curLength);
                }{
                    val curLength = task.getWeight() + edgeTo.getWeight() + 1 + curTaskLength;
                    //printLine("curLength = " + curLength);
                    length = min(length, curLength);
                }
            }{
                ifElse ( task == edgeTo ) {
                    val curLength = task.getWeight() + edgeFrom.getWeight() + 1 + curTaskLength;
                    //printLine("curLength = " + curLength);
                    length = min(length, curLength);                    
                }{
                    val curLength = task.getWeight() + 1 + curTaskLength;
                    //printLine("curLength = " + curLength);
                    length = min(length, curLength);                
                }
            };
            
        };   

        //printLine("cs from task " + task.toString() + "   "+ length);
        length
    }
 
     method immutable Integer computeCriticalPathTaskWithoutEdge(shared Task task,
                                                                 shared Task edgeFrom,
                                                                 shared Task edgeTo) {
        var length = match ( task.rdeps.size() == 0 ) {
            case True {
                // check if we are the end of the connection 
                ifElse (task == edgeTo) {
                    task.getWeight() + edgeFrom.getWeight()
                }{
                    task.getWeight()
                }
            }
            case False { task.getWeight() }
        };
        
        val it = task.rdeps.iterator();
        while { it.hasNext() }{
            val curTask = it.next();
            
            val immutable Integer curTaskLength = computeCriticalPathTaskWithoutEdge(curTask, edgeFrom, edgeTo);
            
            //printLine("curTaskLength = " + curTaskLength);
            
            ifElse ( task == edgeFrom ) {
                ifElse ( curTask == edgeTo) {
                    val curLength = curTaskLength;
                    //printLine("curLength = " + curLength);
                    length = max(length, curLength);
                }{
                    val curLength = task.getWeight() + edgeTo.getWeight() + 1 + curTaskLength;
                    //printLine("curLength = " + curLength);
                    length = max(length, curLength);
                }
            }{
                ifElse ( task == edgeTo ) {
                    val curLength = task.getWeight() + edgeFrom.getWeight() + 1 + curTaskLength;
                    //printLine("curLength = " + curLength);
                    length = max(length, curLength);                    
                }{
                    val curLength = task.getWeight() + 1 + curTaskLength;
                    //printLine("curLength = " + curLength);
                    length = max(length, curLength);                
                }
            };
            
        };   

        //printLine("cs from task " + task.toString() + "   "+ length);
        length
    }

    method immutable Integer computeCriticalPathGraphWithoutEdge(unique Set tasks,
                                                                 shared Task edgeFrom,
                                                                 shared Task edgeTo) {
        val it = tasks.iterator();
        var length = 0;
        
        while { it.hasNext() }{
            val curTask = it.next();
            
            // start from top nodes 
            if ( curTask.deps.size() == 0 ) {
                 val curLength = computeCriticalPathTaskWithoutEdge(curTask, edgeFrom, edgeTo);
                 //DEBUG(DEBUG_PRIO_LOW, "<TaskBuilderPass> critical path length from " + curTask.toString() + " is " + curLength);
                 length = max(length, curLength);
            };
        };
        //DEBUG(DEBUG_PRIO_LOW, "<TaskBuilderPass> critical path length for graph is without " + edgeFrom.toString() + " -> " + edgeTo.toString() + " is "  + length);
        length;
    }
    
    
    method immutable Integer computeMinimimPathNode(shared Task task) {
        var length = match (task.rdeps.size() == 0 ) {
             case True { task.getWeight() }
             case False { 1000000000 } 
        };
        
        val it = task.rdeps.iterator();
        while { it.hasNext() }{
            val curTask = it.next();
            
            val curLength = task.getWeight() + 1 + computeMinimimPathNode(curTask);
            length = min(length, curLength);
        };   
        
        length
    }
    
    method immutable Integer computeCriticalPathTask(shared Task task) {
        var length = 0;
        
        val it = task.rdeps.iterator();
        while { it.hasNext() }{
            val curTask = it.next();
            
            val curLength = 1 + computeCriticalPathTask(curTask);
            length = max(length, curLength);
        };   
        
        length = length + task.getWeight();
        length
    }
    
    
    
    method immutable Integer computeCriticalPathGraph(unique Set tasks) {
        val it = tasks.iterator();
        var length = 0;
        
        while { it.hasNext() }{
            val curTask = it.next();
            
            // start from top nodes 
            if ( curTask.deps.size() == 0 ) {
                 val curLength = computeCriticalPathTask(curTask);
                 //DEBUG(DEBUG_PRIO_LOW, "<TaskBuilderPass> critical path length from " + curTask.toString() + " is " + curLength);
                 length = max(length, curLength);
            };
        };
        //DEBUG(DEBUG_PRIO_LOW, "<TaskBuilderPass> critical path length for graph is " + length);
        length;
    }
    
    method unique Task mergeTasks(shared Task from, shared Task to) {
        val unique Task task = makeTask();
        
        task.deps.addAll(from.deps);
        task.deps.addAll(to.deps);
        task.deps.remove(from);
        
        task.rdeps.addAll(from.rdeps);
        task.rdeps.addAll(to.rdeps);
        task.rdeps.remove(to);
        
        // fix other tasks 
        val itDeps = task.deps.iterator();
        while {itDeps.hasNext()}{
            val curDep = itDeps.next();
            curDep.rdeps.remove(from);
            curDep.rdeps.remove(to);
            curDep.rdeps.add(task);
        };
        val itRDeps = task.rdeps.iterator();
        while {itRDeps.hasNext()}{
            val curRDep = itRDeps.next();
            curRDep.deps.remove(from);
            curRDep.deps.remove(to);
            curRDep.deps.add(task);
        };

        task.infos.addAll(from.infos);
        task.infos.addAll(to.infos);

        from.reset();
        to.reset();  
        
        DEBUG(DEBUG_PRIO_LOW, "<TaskBuilderPass> merged Tasks (" + from.getID() + "," + to.getID() + ") into " + task.getID());
        
        task              
    }
    
    method unique Set mergeVarDecls(unique Set tasks) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> mergeVarDecls");
        val result = java.util.HashSet.new();
        result.addAll(tasks);
        
        val it = tasks.iterator();
        while { it.hasNext() }{
            val curTask = it.next();
        
            if ( result.contains(curTask)) { // check if we already remove/merged the task
                match (curTask.infos.iterator().next().node) {
                    case ParsedVarDecl {
                        match (curTask.deps.size() == 1 ) {
                            case True {
                                val depTask = curTask.deps.iterator().next();
                                result.remove(curTask);
                                result.remove(depTask);
                                result.add(mergeTasks(depTask, curTask));
                            }
                            case False {
                                if ( curTask.deps.size() > 1 ) {
                                    ABORT("<TaskBuilderPass> var decl has more than one dependency " + curTask.deps.toString())
                                }
                            }
                        }
                    }
                    default {}
                }
            }
        };
        
        result
    }
    
    method immutable Boolean minimumPathDegressionForGraphWithoutEdge(unique Set tasks,
                                                                      shared Task from,
                                                                      shared Task to) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> minimumPathDegressionForGraphWithoutEdge ");
        
        var result = false;
        val it = tasks.iterator();
        
        while { it.hasNext() && result == false }{
            val curTask = it.next();
            
            if ( curTask.rdeps.size() > 0 && !(curTask == to)) {
                val minPathLength         = computeMinimimPathNode(curTask);
                val minPathLengthWithout  = computeMinimimPathNodeWithoutEdge(curTask, from, to);
        
        
                DEBUG(DEBUG_PRIO_LOW, "        MIN path from             " + curTask.toString() + " = " +  minPathLength );
                DEBUG(DEBUG_PRIO_LOW, "        MIN path from zeroed edge " + curTask.toString() + " = " +  minPathLengthWithout + "    " + from.toString() + " -> " + to.toString());    
                
                if ( minPathLength < minPathLengthWithout ) {
                    DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass>        LOCAL DEGRESSION");
                    result = true
                };
            }
        };
        
        result
    }
    
    method unique Set/*Task*/ computeTasks(immutable String path, shared Set infos) {
       DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> comupte tasks");
       
       var unique Set/*Task*/ tasks = this.createTaskGraph(infos);
       dumpTaskGraph(path, "TASK-STEP-0", tasks);     
       
       tasks = mergeVarDecls(tasks);
       dumpTaskGraph(path, "TASK-STEP-1", tasks);
    
       // TODO merge atomic blocks
    
       val clusteredTasks = clusterTasks(path, tasks);
    }
    
    val unique Map visitedEdges = java.util.IdentityHashMap.new();
    
    method void setEdgeVisited(shared Task from, shared Task to) {
        val values = match (this.visitedEdges.containsKey(from)) {
            case True { this.visitedEdges.get(from) } 
            case False {
                val newValues = java.util.HashSet.new();
                this.visitedEdges.put(from, newValues);
                newValues
            }
        };
        
        values.add(to);
    }
    
    method immutable Boolean edgeVisited(shared Task from, shared Task to) {
        match ( this.visitedEdges.containsKey(from) ) {
            case True { 
                val values = this.visitedEdges.get(from);
                values.contains(to)
            }
            case False { false } 
        }
    }
    
    method immutable Boolean findTransitiveEdge(shared Task target, shared Set tasks) {
        val it = tasks.iterator();
        
        var found = false;
        while { found == false && it.hasNext() }{
            val curTask = it.next();
            match ( curTask == target ) {
                case True {
                    found = true;
                }
                case False {
                    found = findTransitiveEdge(target, curTask.deps);
                }
            }
        };
        
        found
    }
    method immutable Boolean hasTransitiveEdge(shared Task from, shared Task to) {
         DEBUG(DEBUG_PRIO_LOW, "<TaskBuilderPass> hasTransitiveEdge " + from.toString() + " -> " + to.toString());
         
         val tasks = java.util.HashSet.new();
         tasks.addAll(to.deps);
         tasks.remove(from);
         
         findTransitiveEdge(from, tasks)
    }
    
    method immutable String taskListToString(unique List tasks) {
        val it = tasks.iterator();
        val sb = java.lang.StringBuilder.new();
        sb.append("[");
        while {it.hasNext()}{sb.append( "" + it.next().getWeight() + ",")};
        sb.deleteCharAt(sb.length() - 1);
        sb.append("]"); 
        sb.toString();   
    }
    
    // simple bubble sort 
    method unique List sortTaskList(unique List inputTasks) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> sortTaskList ");        
        
        val unique List tasks = java.util.ArrayList.new();
        tasks.addAll(inputTasks);
  
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> input: " + taskListToString(tasks));

        
        val length = tasks.size();
        var i = 0; 
        while { i < (length - 1) }{
            var j = i + 1;
            while { j < length }{
                if ( tasks.get(i).getWeight() > tasks.get(j).getWeight() ) {
                    // swap elements
                    val swap = tasks.get(i);
                    tasks.set(i, tasks.get(j));
                    tasks.set(j, swap);
                };
                j = j + 1;
            };
            i = i + 1;
        };
        
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> output: " + taskListToString(tasks));
        
        tasks
    }
    
    method unique Set/*Task*/ clusterTasks(immutable String path, shared Set tasksInput) {
       DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> clusterTasks");
       
       var unique List tasks = java.util.ArrayList.new();
       tasks.addAll(tasksInput);

       // sort tasks 
       tasks = sortTaskList(tasks);
       
       var immutable Boolean zeroed  = true;
       var immutable Integer step = 2;
       while { zeroed == true }{
           // iterarte through nodes 
           // check for every edge of a task merge does not increase the critical path length 
           DEBUG(DEBUG_PRIO_MEDIUM,"<TaskBuilderPass> ITERATION " + step );
           
           zeroed = false;
           val taskIt = tasks.iterator();
           while { zeroed == false && taskIt.hasNext() }{
               val curTask = taskIt.next();
               if ( curTask.rdeps.size() > 0 ){ 
                   val edgeIt = curTask.rdeps.iterator();
                   while { zeroed == false && edgeIt.hasNext() } {
                       val rdepTask = edgeIt.next();
                       
                       ifElse ( this.edgeVisited(curTask, rdepTask) == false && hasTransitiveEdge(curTask, rdepTask) == false ) {
                           val immutable Boolean merge = ifElse ( this.USE_SARKAR ) {
                               val cpLength = computeCriticalPathGraph(tasks);
                               val cpLenghtWithout = computeCriticalPathGraphWithoutEdge(tasks, curTask, rdepTask);
                               DEBUG(DEBUG_PRIO_LOW, "    CP from             " + curTask.toString() + " = " +  cpLength );
                               DEBUG(DEBUG_PRIO_LOW, "    CP from zeroed edge " + curTask.toString() + " = " +  cpLenghtWithout + "    " + curTask.toString() + " -> " + rdepTask.toString());    
               
                               val immutable Boolean localDecression = minimumPathDegressionForGraphWithoutEdge(tasks, curTask, rdepTask);
               
                               ifElse ( cpLenghtWithout <= cpLength ) {
                                   ifElse ( localDecression == false  ) {
                                       true
                                   }{
                                       // with next edge continue
                                       zeroed = true;
                                       setEdgeVisited(curTask, rdepTask);
                                       false 
                                   } 
                               }{
                                   false
                               }
                           }{
                               // use simple heuristic and merge nodes if at least one has no more than 1 dependency
                               ifElse ( curTask.rdeps.size() <= 1 && rdepTask.deps.size() <= 1 ) {  
                                   true
                               }{
                                   //merge nodes if both have weight 0
                                   ifElse ( curTask.getWeight() == 0 && rdepTask.getWeight() == 0 ) {
                                        true
                                   }{
                                       false
                                   } 
                               }
                           };
                           
                           if ( merge ) {
                               DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> merge " + curTask.toString() + " into " + rdepTask.toString());
                               
                               //merge tasks
                               val unique Task mergedTask = mergeTasks(curTask, rdepTask);
        
                               // remove rdepTask from tasks list
                               tasks.remove(rdepTask);
                               tasks.remove(curTask);
                               tasks.add(mergedTask);
                               
                               // sort task list 
                               tasks = sortTaskList(tasks);
                               
                               // abort iterations and retart 
                               zeroed = true;
                            
                               // dump task graph
                               dumpTaskGraph(path, "TASK-STEP-" + step, tasks);
                            
                               // increase step counter 
                               step = step + 1;                       
                           };
                       }{
                           DEBUG(DEBUG_PRIO_LOW, "<TaskBuilderPass> edge " + curTask.toString() + " -> " + rdepTask.toString()+ " already visited" );
                       }
                   }
               };
           };
       };
       
       tasks
    }
}