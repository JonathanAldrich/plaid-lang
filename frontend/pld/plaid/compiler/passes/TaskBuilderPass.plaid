package plaid.compiler.passes;

import plaid.ast.parsed.ParsedLeafVisitor;
import plaid.ast.util.makeStringFromQualifiedIdentifier;

import plaid.compiler.ERROR;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.Pass;

import plaid.compiler.*;
import plaid.compiler.typechecker.*;
import plaid.compiler.aeminium.*;
import plaid.compiler.permissions.*;

state TaskBuilderPass case of Pass = ParsedLeafVisitor with {
    var hasErrors = false;
    
    method immutable Boolean run(unique Job job) {
        match (job) {
          case UserJob {
              match (job.ast) {
                  case Some {
                    ifElse ( AEMINIUM_MODE()  ) {
                        DEBUG(DEBUG_PRIO_HIGH, "<TaskBuilderPass> started");
                    
                        job.ast.value.accept(this);
                
                        DEBUG(DEBUG_PRIO_HIGH, "<TaskBuilderPass> finished");
                        !this.hasErrors;
                    }{
                        true
                    }
                  }
                  default {
                      ERROR("<TaskBuilderPass> AST invalid");
                      false
                  }
              }
          }
          case CompilerJob {
              DEBUG(DEBUG_PRIO_HIGH, "<AEminiumPass> skip CompilerJob");
              true
          }
        }
    }
    
    override method void LOG(immutable String msg) {
        //DEBUG(DEBUG_PRIO_LOW, "<TaskBuilderPass> " + msg);
    }
    
    override method void visitParsedConcreteMethodDecl(immutable ParsedConcreteMethodDecl node) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> found Method Declaration '" + node.name.name + "'");
        
        ifElse ( typecheckingEnabled(node) ) {         
            // get dependency information for 
            val unique DependencyInformationCollector dic = new DependencyInformationCollector;
            node.accept(dic);
            val shared Set infos = dic.getNodes();
            DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass>     found " + infos.size() + " dependency information nodes");
            
            val unique LinkedList ops = makeLinkedList();
            ops.addLast( fn (depInfos) => {
                 val result = this.removeSplitAndJoinDependencies(depInfos);
                 dumpGraph(node, "DEL-SPLIT-JOIN");
                 result
            });
            /*
            ops.addLast( fn (depInfos) => {
                 val result = this.removeArguments(depInfos);
                 dumpGraph(node, "DEL-ARGS");
                 result
            });
            */
            ops.addLast( fn (depInfos) => {
                 val result = this.removeIds(depInfos);
                 dumpGraph(node, "DEL-ID");
                 result
            });
            ops.addLast( fn (depInfos) => {
                 val result = this.removeFieldRestores(depInfos);
                 dumpGraph(node, "DEL-FIELD-RESTORES");
                 result
            });
            ops.addLast( fn (depInfos) => {
                 val result = this.removeTransitiveDependencies(depInfos);
                 dumpGraph(node, "DEL-TRANS");
                 result
            });          
            // execute ops
            var unique Set nodes = infos; 
            ops.do( fn (op) => {
                nodes = op(nodes);
            });
            
            // dump final graph
            dumpGraph(node, "TASK-FINAL");
        }{
            DEBUG(DEBUG_PRIO_HIGH, "<TaskBuilderPass> SKIP method " + node.name.name);
        }
    }
    
    
    method immutable Boolean hasTransitiveDependency(shared DependencyInformation depInfo, shared Set deps) {
        val it = deps.iterator();
        var result = false;
        
        while { it.hasNext() && result == false }{
            val curInfo = it.next();
            ifElse ( curInfo == depInfo ) {
                result = true
            }{
                //printLine("check for trans dep " + curInfo.toString() );
                if ( result == false ) {
                    result = hasTransitiveDependency(depInfo, curInfo.deps)
                }
            };
        };
        
        result
    }
    
    method void removeTransitiveDependencies(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeTransitiveDependencies");
        
        val it = infos.iterator();
        while { it.hasNext() }{
            val curInfo = it.next(); 
            val depsIt =  curInfo.deps.iterator();
            
            // find deps that have transitive dependencies
            val removeSet = java.util.HashSet.new();
            while { depsIt.hasNext() }{
                val nextDep = depsIt.next();
                
                val depSet = java.util.HashSet.new();
                depSet.addAll(curInfo.deps);
                depSet.remove(nextDep);
                
                if ( hasTransitiveDependency(nextDep, depSet) ) {
                    DEBUG(DEBUG_PRIO_LOW, "<TaskBuilderPass> remove dependency " + curInfo.toString() + " -> " + nextDep.toString() );
                    removeSet.add(nextDep);
                };
            };
            
            // remove found edges
            if ( removeSet.size() > 0 ) {
                val removeIt = removeSet.iterator();
                
                while { removeIt.hasNext() }{
                    removeDependency(curInfo, removeIt.next());
                }
            };
        }; 
        
        infos
    }
    
    method void removeSplitAndJoinDependencies(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeSplitAndJoinDependencies");
        val result = java.util.HashSet.new();
        val it = infos.iterator();
        
        while { it.hasNext() }{
            val nextInfo = it.next();
            match (nextInfo) {
                case JoinInformation  { removeDependencyInformation(nextInfo) }
                case SplitInformation { removeDependencyInformation(nextInfo) }
                default{ result.add(nextInfo) }
            }
        };
        
        result
    }
    
    method void removeArguments(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeSplitAndJoinDependencies");
        val result = java.util.HashSet.new();
        val it = infos.iterator();
        
        while { it.hasNext() }{
            val nextInfo = it.next();
            match (nextInfo) {
                case ASTInformation {
                    match (nextInfo.node) {
                        case ParsedArg {
                            removeDependencyInformation(nextInfo) 
                        }
                        default { result.add(nextInfo) } 
                    }
                }
                default{ result.add(nextInfo) }
            }
        };
        
        result
    }
    
    method void removeIds(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeSplitAndJoinDependencies");
        val result = java.util.HashSet.new();
        val it = infos.iterator();
        
        while { it.hasNext() }{
            val nextInfo = it.next();
            match (nextInfo) {
                case ASTInformation {
                    match (nextInfo.node) {
                        case ParsedIdentifier {
                            removeDependencyInformation(nextInfo) 
                        }
                        default { result.add(nextInfo) } 
                    }
                }
                default{ result.add(nextInfo) }
            }
        };
        
        result
    }
    
    method void removeFieldRestores(shared Set infos) {
        DEBUG(DEBUG_PRIO_MEDIUM, "<TaskBuilderPass> removeFieldRestores");
        val result = java.util.HashSet.new();
        val it = infos.iterator();
        
        while { it.hasNext() }{
            val nextInfo = it.next();
            match (nextInfo) {
                case FieldRestoreInformation {
                    removeDependencyInformation(nextInfo) 
                }
                default{ result.add(nextInfo) }
            }
        };
        
        result
    }
}