package plaid.compiler.types;

import plaid.compiler.*;
import plaid.compiler.util.*;
import plaid.collections.makeLinkedList;

state AbstractDereferenceExpression case of AbstractExpression {
    val shared Symbol symbol;
    val unique LinkedList drefs = makeLinkedList();

    method immutable Structure getStructure() {
        var struct = symbol.getStructure();
        DEBUG(DEBUG_PRIO_LOW, "<AbstractDereferenceExpression> start with structure " + struct.toString());
        
        drefs.do( fn (right) => {
            match ( struct ) {
                case NominalStructure {
                    val rightSigOpt = struct.getMember(right);
                    match ( rightSigOpt ) {
                        case Some {
                            val sig = rightSigOpt.value;
                            match (sig) {
                                case DatagroupSignature {
                                    struct = DATAGROUPSTRUCT
                                }
                                case FieldSignature {
                                    struct = sig.getDeclaredType().structure
                                }
                                default { 
                                    ABORT("<AbstractDereferenceExpression> Unsupported signature " + sig.toString() )
                                }
                            }
                        }
                        case None {
                            ABORT("<AbstractDereferenceExpression> Cannot find '" + right + "' member in '" + struct.toString() + "'"); 
                        }
                    }
                }
                default { ABORT("<AbstractDereferenceExpression> Unsupported structure " + struct.toString() ) } 
            }
        });
        
        struct
    }

    method immutable Boolean ==(immutable AbstractExpression other) {
        DEBUG(DEBUG_PRIO_LOW, "<AbstractDereferenceExpression> " + this.toString() + " == " + other.toString() );
        match (other) {
            case AbstractDereferenceExpression {
                ifElse ( (this.symbol == other.symbol ) && (this.drefs.size() == other.drefs.size() )  )  {
                    var result = true;
                    
                    var i = 0;
                    while { i < this.drefs.size() }{
                        val s1 = this.drefs.get(i);
                        val s2 = other.drefs.get(i);
                        
                        result = result && (s1 == s2);
                        
                        i = i + 1;
                    };
                    
                    result;
                }{
                    false
                }
            }
            default { false }
        }
    }
    
    method immutable String toString() {
        val root = match ( this.symbol ) {
            case VariableSymbol { this.symbol.name }
            case StaticParameterSymbol { this.symbol.name }
            default { this.symbol.symbolType() }
        };
        
        match ( this.drefs.size() == 0 ) {
            case True {
                root
            }
            case False {
                root + "." + makeStringFromLinkedList(this.drefs, ".")  
            }
        }
    } 
}