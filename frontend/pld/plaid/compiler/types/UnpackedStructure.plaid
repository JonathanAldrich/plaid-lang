package plaid.compiler.types;

import java.util.Map;
import java.util.HashMap;
import plaid.compiler.*;
import plaid.compiler.symbol.*;

state UnpackedStructure case of ObjectStructure {
  val immutable NominalStructure unpackedStructure;
  val unique Map<immutable String,immutable UnpackedFieldSignature> unpackedFields = HashMap.new();
  
  method immutable Boolean ==(immutable Structure other)
                             [immutable UnpackedStructure this] 
  {
    match (other) {
      case UnpackedStructure {
        var immutable Boolean eq = 
          this.unpackedStructure == other.unpackedStructure &&
          this.unpackedFields.size() == other.unpackedFields.size();
        val unique Iterator iter = this.unpackedFields.keySet().iterator();
        while { eq && iter.hasNext() } {
          val immutable String fieldName = iter.next();
          match (other.unpackedFields.containsKey(fieldName)) {
            case True {
              eq = other.unpackedFields.get(fieldName) == 
                         this.unpackedFields.get(fieldName)    
            }
            case False { eq = false; }
          }     
        };
        eq
      }
      default { false }
    }
  }
  
  /**
   * Unpacked structures do not have least upper bounds
   */
  method unique Option<immutable Structure> leastUpperBound(immutable Structure other)[immutable UnpackedStructure this] {
    new None;
  }
  
  /**
   * unpacked structures cannot be used in place of any other structures
   * might want to relax this in the future
   */
  method immutable Boolean isSubStructureOf(immutable Structure other)[immutable UnpackedStructure this] {
    false
  }
  
  method immutable String toString()[immutable UnpackedStructure] {
    var immutable String ret = this.unpackedStructure.toString() + " UNPACKED Fields: ";
    val unique Iterator iter = this.unpackedFields.keySet().iterator();
    while {iter.hasNext() } {
       val immutable String fieldName = iter.next();
       ret = ret + this.unpackedFields.get(fieldName).toString() + ","
    };
    ret
  }
  
  /**
   *  returns None if the member is not defined for this type or the current signature representing
   *    the member if it is defined as a method or field.
   *  Preconditions:
   *    None
   *  Errors:
   *    None
   */
  method unique Option<immutable Signature> getMember(immutable String memberName) {
    DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure> searching for '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
    match (this.unpackedFields.containsKey(memberName)) {
      case True { 
        DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found unpacked field for '"+memberName+"'");
        makeSome(this.unpackedFields.get(memberName)) 
      }
      case False {
        val memberSymbolOpt = this.unpackedStructure.symbol.getMember(memberName);
        match (memberSymbolOpt) {
          case Some {
            match (memberSymbolOpt.value) {
              case FieldSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found FieldSymbol for '"+memberName+"'");
                match (this.unpackedFields.containsKey(memberSymbolOpt.value)) {
                  case True {
                     makeSome(this.unpackedFields.get(memberName))
                  }
                  case False {
                     makeSome(memberSymbolOpt.value.getSignature())
                  }
                }
              }
              case MethodSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found MethodSymbol for '"+memberName+"'");
                makeSome(memberSymbolOpt.value.getSignature())
              }
              default {
                DEBUG(DEBUG_PRIO_HIGH, "<UnpackedStructure>   found unrecognized symbol type for '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
                new None
              }
            }
          }
          case None {
            DEBUG(DEBUG_PRIO_HIGH, "<UnpackedStructure>   Cannot find member '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
            new None
          }
        }
      }
    }
  }
  
  /**
   *  If fieldName is in the list of unpacked field, then retType is returned to it, assuming the object
   *  IDs match. 
   *  If the field is not in the list of unpacked fields, then we know that one of the following holds:
   *    A) the field was reassigned, OR
   *    B) pulling the permission being returned did not unpack the field, OR
   *    C) the object changed to a different state which removed or packed the field
   *  Thus, the field may or may not still be present in the object and no action is needed in this case.  
   *  Preconditions:
   *    None
   *  Errors:
   *    None
   */
  method immutable Structure restoreToField(immutable String fieldName, immutable Type retType, immutable Integer objectID) {
    match (this.unpackedFields.containsKey(fieldName)) {
      case True {
        val immutable Signature newFieldSig = this.unpackedFields.get(fieldName).restore(retType,objectID);
        match (newFieldSig) {
          case FieldSignature {
            ifElse (this.unpackedFields.size() == 1) {
              this.unpackedStructure
            } {
              val unique Map<immutable String, immutable UnpackedFieldSignature> newMap = java.util.HashMap.new();
              newMap.putAll(this.unpackedFields);
              newMap.remove(fieldName);
              makeUnpackedStructureWithFieldMap(this.unpackedStructure, newMap)
            }
          }
          case UnpackedFieldSignature {//TODO: fix when match local variable scoping is fixed
            val unique Map<immutable String, immutable UnpackedFieldSignature> newMap2 = java.util.HashMap.new();
            newMap2.putAll(this.unpackedFields);
            newMap2.put(fieldName,newFieldSig);
            makeUnpackedStructureWithFieldMap(this.unpackedStructure, newMap2)
          }
        }
      }
      case False { this /* no op */ }
    }
  }
  
  /**
   * unpacking assumes that the calculation of the updated permissions has already occurred and that
   * it was legal.  An unpacked structure including the newly unpacked field is returned
   *  Preconditions:
   *    fieldName is a member of this type and is a field
   *  Errors:
   *    if precondition not met, then ABORT will be called
   */
  method immutable UnpackedStructure unpackField(immutable UnpackedFieldSignature newFieldSig) {
    val immutable String fieldName = newFieldSig.packedSignature.name;
    DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure> unpacking field '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
    
    match (this.unpackedFields.containsKey(fieldName)) {
      case True { //previously unpacked
        DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>  updating already unpacked field '"+fieldName+"'");
        val newUnpackedFields = java.util.HashMap.new();
        newUnpackedFields.putAll(this.unpackedFields);
        newUnpackedFields.put(fieldName,newFieldSig); //replaces existing unpackedsig
        makeUnpackedStructureWithFieldMap(this.unpackedStructure,newUnpackedFields)
      }
      case False { //not yet unpacked
        val memberSymbolOption = this.unpackedStructure.symbol.getMember(fieldName);
        match (memberSymbolOption) {
          case Some {
            match (memberSymbolOption.value) {
              case FieldSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found FieldSymbol for '"+fieldName+"'");
                val newUnpackedFields = java.util.HashMap.new();
                newUnpackedFields.putAll(this.unpackedFields);
                newUnpackedFields.put(fieldName,newFieldSig);
                makeUnpackedStructureWithFieldMap(this.unpackedStructure,newUnpackedFields)
              }
              case MethodSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found MethodSymbol for '"+fieldName+"'");
                ABORT("(Implementation Error) Found a method to unpack for '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'")
              }
              default {
                DEBUG(DEBUG_PRIO_HIGH, "<UnpackedStructure>   found unrecognized symbol type for '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
                ABORT("(Implementation Error) Found an unsupported member type to unpack for '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
              }
            }
          }
          case None {
            DEBUG(DEBUG_PRIO_HIGH, "<NominalStructure>   Cannot find member '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")' to unpack");
            ABORT("(Implementation Error) no member found to unpack for '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
          }
        }
      }
    }
  }
  
  /**
   *  if fieldName is packed, then assignment is a no-op
   *  if fieldName is an unpacked field, then that field is removed from the
   *    list of unpacked fields.  If this removes the last field from the list
   *    then the packed structure is returned, otherwise an unpacked structure with
   *    the remaining unpacked fields is returned
   *  Preconditions:
   *    fieldName is a member of this type and is a field
   *  Errors:
   *    if precondition not met, then ABORT will be called
   */
  method immutable ObjectStructure assignToField(immutable String fieldName) {
    DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure> assigning to field '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
    
    match (this.unpackedFields.containsKey(fieldName)) {
      case True {
        DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>  assigning to unpacked field '"+fieldName+"'");
        match (this.unpackedFields.get(fieldName).packedSignature.isVar) {
          case True {
            match (this.unpackedFields.size() == 1) {
              case True { this.unpackedStructure } //PACKED!!
              case False { //still some unpacked fields
                 val newUnpackedFields = java.util.HashMap.new();
                newUnpackedFields.putAll(this.unpackedFields);
                newUnpackedFields.remove(fieldName); //remove 
                makeUnpackedStructureWithFieldMap(this.unpackedStructure,newUnpackedFields)
              }
            }
          }
          case False { ABORT("(Implementation Error) assigning to val field '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'") } 
        }
      }
      case False {  //otherwise make sure that this assignment was well formed (TODO: this is potentially redundant)
        val memberSymbolOption = this.unpackedStructure.symbol.getMember(fieldName);
        match (memberSymbolOption) {
          case Some {
            match (memberSymbolOption.value) {
              case FieldSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found FieldSymbol for '"+fieldName+"'");
                match (memberSymbolOption.value.getSignature().isVar) {
                  case True { this }
                  case False { 
                    ABORT("(Implementation Error) assigning to val field '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'") 
                  } 
                }
              }
              case MethodSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found MethodSymbol for '"+fieldName+"'");
                ABORT("(Implementation Error) method found to assign to for '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'")
              }
              default {
                DEBUG(DEBUG_PRIO_HIGH, "<UnpackedStructure>   found unrecognized symbol type for '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
                ABORT("(Implementation Error) unsupported member type found to assign to for '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
              }
            }
          }
          case None {
            DEBUG(DEBUG_PRIO_HIGH, "<NominalStructure>   Cannot find member '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")' to assign to");
            ABORT("(Implementation Error) no member found to assign to for '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
          }
        }
      }
    }
  }
  
}