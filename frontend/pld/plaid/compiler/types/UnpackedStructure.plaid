package plaid.compiler.types;

import java.util.Map;
import java.util.HashMap;
import plaid.compiler.*;
import plaid.compiler.symbol.*;

state UnpackedStructure case of ObjectStructure {
  val immutable NominalStructure unpackedStructure;
  val unique Map<immutable String,immutable UnpackedFieldSignature> unpackedFields = HashMap.new();
  
  method immutable Boolean ==(immutable Structure other)
                             [immutable UnpackedStructure this] 
  {
    match (other) {
      case UnpackedStructure {
        var immutable Boolean eq = 
          this.unpackedStructure == other.unpackedStructure &&
          this.unpackedFields.size() == other.unpackedFields.size();
        val unique Iterator iter = this.unpackedFields.keySet().iterator();
        while { eq && iter.hasNext() } {
          val immutable String fieldName = iter.next();
          match (other.unpackedFields.containsKey(fieldName)) {
            case True {
              eq = other.unpackedFields.get(fieldName) == 
                         this.unpackedFields.get(fieldName)    
            }
            case False { eq = false; }
          }     
        };
        eq
      }
      default { false }
    }
  }
  
  /**
   * Unpacked structures do not have least upper bounds
   */
  method unique Option<immutable Structure> leastUpperBound(immutable Structure other)[immutable UnpackedStructure this] {
    new None;
  }
  
  /**
   * unpacked structures cannot be used in place of any other structures
   * might want to relax this in the future
   */
  method immutable Boolean isSubStructureOf(immutable Structure other)[immutable UnpackedStructure this] {
    false
  }
  
  method immutable String toString()[immutable UnpackedStructure] {
    var immutable String ret = this.unpackedStructure.toString() + "(";
    val unique Iterator iter = this.unpackedFields.keySet().iterator();
    while {iter.hasNext() } {
       val shared FieldSymbol fieldSym = iter.next();
       s = s + fieldSym.name + " : " + this.unpackedFields.get(fieldSym).toString()
    };
    s
  }
  
  method unique Option<immutable Signature> getMember(immutable String memberName) {
    DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure> searching for '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
    match (this.unpackedFields.containsKey(memberName)) {
      case True { 
        DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found unpacked field for '"+memberName+"'");
        makeSome(this.unpackedFields.get(memberName)) 
      }
      case False {
        val memberSymbolOpt = this.unpackedStructure.symbol.getMember(memberName);
        match (memberSymbolOpt) {
          case Some {
            match (memberSymbolOpt.value) {
              case FieldSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found FieldSymbol for '"+memberName+"'");
                match (this.unpackedFields.containsKey(memberSymbolOpt.value)) {
                  case True {
                     makeSome(this.unpackedFields.get(memberName))
                  }
                  case False {
                     makeSome(memberSymbolOpt.value.getSignature())
                  }
                }
              }
              case MethodSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found MethodSymbol for '"+memberName+"'");
                makeSome(memberSymbolOpt.value.getSignature())
              }
              default {
                DEBUG(DEBUG_PRIO_HIGH, "<UnpackedStructure>   found unrecognized symbol type for '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
                new None
                //ABORT("Unsupported member type ");
              }
            }
          }
          case None {
            DEBUG(DEBUG_PRIO_HIGH, "<UnpackedStructure>   Cannot find member '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
            new None
            //ABORT("Cannot find member '"+memberName+"' in '" + this.unpackedStructure.symbol.getFQN() + "'");
          }
        }
      }
    }
  }
  
  method immutable Structure restoreToField(immutable String fieldName, immutable Type retType, immutable Integer objectID) {
    match (this.unpackedFields.containsKey(fieldName)) {
      case True {
        val immutable Signature newFieldSig = this.unpackedFields.get(fieldName).restore(retType,objectID);
        match (newFieldSig) {
          case FieldSignature {
            ifElse (this.unpackedFields.size() == 1) {
              this.unpackedStructure
            } {
              val unique Map<immutable String, immutable UnpackedFieldSignature> newMap = java.util.HashMap.new();
              newMap.putAll(this.unpackedFields);
              newMap.remove(fieldName);
              makeUnpackedStructureWithFieldMap(this.unpackedStructure, newMap)
            }
          }
          case UnpackedFieldSignature {//TODO: fix when match local variable scoping is fixed
            val unique Map<immutable String, immutable UnpackedFieldSignature> newMap2 = java.util.HashMap.new();
            newMap2.putAll(this.unpackedFields);
            newMap2.put(fieldName,newFieldSig);
            makeUnpackedStructureWithFieldMap(this.unpackedStructure, newMap2)
          }
        }
      }
      case False { 
        val unique Option<immutable Symbol> memberSymbolOption = this.unpackedStructure.symbol.getMember(fieldName);
        match (memberSymbolOption) {
          case Some {
            match (memberSymbolOption.value) {
              case FieldSymbol { this } //restoring to a packed field has no effect
              default { ABORT("Permissions can only be restored to fields") }
            }
          }
          case None {
            ABORT("field not there"); 
          }
        }
      }
    }
  }
  
}