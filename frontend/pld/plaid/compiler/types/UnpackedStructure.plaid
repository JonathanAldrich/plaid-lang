package plaid.compiler.types;

import java.util.Map;
import java.util.HashMap;
import plaid.compiler.*;
import plaid.compiler.symbol.*;

state UnpackedStructure case of ObjectStructure {
  val immutable NominalStructure unpackedStructure;
  val unique Map<immutable String,immutable UnpackedFieldSignature> unpackedFields = HashMap.new();
  
  method immutable Boolean ==(immutable Structure other)
                             [immutable UnpackedStructure this] 
  {
    match (other) {
      case UnpackedStructure {
        var immutable Boolean eq = 
          this.unpackedStructure == other.unpackedStructure &&
          this.unpackedFields.size() == other.unpackedFields.size();
        val unique Iterator iter = this.unpackedFields.keySet().iterator();
        while { eq && iter.hasNext() } {
          val immutable String fieldName = iter.next();
          match (other.unpackedFields.containsKey(fieldName)) {
            case True {
              eq = other.unpackedFields.get(fieldName) == 
                         this.unpackedFields.get(fieldName)    
            }
            case False { eq = false; }
          }     
        };
        eq
      }
      default { false }
    }
  }
  
  /**
   * Unpacked structures do not have least upper bounds
   */
  method unique Option<immutable Structure> leastUpperBound(immutable Structure other)[immutable UnpackedStructure this] {
    new None;
  }
  
  /**
   * unpacked structures cannot be used in place of any other structures
   * might want to relax this in the future
   */
  method immutable Boolean isSubStructureOf(immutable Structure other)[immutable UnpackedStructure this] {
    false
  }
  
  method immutable String toString()[immutable UnpackedStructure] {
    var immutable String ret = this.unpackedStructure.toString() + " UNPACKED Fields: ";
    val unique Iterator iter = this.unpackedFields.keySet().iterator();
    while {iter.hasNext() } {
       val immutable String fieldName = iter.next();
       ret = ret + this.unpackedFields.get(fieldName).toString() + ","
    };
    ret
  }
  
  method unique Option<immutable Signature> getMember(immutable String memberName) {
    DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure> searching for '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
    match (this.unpackedFields.containsKey(memberName)) {
      case True { 
        DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found unpacked field for '"+memberName+"'");
        makeSome(this.unpackedFields.get(memberName)) 
      }
      case False {
        val memberSymbolOpt = this.unpackedStructure.symbol.getMember(memberName);
        match (memberSymbolOpt) {
          case Some {
            match (memberSymbolOpt.value) {
              case FieldSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found FieldSymbol for '"+memberName+"'");
                match (this.unpackedFields.containsKey(memberSymbolOpt.value)) {
                  case True {
                     makeSome(this.unpackedFields.get(memberName))
                  }
                  case False {
                     makeSome(memberSymbolOpt.value.getSignature())
                  }
                }
              }
              case MethodSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found MethodSymbol for '"+memberName+"'");
                makeSome(memberSymbolOpt.value.getSignature())
              }
              default {
                DEBUG(DEBUG_PRIO_HIGH, "<UnpackedStructure>   found unrecognized symbol type for '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
                new None
                //ABORT("Unsupported member type ");
              }
            }
          }
          case None {
            DEBUG(DEBUG_PRIO_HIGH, "<UnpackedStructure>   Cannot find member '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
            new None
            //ABORT("Cannot find member '"+memberName+"' in '" + this.unpackedStructure.symbol.getFQN() + "'");
          }
        }
      }
    }
  }
  
  method immutable Structure restoreToField(immutable String fieldName, immutable Type retType, immutable Integer objectID) {
    match (this.unpackedFields.containsKey(fieldName)) {
      case True {
        val immutable Signature newFieldSig = this.unpackedFields.get(fieldName).restore(retType,objectID);
        match (newFieldSig) {
          case FieldSignature {
            ifElse (this.unpackedFields.size() == 1) {
              this.unpackedStructure
            } {
              val unique Map<immutable String, immutable UnpackedFieldSignature> newMap = java.util.HashMap.new();
              newMap.putAll(this.unpackedFields);
              newMap.remove(fieldName);
              makeUnpackedStructureWithFieldMap(this.unpackedStructure, newMap)
            }
          }
          case UnpackedFieldSignature {//TODO: fix when match local variable scoping is fixed
            val unique Map<immutable String, immutable UnpackedFieldSignature> newMap2 = java.util.HashMap.new();
            newMap2.putAll(this.unpackedFields);
            newMap2.put(fieldName,newFieldSig);
            makeUnpackedStructureWithFieldMap(this.unpackedStructure, newMap2)
          }
        }
      }
      case False { 
        val unique Option<immutable Symbol> memberSymbolOption = this.unpackedStructure.symbol.getMember(fieldName);
        match (memberSymbolOption) {
          case Some {
            match (memberSymbolOption.value) {
              case FieldSymbol { this } //restoring to a packed field has no effect
              default { ABORT("Permissions can only be restored to fields") }
            }
          }
          case None {
            ABORT("field not there"); 
          }
        }
      }
    }
  }
  
  method immutable UnpackedStructure unpackField(immutable UnpackedFieldSignature newFieldSig) {
    val immutable String fieldName = newFieldSig.packedSignature.name;
    DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure> unpacking field '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
    
    match (this.unpackedFields.containsKey(fieldName)) {
      case True {
        DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>  updating already unpacked field '"+fieldName+"'");
        val newUnpackedFields = java.util.HashMap.new();
        newUnpackedFields.putAll(this.unpackedFields);
        newUnpackedFields.put(fieldName,newFieldSig); //replaces existing unpackedsig
        makeUnpackedStructureWithFieldMap(this.unpackedStructure,newUnpackedFields)
      }
      case False {
        val memberSymbolOption = this.unpackedStructure.symbol.getMember(fieldName);
        match (memberSymbolOption) {
          case Some {
            match (memberSymbolOption.value) {
              case FieldSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found FieldSymbol for '"+fieldName+"'");
                val newUnpackedFields = java.util.HashMap.new();
                newUnpackedFields.putAll(this.unpackedFields);
                newUnpackedFields.put(fieldName,newFieldSig);
                makeUnpackedStructureWithFieldMap(this.unpackedStructure,newUnpackedFields)
              }
              case MethodSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found MethodSymbol for '"+fieldName+"'");
                ABORT("Cannot unpack a method")
              }
              default {
                DEBUG(DEBUG_PRIO_HIGH, "<UnpackedStructure>   found unrecognized symbol type for '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
                ABORT("Attempting to unpack unsupported member type");
              }
            }
          }
          case None {
            DEBUG(DEBUG_PRIO_HIGH, "<NominalStructure>   Cannot find member '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")' to unpack");
            ABORT("Cannot find member '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")' to unpack");
          }
        }
      }
    }
  }
  
  method immutable ObjectStructure assignToField(immutable String fieldName) {
    DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure> assigning to field '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
    
    match (this.unpackedFields.containsKey(fieldName)) {
      case True {
        DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>  assigning to unpacked field '"+fieldName+"'");
        match (this.unpackedFields.get(fieldName).packedSignature.isVar) {
          case True {
            match (this.unpackedFields.size() == 1) {
              case True { this.unpackedStructure } //PACKED!!
              case False { //still some unpacked fields
                 val newUnpackedFields = java.util.HashMap.new();
                newUnpackedFields.putAll(this.unpackedFields);
                newUnpackedFields.remove(fieldName); //remove 
                makeUnpackedStructureWithFieldMap(this.unpackedStructure,newUnpackedFields)
              }
            }
          }
          case False { ABORT("Cannot assign to 'val' variable '" + fieldName + "'") } 
        }
      }
      case False {  //otherwise make sure that this assignment was well formed (TODO: this is potentially redundant)
        val memberSymbolOption = this.unpackedStructure.symbol.getMember(fieldName);
        match (memberSymbolOption) {
          case Some {
            match (memberSymbolOption.value) {
              case FieldSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found FieldSymbol for '"+fieldName+"'");
                match (memberSymbolOption.value.getSignature().isVar) {
                  case True { this }
                  case False { ABORT("Cannot assign to 'val' variable '" + fieldName + "'") } 
                }
              }
              case MethodSymbol {
                DEBUG(DEBUG_PRIO_MEDIUM, "<UnpackedStructure>   found MethodSymbol for '"+fieldName+"'");
                ABORT("Cannot assign to a method")
              }
              default {
                DEBUG(DEBUG_PRIO_HIGH, "<UnpackedStructure>   found unrecognized symbol type for '"+memberName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")'");
                ABORT("Attempting to assign to an unsupported member type");
              }
            }
          }
          case None {
            DEBUG(DEBUG_PRIO_HIGH, "<NominalStructure>   Cannot find member '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")' to assign to");
            ABORT("Cannot find member '"+fieldName+"' in 'UNPACKED(" + this.unpackedStructure.symbol.getFQN() + ")' to assign to");
          }
        }
      }
    }
  }
  
}