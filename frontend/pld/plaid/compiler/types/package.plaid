/**
 * Copyright (c) 2010 The Plaid Group (see AUTHORS file)
 * 
 * This file is part of Plaid Programming Language.
 *
 * Plaid Programming Language is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 *  Plaid Programming Language is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Plaid Programming Language.  If not, see <http://www.gnu.org/licenses/>.
 */

package plaid.compiler.types;

import plaid.compiler.permissions.DYNAMICP;
import plaid.compiler.permissions.NONEP;
import plaid.compiler.Type;

/***********************************************
 ***          Merge two Structures           ***
 ***********************************************/

/**
  * merges two structures when returning types
  * the resulting structure is the more specific of the two structures.  Both cannot have been changed because
  *    a change to one must necessarily downgrade the other type.
  *    Thus, we throw an internal exception if this occurs
  */
method immutable Structure mergeStructures(immutable Structure struct1, immutable Structure struct2) {
  ifElse (struct1.isSubStructureOf(struct2)) { 
    struct1
  } /*else*/ { 
    ifElse (struct2.isSubStructureOf(struct1))
      { struct2 }
      { ABORT("(implementation Error) rejoined structural types have both changed in incompatible way") } 
  };
}



/***********************************************
 ***               Type Constants            ***
 ***********************************************/

val immutable Type DYNAMICTYPE = new Type { val permission = DYNAMICP; val structure = DYNAMICSTRUCT; };
val immutable Type VOID = new Type { val permission = NONEP; val structure = TOPSTRUCT; };

/***********************************************
 ***   Factory method for creating a type    ***
 ***********************************************/

method immutable Type makeType(immutable Permission p, immutable Structure s) {
  new Type {
    val permission = p;
    val structure = s;
  } 
}

/***********************************************
 *** Factory methods for creating Structures ***
 ***********************************************/
 
val immutable DynamicStructure DYNAMICSTRUCT = new DynamicStructure;
val immutable DynamicStructure DYNSTRUCT = DYNAMICSTRUCT;
val immutable TopStructure TOPSTRUCT = new TopStructure;

method immutable LambdaStructure makeLambdaStructure(argTypes, metaArgs, environment) {
  new LambdaStructure {
    val argTypes = argTypes;
    val metaArgs = metaArgs;
    val environment = environment;
  }
}

method immutable NominalStructure makeNominalStructure(shared StateSymbol symbol, immutable Structure owner, immutable String name) {
  new NominalStructure {
    val symbol = symbol;
    val owner = owner;
    val name = name;
  }
}

method immutable UnpackedStructure makeUnpackedStructure(immutable NominalStructure unpackedStructure) {
  new UnpackedStructure {
    val unpackedStructure = unpackedStructure;
  }
}

method immutable UnpackedStructure makeUnpackedStructureWithFieldMap(immutable NominalStructure unpackedStructure, 
                                                                    /*immutable Map<immutable String,immutable FieldSignature>*/ unpackedFields) {
  new UnpackedStructure {
    val unpackedStructure = unpackedStructure;
    override val unpackedFields = unpackedFields;
  };
}

method immutable PackageStructure makePackageStructure(immutable Structure owner, immutable String name) {
  new PackageStructure {
    val owner = owner;
    val name = name;
  }
}

/***********************************************
 *** Factory methods for creating Signatures ***
 ***********************************************/
 
method immutable FieldSignature makeFieldSignature(immutable Boolean isVar, immutable Type fieldType, immutable String name) {
  new FieldSignature {
    val isVar = isVar;
    val fieldType = fieldType;
    val name = name;
  }
} 

method immutable UnpackedFieldSignature makeUnpackedFieldSignature(immutable FieldSignature packedSignature, immutable Integer objectID, immutable Type currentType) {
  new UnpackedFieldSignature {
    val packedSignature = packedSignature;
    val objectID = objectID;
    val currentType = currentType;
  }
} 

method immutable MethodSignature makeMethodSignature(immutable Type returnType, immutable String name, 
                                                     immutable LinkedList<immutable ArgSpec> arguments, 
                                                     immutable ArgSpec receiverSpec, 
                                                     immutable Map<immutable VariableSymbol, immutable ArgSpec> environment,
                                                     immutable LinkedList staticArgSpec) {
  new MethodSignature {
    val returnType = returnType;
    val name = name;
    val arguments = arguments;
    val receiverSpec = receiverSpec;
    val environment = environment;
    val staticArgsSpec = staticArgSpec;
  }
} 

/***********************************************
 *** Factory methods for creating ArgSpecs ***
 ***********************************************/
 
method immutable ArgSpec makeArgSpec(immutable Type input, immutable Type output) {
  new ArgSpec {
    val inputType = input;
    val outputType = output;
  }   
}