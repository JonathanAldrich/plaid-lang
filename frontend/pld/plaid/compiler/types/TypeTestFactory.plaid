/**
 * Copyright (c) 2010 The Plaid Group (see AUTHORS file)
 * 
 * This file is part of Plaid Programming Language.
 *
 * Plaid Programming Language is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 *  Plaid Programming Language is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Plaid Programming Language.  If not, see <http://www.gnu.org/licenses/>.
 */

package plaid.compiler.types;

import plaid.lang.testing.TestFactory;
import plaid.lang.testing.Test;
import plaid.compiler.*;
import plaid.compiler.symbol.*;
import plaid.compiler.permissions.*;
import plaid.ast.parsed.*;

import plaid.collections.makeLinkedList;

state TypeTestFactory case of TestFactory {
  
  method unique List<unique Test> createTests() {
    val tests = makeLinkedList();
    val test = fn(name,body) => { tests.add(mktest(name, body)) };
    var result = unit; //dummy result variable
    
    //setup values to use for tests
    val immutable String stateName1 = "state1";
    val immutable String stateName2 = "state2";
    val immutable String stateName3 = "state3";
    val immutable String stateName4 = "state4";
    
    val unique SymbolFactory symFac = new SymbolFactory;
    
    //Top symbol
    val immutable TopSymbol topSym = TOPSYM;
    
    //package symbols and structures
    val immutable PackageSymbol packSym1 = symFac.makePackageSymbol("pack1",topSym);
    val immutable PackageStructure packStruct1 = makePackageStructure(TOPSTRUCT, "pack1");
    
    //state Symbols
    val immutable ParsedIdentifier stateID1 = new ParsedIdentifier { val name = stateName1; };
    val immutable ParsedIdentifier stateID2 = new ParsedIdentifier { val name = stateName2; };
    val immutable ParsedIdentifier stateID3 = new ParsedIdentifier { val name = stateName3; };
    
    val immutable ParsedAbstractStateDecl stateAST1 = new ParsedStateDecl {
      val name = stateID1;
      val modifiers = makeLinkedList();
      val caseOf = new ParsedEmptyQualifiedIdentifier;
      val StaticArgsSpec = makeLinkedList();
      val metaCaseOfArgs = makeLinkedList();
    };
    
    val stateCaseOf2IDs = makeLinkedList();
    stateCaseOf2IDs.add(stateID1);
    val stateCaseOf2 = new ParsedQualifiedIdentifier { val identifiers = stateCaseOf2IDs; };
    val immutable ParsedAbstractStateDecl stateAST2 = new ParsedStateDecl {
      val name = new ParsedIdentifier { val name = stateName2; };
      val modifiers = makeLinkedList();
      val caseOf = stateCaseOf2;
      val StaticArgsSpec = makeLinkedList();
      val metaCaseOfArgs = makeLinkedList();
    };
    
    val stateCaseOf3IDs = makeLinkedList();
    stateCaseOf3IDs.add(stateID1);
    val stateCaseOf3 = new ParsedQualifiedIdentifier { val identifiers = stateCaseOf3IDs; };
    val immutable ParsedAbstractStateDecl stateAST3 = new ParsedStateDecl {
      val name = new ParsedIdentifier { val name = stateName3; };
      val modifiers = makeLinkedList();
      val caseOf = stateCaseOf3;
      val StaticArgsSpec = makeLinkedList();
      val metaCaseOfArgs = makeLinkedList();
    };
    
    val immutable ParsedAbstractStateDecl stateAST4 = new ParsedStateDecl {
      val name = new ParsedIdentifier { val name = stateName4; };
      val modifiers = makeLinkedList();
      val caseOf = new ParsedEmptyQualifiedIdentifier;
      val StaticArgsSpec = makeLinkedList();
      val metaCaseOfArgs = makeLinkedList();
    };
    
    val immutable StateSymbol stateSym1 = symFac.makeStateSymbol(stateName1, stateAST1, packSym1);
    val immutable StateSymbol stateSym2 = symFac.makeStateSymbol(stateName2, stateAST2, packSym1);
    val immutable StateSymbol stateSym3 = symFac.makeStateSymbol(stateName3, stateAST3, packSym1);
    val immutable StateSymbol stateSym4 = symFac.makeStateSymbol(stateName4, stateAST4, packSym1);
    val immutable Symbol owner = new Symbol { val name = "owner"; };
    

    
    val unique LinkedList QIlist1 = makeLinkedList();
    QIlist1.add(stateID1);
    val unique LinkedList QIlist2 = makeLinkedList();
    QIlist2.add(stateID2);
    val unique LinkedList QIlist3 = makeLinkedList();
    QIlist3.add(stateID3);
    
    val immutable ParsedQualifiedIdentifier stateQID1 = new ParsedQualifiedIdentifier { val identifiers = QIlist1; };
    val immutable ParsedQualifiedIdentifier stateQID2 = new ParsedQualifiedIdentifier { val identifiers = QIlist2; };
    val immutable ParsedQualifiedIdentifier stateQID3 = new ParsedQualifiedIdentifier { val identifiers = QIlist3; };
    
    val immutable ParsedNominalStructure nomStructAST1 = new ParsedNominalStructure { val stateQi = stateQID1; val metaTypes = makeLinkedList(); };
    val immutable ParsedNominalStructure nomStructAST2 = new ParsedNominalStructure { val stateQi = stateQID2; val metaTypes = makeLinkedList(); };
    val immutable ParsedNominalStructure nomStructAST3 = new ParsedNominalStructure { val stateQi = stateQID3; val metaTypes = makeLinkedList(); };
    
    addSymbolForAST(stateCaseOf2,stateSym1);
    addSymbolForAST(stateCaseOf3,stateSym1);
    addSymbolForAST(stateQID1,stateSym1);
    addSymbolForAST(stateQID2,stateSym2);
    addSymbolForAST(stateQID3,stateSym3);
    
    val immutable ParsedConcreteType nomTypeAST1 = new ParsedConcreteType {
      val permission = new ParsedUniquePermission;
      val structure = nomStruct1;
    };
    val immutable ParsedConcreteType nomTypeAST1alt = new ParsedConcreteType {
      val permission = new ParsedNonePermission;
      val structure = nomStruct1;
    };
    val immutable ParsedConcreteType nomTypeAST2 = new ParsedConcreteType {
      val permission = new ParsedEmptyPermission;
      val structure = nomStruct2;
    };
     val immutable ParsedConcreteType nomTypeAST3 = new ParsedConcreteType {
      val permission = new ParsedEmptyPermission;
      val structure = nomStruct3;
    };
    
    val immutable NominalStructure nomStruct1 = makeNominalStructure(stateSym1,packStruct1,stateName1);
    val immutable NominalStructure nomStruct2 = makeNominalStructure(stateSym2,packStruct1,stateName2);
    val immutable NominalStructure nomStruct3 = makeNominalStructure(stateSym3,packStruct1,stateName3);
    val immutable NominalStructure nomStruct4 = makeNominalStructure(stateSym4,packStruct1,stateName4);
    
    val immutable String fieldName1 = "field1";
    val immutable String fieldName2 = "field2";
    val immutable ParsedASTNode fieldAST1 =new ParsedFieldDecl {
      val name = new ParsedIdentifier { val name = fieldName1; };
      val modifiers = makeLinkedList();
      val specifier = new ParsedValSpecifier;
      val fieldType = nomTypeAST1;
    };
    val immutable ParsedASTNode fieldAST1alt =new ParsedFieldDecl {
      val name = new ParsedIdentifier { val name = fieldName1; };
      val modifiers = makeLinkedList();
      val specifier = new ParsedVarSpecifier;
      val fieldType = nomTypeAST1alt;
    };
    val immutable ParsedASTNode fieldAST2 =new ParsedFieldDecl {
      val name = new ParsedIdentifier { val name = fieldName2; };
      val modifiers = makeLinkedList();
      val specifier = new ParsedValSpecifier;
      val fieldType = nomTypeAST2;
    };
    
    val immutable FieldSignature fieldSig1 = makeFieldSignature(true,DYNAMICTYPE,fieldName1);
    val immutable FieldSignature fieldSig1alt = makeFieldSignature(false,DYNAMICTYPE,fieldName1);
    val immutable FieldSignature fieldSig2 = makeFieldSignature(true,DYNAMICTYPE,fieldName2);
    val immutable FieldSignature fieldSig2alt = makeFieldSignature(true,VOID,fieldName2);
    
    
    val immutable Symbol fieldSym1 = new Symbol { val name = fieldName1; };
    val immutable Symbol fieldSym2 = new Symbol { val name = fieldName2; };
    
    val unique Map fieldMap1 = java.util.HashMap.new();
    fieldMap1.put(fieldName1,fieldSig1);
    val unique Map fieldMap1alt = java.util.HashMap.new();
    fieldMap1alt.put(fieldName1,fieldSig1alt);
    val unique Map fieldMap2 = java.util.HashMap.new();
    fieldMap2.put(fieldName1,fieldSig1);
    fieldMap2.put(fieldName2,fieldSig2);
    val unique Map fieldMap3 = java.util.HashMap.new();
    fieldMap3.put(fieldName1,fieldSig1);
    
    val immutable UnpackedStructure unpackedStruct1 = makeUnpackedStructureWithFieldMap(nomStruct1,fieldMap1);
    val immutable UnpackedStructure unpackedStruct1alt = makeUnpackedStructureWithFieldMap(nomStruct1,fieldMap1alt);
    val immutable UnpackedStructure unpackedStruct1altalt = makeUnpackedStructureWithFieldMap(nomStruct1,fieldMap2);
    val immutable UnpackedStructure unpackedStruct2 = makeUnpackedStructureWithFieldMap(nomStruct2,fieldMap3);
    
    /********************** Top Structure *************************/
    
    test("TopStructure equality", fn(ctx) => {
      
      ctx.assertTrue(TOPSTRUCT == new TopStructure);
      ctx.assertFalse(TOPSTRUCT == DYNAMICSTRUCT);
      ctx.assertFalse(TOPSTRUCT == nomStruct1);
      ctx.assertFalse(TOPSTRUCT == unpackedStruct1);
    }); 
    
    test("TopStructure isSubStructureOf", fn(ctx) => {
      ctx.assertFalse(TOPSTRUCT.isSubStructureOf(nomStruct2));
      ctx.assertTrue(TOPSTRUCT.isSubStructureOf(new TopStructure));
      ctx.assertFalse(TOPSTRUCT.isSubStructureOf(DYNAMICSTRUCT));
      ctx.assertFalse(TOPSTRUCT.isSubStructureOf(unpackedStruct1));
    });
    
    test("TopStructure leastUpperBound", fn(ctx) => {
      result = TOPSTRUCT.leastUpperBound(nomStruct2); 
      result = match (result) {
        case Some { result.value == TOPSTRUCT }
        case None { false }
      };
      ctx.assertTrue(result);
      
      result = TOPSTRUCT.leastUpperBound(new TopStructure); 
      result = match (result) {
        case Some { result.value == TOPSTRUCT }
        case None { false }
      };
      ctx.assertTrue(result);
      
      result = TOPSTRUCT.leastUpperBound(DYNAMICSTRUCT); 
      result = match (result) {
        case Some { false }
        case None { true }
      };
      ctx.assertTrue(result);
      
      result = TOPSTRUCT.leastUpperBound(unpackedStruct1); 
      result = match (result) {
        case Some { false }
        case None { true }
      };
      ctx.assertTrue(result);
    });

    /********************** Dynamic Structure *************************/
    
    test("DynamicStructure equality", fn(ctx) => {
      
      ctx.assertTrue(DYNAMICSTRUCT == new DynamicStructure);
      ctx.assertFalse(DYNAMICSTRUCT == TOPSTRUCT);
      ctx.assertFalse(DYNAMICSTRUCT == nomStruct1);
      ctx.assertFalse(DYNAMICSTRUCT == unpackedStruct1);
    }); 
    
    test("DynamicStructure isSubStructureOf", fn(ctx) => {
      ctx.assertFalse(DYNAMICSTRUCT.isSubStructureOf(nomStruct2));
      ctx.assertFalse(DYNAMICSTRUCT.isSubStructureOf(TOPSTRUCT));
      ctx.assertFalse(DYNAMICSTRUCT.isSubStructureOf(new DynamicStructure));
      ctx.assertFalse(DYNAMICSTRUCT.isSubStructureOf(unpackedStruct1));
    });

    test("DynamicStructure leastUpperBound", fn(ctx) => {
      ctx.assertTrue(match (DYNAMICSTRUCT.leastUpperBound(nomStruct2)) { case Some { false } case None { true } });
      ctx.assertTrue(match (DYNAMICSTRUCT.leastUpperBound(TOPSTRUCT)) { case Some { false } case None { true } });
      result = DYNAMICSTRUCT.leastUpperBound(new DynamicStructure);
      ctx.assertTrue(match (result) { case Some { result.value == DYNAMICSTRUCT } case None { false } });
      ctx.assertTrue(match (DYNAMICSTRUCT.leastUpperBound(unpackedStruct1)) { case Some { false } case None { true } });
    });
    
    /********************** Nominal Structure *************************/
    test("NominalStructure equality", fn(ctx) => {
      
      ctx.assertFalse(nomStruct1 == DYNAMICSTRUCT);
      ctx.assertFalse(nomStruct1 == TOPSTRUCT);
      ctx.assertTrue(nomStruct1 == nomStruct1);
      ctx.assertFalse(nomStruct1 == nomStruct2);
      ctx.assertFalse(nomStruct1 == unpackedStruct1);
    });   

    test("NominalStructure isSubStructureOf", fn(ctx) => {
      ctx.assertFalse(nomStruct1.isSubStructureOf(nomStruct2));
      ctx.assertTrue(nomStruct2.isSubStructureOf(nomStruct1));
      ctx.assertTrue(nomStruct1.isSubStructureOf(TOPSTRUCT));
      ctx.assertFalse(nomStruct1.isSubStructureOf(DYNAMICSTRUCT));
      ctx.assertFalse(nomStruct1.isSubStructureOf(unpackedStruct1));
    }); 
    
    test("NominalStructure leastUpperBound", fn(ctx) => {
      result = nomStruct1.leastUpperBound(nomStruct2); 
      result = match (result) {
        case Some { result.value == nomStruct1 }
        case None { false }
      };
      ctx.assertTrue(result);
      
      result = nomStruct2.leastUpperBound(nomStruct1); 
      result = match (result) {
        case Some { result.value == nomStruct1 }
        case None { false }
      };
      ctx.assertTrue(result);
      
      result = nomStruct1.leastUpperBound(TOPSTRUCT); 
      result = match (result) {
        case Some { result.value == TOPSTRUCT }
        case None { false }
      };
      ctx.assertTrue(result);
      
      result = nomStruct2.leastUpperBound(nomStruct3); 
      result = match (result) {
        case Some { result.value == nomStruct1 }
        case None { false }
      };
      ctx.assertTrue(result);
      
      result = nomStruct2.leastUpperBound(nomStruct4); 
      result = match (result) {
        case Some { result.value == TOPSTRUCT }
        case None { false }
      };
      ctx.assertTrue(result);
            
      result = nomStruct2.leastUpperBound(DYNAMICSTRUCT); 
      result = match (result) {
        case Some { false }
        case None { true }
      };
      ctx.assertTrue(result);
      
      result = nomStruct2.leastUpperBound(unpackedStruct1); 
      result = match (result) {
        case Some { false }
        case None { true }
      };
      ctx.assertTrue(result);
    }); 
    
    test("NominalStructure getMember", fn(ctx) => {
      ctx.assertFalse(nomStruct1.isSubStructureOf(nomStruct2));
      ctx.assertTrue(nomStruct2.isSubStructureOf(nomStruct1));
      ctx.assertTrue(nomStruct1.isSubStructureOf(TOPSTRUCT));
      ctx.assertFalse(nomStruct1.isSubStructureOf(DYNAMICSTRUCT));
      ctx.assertFalse(nomStruct1.isSubStructureOf(unpackedStruct1));
    }); 
    
    /********************** Unpacked Structure *************************/
    test("UnpackedStructure equality", fn(ctx) => {
      
      ctx.assertFalse(unpackedStruct1 == DYNAMICSTRUCT);
      ctx.assertFalse(unpackedStruct1 == TOPSTRUCT);
      ctx.assertFalse(unpackedStruct1 == nomStruct1);
      ctx.assertTrue(unpackedStruct1 == unpackedStruct1);
      ctx.assertFalse(unpackedStruct1alt == unpackedStruct1);
      ctx.assertFalse(unpackedStruct1altalt == unpackedStruct1);
      ctx.assertFalse(unpackedStruct2 == unpackedStruct1);
    }); 
    
    test("UnpackedStructure isSubStructureOf", fn(ctx) => {
      ctx.assertFalse(unpackedStruct1.isSubStructureOf(nomStruct2));
      ctx.assertFalse(unpackedStruct1.isSubStructureOf(TOPSTRUCT));
      ctx.assertFalse(unpackedStruct1.isSubStructureOf(DYNAMICSTRUCT));
      ctx.assertFalse(unpackedStruct1.isSubStructureOf(unpackedStruct1));
    }); 
    
    test("UnpackedStructure leastUpperBound", fn(ctx) => {
      ctx.assertTrue(match (unpackedStruct1.leastUpperBound(nomStruct2)) { case Some { false } case None { true } });
      ctx.assertTrue(match (unpackedStruct1.leastUpperBound(TOPSTRUCT)) { case Some { false } case None { true } });
      ctx.assertTrue(match (unpackedStruct1.leastUpperBound(new DynamicStructure)) { case Some { false } case None { true } });
      ctx.assertTrue(match (unpackedStruct1.leastUpperBound(unpackedStruct1)) { case Some { false } case None { true } });
    });
    
    /********************** Field Signatures *************************/
    test("Field Signature equality", fn(ctx) => {
      
      ctx.assertTrue(fieldSig1 == makeFieldSignature(true,DYNAMICTYPE,fieldName1));
      ctx.assertFalse(fieldSig1 == fieldSig1alt);
      ctx.assertFalse(fieldSig1 == fieldSig2);
      ctx.assertFalse(fieldSig2 == fieldSig2alt);
    }); 
    
    test("Field Signature getFieldType", fn(ctx) => {
      ctx.assertTrue(fieldSig1.getFieldType() == DYNAMICTYPE);
    }); 
    
    /********************** Method Signatures *************************/
    val immutable String methodName1 = "method1";
    val immutable String methodName2 = "method2";
    
    val immutable Type returnType1 = VOID;
    val immutable Type returnType2 = DYNAMICTYPE;
    
    val immutable ArgSpec receiverSpec1 = makeArgSpec(VOID,VOID);
    val immutable ArgSpec receiverSpec2 = makeArgSpec(DYNAMICTYPE,DYNAMICTYPE);
    
    val immutable VariableSymbol argSymbol1 = 
      symFac.makeVariableSymbol("a1", new ParsedEmptyExpr);
    val immutable VariableSymbol argSymbol1alt = 
      symFac.makeVariableSymbol("a1alt", new ParsedEmptyExpr);
    val immutable VariableSymbol argSymbol3 = 
      symFac.makeVariableSymbol("a3", new ParsedEmptyExpr);
    
    
    val unique LinkedList<immutable ArgSpec> args1 = makeLinkedList();
    args1.add(makePair(argSymbol1,makeArgSpec(VOID,VOID)));
    val unique LinkedList<immutable ArgSpec> args1alt = makeLinkedList();
    args1alt.add(makePair(argSymbol1alt,makeArgSpec(VOID,VOID)));
    val unique LinkedList<immutable ArgSpec> args2 = makeLinkedList();
    val unique LinkedList<immutable ArgSpec> args3 = makeLinkedList();
    args3.add(makePair(argSymbol3,makeArgSpec(DYNAMICTYPE,DYNAMICTYPE)));
    
    val immutable VariableSymbol envSymbol1 = 
      symFac.makeVariableSymbol("v1", new ParsedEmptyExpr);
    val immutable VariableSymbol envSymbol1alt = 
      symFac.makeVariableSymbol("v1", new ParsedEmptyExpr);
    val immutable VariableSymbol envSymbol2 = 
      symFac.makeVariableSymbol("v2", new ParsedEmptyExpr);
    
    val unique Map<immutable Symbol,immutable ArgSpec> env1 = java.util.HashMap.new();
    env1.put(envSymbol1,makeArgSpec(VOID,VOID));
    val unique Map<immutable Symbol,immutable ArgSpec> env1alt = java.util.HashMap.new();
    env1alt.put(envSymbol1alt,makeArgSpec(VOID,VOID));
    val unique Map<immutable Symbol,immutable ArgSpec> env2 = java.util.HashMap.new();
    val unique Map<immutable Symbol,immutable ArgSpec> env3 = java.util.HashMap.new();
    env3.put(envSymbol1,makeArgSpec(DYNAMICTYPE,DYNAMICTYPE));
    val unique Map<immutable Symbol,immutable ArgSpec> env4 = java.util.HashMap.new();
    env4.put(envSymbol2,makeArgSpec(DYNAMICTYPE,DYNAMICTYPE));
    
    //TODO replace integers with static args later - not sure what these
    //should be now, but want to test equality method
    //types aren't checked now
    val unique LinkedList<immutable ArgSpec> staticArgs1 = makeLinkedList();
    staticArgs1.add(5);
    val unique LinkedList<immutable ArgSpec> staticArgs2 = makeLinkedList();
    val unique LinkedList<immutable ArgSpec> staticArgs3 = makeLinkedList();
    staticArgs3.add(6);

    val immutable MethodSignature mSig = 
      makeMethodSignature(returnType1,methodName1,args1,receiverSpec1,env1,staticArgs1);
    val immutable MethodSignature mSigEQ = 
      makeMethodSignature(returnType1,methodName1,args1alt,receiverSpec1,env1alt,staticArgs1);    
    val immutable MethodSignature mSigRetType = 
      makeMethodSignature(returnType2,methodName1,args1,receiverSpec1,env1,staticArgs1);
    val immutable MethodSignature mSigName = 
      makeMethodSignature(returnType1,methodName2,args1,receiverSpec1,env1,staticArgs1);
    val immutable MethodSignature mSigArgs2 = 
      makeMethodSignature(returnType1,methodName1,args2,receiverSpec1,env1,staticArgs1);
    val immutable MethodSignature mSigArgs3 = 
      makeMethodSignature(returnType1,methodName1,args3,receiverSpec1,env1,staticArgs1);
    val immutable MethodSignature mSigReceiverSpec = 
      makeMethodSignature(returnType1,methodName1,args1,receiverSpec2,env1,staticArgs1);
    val immutable MethodSignature mSigEnv2 = 
      makeMethodSignature(returnType1,methodName2,args1,receiverSpec1,env2,staticArgs1);
    val immutable MethodSignature mSigEnv3 = 
      makeMethodSignature(returnType1,methodName2,args1,receiverSpec1,env3,staticArgs1);
    val immutable MethodSignature mSigEnv4 = 
      makeMethodSignature(returnType1,methodName2,args1,receiverSpec1,env4,staticArgs1);
    val immutable MethodSignature mSigSA2 = 
      makeMethodSignature(returnType1,methodName2,args1,receiverSpec1,env1,staticArgs2);
    val immutable MethodSignature mSigSA3 = 
      makeMethodSignature(returnType1,methodName2,args1,receiverSpec1,env1,staticArgs3);
    
    test("Method Signature equality", fn(ctx) => {
      
      ctx.assertTrue(mSig == mSigEQ);
      ctx.assertFalse(mSig == mSigRetType);
      ctx.assertFalse(mSig == mSigName);
      ctx.assertFalse(mSig == mSigArgs2);
      ctx.assertFalse(mSig == mSigArgs3);
      ctx.assertFalse(mSig == mSigReceiverSpec);
      ctx.assertFalse(mSig == mSigEnv2);
      ctx.assertFalse(mSig == mSigEnv3);
      ctx.assertFalse(mSig == mSigEnv4);
      ctx.assertFalse(mSig == mSigSA2);
      ctx.assertFalse(mSig == mSigSA3);
    }); 
    
    test("Method Signature toString", fn(ctx) => {
      
      ctx.assertTrue(mSig.toString().equals(
        "method none TOP method1(none TOP >> none TOP a1)[none TOP >> none TOP, none TOP >> none TOP v1];"
      ));
    });
    
    /********************** Types *************************/
    
    test("Type equality", fn(ctx) => {
      
      ctx.assertTrue(makeType(UNIQUE,nomStruct1) == makeType(UNIQUE,nomStruct1));
      ctx.assertFalse(makeType(UNIQUE,nomStruct1) == makeType(UNIQUE,nomStruct2));
      ctx.assertFalse(makeType(UNIQUE,nomStruct1) == makeType(IMMUTABLE,nomStruct1));
      ctx.assertFalse(VOID == makeType(IMMUTABLE,nomStruct1));
      ctx.assertTrue(VOID == makeType(new NonePermission,new TopStructure));
      ctx.assertFalse(DYNAMICTYPE == VOID);
      ctx.assertTrue(DYNAMICTYPE == makeType(new DynamicPermission,new DynamicStructure));
    }); 
    
    test("Type downgrade", fn(ctx) => {
      
      ctx.assertTrue(makeType(UNIQUE,nomStruct1).downgrade() == makeType(UNIQUE,nomStruct1));
      ctx.assertTrue(makeType(IMMUTABLE,nomStruct1).downgrade() == makeType(IMMUTABLE,nomStruct1));
      ctx.assertTrue(makeType(LOCALIMMUTABLE,nomStruct1).downgrade() == makeType(LOCALIMMUTABLE,nomStruct1));
      ctx.assertTrue(makeType(SHARED,nomStruct1).downgrade() == makeType(SHARED,TOPSTRUCT));
      ctx.assertTrue(makeType(LOCALSHARED,nomStruct1).downgrade() == makeType(LOCALSHARED,TOPSTRUCT));
      ctx.assertTrue(VOID.downgrade() == makeType(NONEP,TOPSTRUCT));
      ctx.assertTrue(DYNAMICTYPE.downgrade() == makeType(new DynamicPermission,new DynamicStructure));
    });
    
    test("Type leastUpperBound", fn(ctx) => {
      result = makeType(IMMUTABLE,nomStruct1).leastUpperBound(makeType(SHARED,nomStruct2)); 
      result = match (result) {
        case Some { result.value == makeType(UNIQUE,nomStruct1) }
        case None { false }
      };
      ctx.assertTrue(result);
            
      result = makeType(IMMUTABLE,TOPSTRUCT).leastUpperBound(makeType(LOCALIMMUTABLE,unpackedStruct1)); 
      result = match (result) {
        case Some { false }
        case None { true }
      };
      ctx.assertTrue(result);
      
      result = DYNAMICTYPE.leastUpperBound(makeType(DYNAMICP,DYNAMICSTRUCT)); 
      result = match (result) {
        case Some { result.value == DYNAMICTYPE }
        case None { false }
      };
      ctx.assertTrue(result);
      
    }); 
    
    test("Type isSubTypeOf", fn(ctx) => {
      ctx.assertFalse(makeType(IMMUTABLE,TOPSTRUCT).isSubTypeOf(makeType(SHARED,TOPSTRUCT)));
      ctx.assertFalse(makeType(IMMUTABLE,TOPSTRUCT).isSubTypeOf(makeType(LOCALIMMUTABLE,unpackedStruct1)));
      ctx.assertTrue(makeType(UNIQUE,nomStruct2).isSubTypeOf(makeType(IMMUTABLE,nomStruct1)));
    }); 
    
    test("Type splitType", fn(ctx) => {
      result = makeType(IMMUTABLE,TOPSTRUCT).splitType(makeType(SHARED,TOPSTRUCT));
      ctx.assertTrue(match (result) { case Some { false } case None { true } });
      result = makeType(IMMUTABLE,TOPSTRUCT).splitType(makeType(LOCALIMMUTABLE,unpackedStruct1));
      ctx.assertTrue(match (result) { case Some { false } case None { true } });
      result = makeType(UNIQUE,nomStruct2).splitType(makeType(IMMUTABLE,nomStruct1));
      ctx.assertTrue(match (result) { case Some { result.value == makeType(IMMUTABLE,nomStruct2) } case None { false } });
    }); 
            
    /********************** ArgSpecs *************************/
    test("ArgSpec equality", fn(ctx) => {
      ctx.assertTrue(makeArgSpec(DYNAMICTYPE,VOID) == makeArgSpec(makeType(DYNAMICP,DYNAMICSTRUCT),makeType(NONEP,TOPSTRUCT)));
      ctx.assertFalse(makeArgSpec(DYNAMICTYPE,VOID) == makeArgSpec(DYNAMICTYPE,DYNAMICTYPE));
      ctx.assertFalse(makeArgSpec(DYNAMICTYPE,VOID) == makeArgSpec(VOID,VOID));
    }); 
    
    tests
  }
  
  
}