package plaid.compiler.types;

import plaid.compiler.Type;
import plaid.compiler.types.*;
import plaid.compiler.Signature;

state UnpackedFieldSignature case of Signature {
  val immutable FieldSignature packedSignature;
  val immutable Integer objectID;
  val immutable Type currentType;
  
  method immutable Boolean ==(immutable Signature other)[immutable UnpackedFieldSignature this] {
      match (other) {
        case UnpackedFieldSignature { 
          this.packedSignature == other.packedSignature &&
          this.objectID == other.objectID &&
          this.currentType == other.currentType
        }
        default { false } 
      }
  }
  
  method immutable Type getDeclaredType() {
    this.packedSignature.getDeclaredType()
  }
  
  method immutable Type getCurrentType() {
    this.currentType
  }
    
  method immutable String toString()[immutable FieldSignature this] {
    "UNPACKED(" + this.packedSignature.toString() + " ," + this.objectID + ") : " + this.currentType.toString() + ";";
  }
  
  /**
   * restores the given type to the unpacked field, returning the new state (packed or unpacked) of the field
   * the resulting permission is the incoming permission restored to the current permission
   * the resulting structure is the more specific of the two structures.  Both cannot have been changed because
   *    a change to one must necessarily downgrade the other type.
   * if the restored type is a subtype of the declared field type, then we return a packed field
   *    otherwise the field remains unpacked at the restored type
   */
  method immutable Signature restore(immutable Type retType, immutable Integer restoreObjectID) {
    match (this.objectID == restoreObjectID) {
      case True {
        val unique Option<immutable Permission> restoredPermOption = this.currentType.permission.returnPerm(retType.permission);
        match (restoredPermOption) {
          case Some {
            val immutable Structure restoredStructure = 
              ifElse (retType.structure.isSubStructureOf(this.currentType.structure)) { 
                retType.structure 
              } /*else*/ { 
                ifElse (this.currentType.structure.isSubStructureOf(retType.structure))
                  { this.currentType.structure }
                  { ABORT("currentType and restored type have inconsistent structures") } 
              };
            val immutable Type restoredType = makeType(restoredPermOption.value, restoredStructure);
            match (restoredType.isSubTypeOf(this.packedSignature.fieldType)) {
              case True { this.packedSignature }
              case False { makeUnpackedFieldSignature(this.packedSignature, this.objectID, restoredType) }
            }
          }
          case None { ABORT("could not return " + perm.toString() + " to " + this.currentType.permission ) }
        }
      }
      case False { this } //mismatched objects - no restoration done
    }
  }
}