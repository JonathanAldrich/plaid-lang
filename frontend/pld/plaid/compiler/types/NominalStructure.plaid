package plaid.compiler.types;

import plaid.compiler.*;
import plaid.compiler.symbol.*;
       
import plaid.collections.makeLinkedList;

state NominalStructure case of ObjectStructure {
  val shared StateSymbol symbol;
  val immutable Structure owner;
  val immutable String name;

  method immutable String getName() { this.name }

  method immutable Boolean ==(immutable Structure other)
                             [immutable NominalStructure this] 
  {
    match (other) {
      case NominalStructure { this.symbol == other.symbol } //TODO: symbol seems like it would be unique, is this correct?
      default { false }
    } 
  }
  
  method immutable String toString()[immutable NominalStructure this] {
    "STRUCT(" + this.symbol.getFQN() + ")";
  }
  
  /**
   * unpacked structures cannot be used in place of any other structures
   * might want to relax this in the future
   * packed structures are subtypes of unpacked structures if the unpacked structure's
   *   underlying type is the same as this type
   */
  method immutable Boolean isSubStructureOf(immutable Structure other)[immutable NominalStructure this] {
    match (other) {
      case TopStructure { true }
      case NominalStructure {
        val immutable StateSymbol otherSymbol = other.symbol;
        var immutable Symbol thisSuperStateSymbol = this.symbol;
        var immutable Boolean found = false;
        while { !found && !(thisSuperStateSymbol == TOPSYM) } {
          ifElse (thisSuperStateSymbol == otherSymbol) 
            { found = true }
            { thisSuperStateSymbol = thisSuperStateSymbol.getSuperStateSymbol() }
        };
        found
      }
      case UnpackedStructure { other.unpackedStructure == this }
      default { false }
    }
  }
  
  /**
   * For two nominal types, If the two nominal types are on different
   * arms of the same dimension, then the least common supertype will be returned.  If one of the nominal
   * types is a supertype of the other, the supertype is returned.
   * When comparing to an unpacked type, the upacked is returned if this nominal type is a subtype of it. 
   */
  method unique Option<immutable Structure> leastUpperBound(immutable Structure other)[immutable NominalStructure this] {
    match (other) {
      case TopStructure { makeSome(TOPSTRUCT) }
      case NominalStructure {
        var thisDimension = this.symbol.getDimension();
        var otherDimension = other.symbol.getDimension();
        
        //reduce to same size by trimming from front (lub cannot be lower than last element in smaller list)
        val sizeCmp = thisDimension.size() - otherDimension.size();
        if (sizeCmp > 0) { //reduce thisDimension
          thisDimension = thisDimension.reduceRight(fn (elem, acc) => {
            if (acc.snd > sizeCmp) { acc.fst.add(elem) };
            makePair(acc.fst,acc.snd - 1)
          },makePair(makeLinkedList(),thisDimension.size())).fst
        };
        if (sizeCmp < 0) { //reduce otherDimension
          otherDimension = otherDimension.reduceRight(fn (elem, acc) => {
            if (acc.snd > (0 - sizeCmp) ) { acc.fst.add(elem) }; //Fix negation once unary ops work
            makePair(acc.fst,acc.snd - 1)
          },makePair(makeLinkedList(),otherDimension.size())).fst
        };
        
        val dimCmp = thisDimension.zipReverse(otherDimension);
        val lub = dimCmp.reduce(TOPSYM,fn (acc,pair) => {
          match (pair.fst == pair.snd) {
            case True { pair.fst }
            case False { acc }
          }
        });
        makeSome(lub.getStructure());
      }
      case UnpackedStructure { 
        match ( this.isSubStructureOf(other)) {
          case True { makeSome(other) }
          case False { new None }
        }
      }
      default { new None }
    }
  }

  /**
   *  returns None if the member is not defined for this type or the current signature representing
   *  the member if it is defined as a method or field.
   *  Preconditions:
   *    None
   *  Errors:
   *    None
   */
  method unique Option<immutable Signature> getMember(immutable String memberName) {
      DEBUG(DEBUG_PRIO_MEDIUM, "<NominalStructure> searching for '"+memberName+"' in '" + this.symbol.getFQN() + "'");
      val memberSymbolOption = this.symbol.getMember(memberName);
      match (memberSymbolOption) {
          case Some {
              match (memberSymbolOption.value) {
                  case FieldSymbol {
                      DEBUG(DEBUG_PRIO_MEDIUM, "<NominalStructure>   found FieldSymbol for '"+memberName+"'");
                      makeSome(memberSymbolOption.value.getSignature())
                  }
                  case MethodSymbol {
                      DEBUG(DEBUG_PRIO_MEDIUM, "<NominalStructure>   found MethodSymbol for '"+memberName+"'");
                      makeSome(memberSymbolOption.value.getSignature())
                  }
                  default {
                      DEBUG(DEBUG_PRIO_HIGH, "<NominalStructure>   found unrecognized symbol type for '"+memberName+"' in '" + this.symbol.getFQN() + "'");
                      new None
                  }
              }
          }
          case None {
              DEBUG(DEBUG_PRIO_HIGH, "<NominalStructure>   Cannot find member '"+memberName+"' in '" + this.symbol.getFQN() + "'");
              new None
          }
      }
  }
  
  /**
   *  returning to a field of a packed nominal type is a no op.  Since the structure is packed, then we know
   *  one of several things about the field
   *    A) the field was packed when reassigned, OR
   *    B) pulling the permission did not unpack the field, OR
   *    C) the object changed to a different state which removes or packs the field
   *  Thus, the field may or may not still be present in the object and no action is needed.
   *  Preconditions:
   *    None
   *  Errors:
   *    None
   */
  method immutable Structure restoreToField(immutable String fieldName, immutable Type retType, immutable Integer objectID) {
    DEBUG(DEBUG_PRIO_MEDIUM, "<NominalStructure> restoring field '"+fieldName+"' in '" + this.symbol.getFQN() + "'");
    this
  }
  
  /**
   * unpacking assumes that the calculation of the updated permissions has already occurred and that
   * it was legal.  An unpacked structure including the newly unpacked field is returned
   *  Preconditions:
   *    fieldName is a member of this type and is a field
   *  Errors:
   *    if precondition not met, then ABORT will be called
   */
  method immutable UnpackedStructure unpackField(immutable UnpackedFieldSignature newFieldSig) {
    val immutable String fieldName = newFieldSig.packedSignature.name;
    DEBUG(DEBUG_PRIO_MEDIUM, "<NominalStructure> unpacking field '"+fieldName+"' in '" + this.symbol.getFQN() + "'");
    val memberSymbolOption = this.symbol.getMember(fieldName);
    match (memberSymbolOption) {
      case Some {
        match (memberSymbolOption.value) {
          case FieldSymbol {
            DEBUG(DEBUG_PRIO_MEDIUM, "<NominalStructure>   found FieldSymbol for '"+fieldName+"'");
            val unpackedFields = java.util.HashMap.new();
            unpackedFields.put(fieldName,newFieldSig);
            makeUnpackedStructureWithFieldMap(this,unpackedFields)
          }
          case MethodSymbol {
            DEBUG(DEBUG_PRIO_MEDIUM, "<NominalStructure>   found MethodSymbol for '"+fieldName+"'");
            ABORT("(Implementation Error) Cannot unpack method in '"+fieldName+"' in '" + this.symbol.getFQN() + "'")
          }
          default {
            DEBUG(DEBUG_PRIO_HIGH, "<NominalStructure>   found unrecognized symbol type for '"+fieldName+"' in '" + this.symbol.getFQN() + "'");
            ABORT("(Implementation Error) Attempting to unpack unsupported member type '"+fieldName+"' in '" + this.symbol.getFQN() + "'");
          }
        }
      }
      case None {
        DEBUG(DEBUG_PRIO_HIGH, "<NominalStructure>   Cannot find member '"+fieldName+"' in '" + this.symbol.getFQN() + "' to unpack");
        ABORT("(Implementation Error) Cannot find member '"+fieldName+"' in '" + this.symbol.getFQN() + "' to unpack");
      }
    }
  }
  
  /**
   *  assignment to a field is a no-op for nominal structures
   *  Preconditions:
   *    fieldName is a member of this type and is a field
   *  Errors:
   *    if precondition not met, then ABORT will be called
   */
  method immutable NominalStructure assignToField(immutable String fieldName) {
    DEBUG(DEBUG_PRIO_MEDIUM, "<NominalStructure> assigning to field '"+fieldName+"' in 'UNPACKED(" + this.symbol.getFQN() + ")'");

    //verify that this assignment was well-formed (TODO - may be redundant)
    val memberSymbolOption = this.symbol.getMember(fieldName);
    match (memberSymbolOption) {
      case Some {
        match (memberSymbolOption.value) {
          case FieldSymbol {
            DEBUG(DEBUG_PRIO_MEDIUM, "<NominalStructure>   found FieldSymbol for '"+fieldName+"'");
            match (memberSymbolOption.value.getSignature().isVar) {
              case True { this }
              case False { ABORT("Cannot assign to 'val' variable '" + fieldName + "'") } 
            }
          }
          case MethodSymbol {
            DEBUG(DEBUG_PRIO_MEDIUM, "<NominalStructure>   found MethodSymbol for '"+fieldName+"'");
            ABORT("Cannot assign to a method")
          }
          default {
            DEBUG(DEBUG_PRIO_HIGH, "<NominalStructure>   found unrecognized symbol type for '"+memberName+"' in 'UNPACKED(" + this.symbol.getFQN() + ")'");
            ABORT("Attempting to assign to an unsupported member type");
          }
        }
      }
      case None {
        DEBUG(DEBUG_PRIO_HIGH, "<NominalStructure>   Cannot find member '"+fieldName+"' in 'UNPACKED(" + this.symbol.getFQN() + ")' to assign to");
        ABORT("Cannot find member '"+fieldName+"' in 'UNPACKED(" + this.symbol.getFQN() + ")' to assign to");
      }
    }
  }
}