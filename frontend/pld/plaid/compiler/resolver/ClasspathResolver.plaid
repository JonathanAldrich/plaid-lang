/**
 * Copyright (c) 2010 The Plaid Group (see AUTHORS file)
 * 
 * This file is part of Plaid Programming Language.
 *
 * Plaid Programming Language is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 *  Plaid Programming Language is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Plaid Programming Language.  If not, see <http://www.gnu.org/licenses/>.
 */
package plaid.compiler.resolver;

import plaid.compiler.Resolver;
import plaid.compiler.Symbol;
import plaid.compiler.symbol.SymbolFactory;
import plaid.compiler.ERROR;
import plaid.compiler.DEBUG;
import plaid.compiler.INFO;


import plaid.ast.parsed.FieldDecl;
import plaid.ast.parsed.MethodDecl;
import plaid.ast.parsed.StateDecl;
import plaid.ast.parsed.StateValDecl;
import plaid.ast.translator.ASTTranslator;
import plaid.ast.util.makeStringFromQualifiedIdentifier;


state ClasspathResolver case of Resolver {
     val /* Map<String, Symbol> */ cache = java.util.HashMap.new();
     val immutable String  fileSeparator = java.lang.System.getProperty("file.separator");
     val /* List<String> */ classpath;
     val sf = new SymbolFactory;
     

     method /*Option<Symbol>*/ lookup(immutable String fqn) {
         DEBUG("Resolver looking for '" + fqn + "'");
         ifElse ( cache.containsKey(fqn) ) {
             DEBUG("found '" + fqn + "' in cache");
             createSome(cache.get(fqn));
         }{
             val /* List<...> */ lookupFunctions = makeEmptyList();
             lookupFunctions.add(this.lookupFromPlaidSource);

             // search through              
             var /* Option<DeclType> */ result = NONE;
             lookupFunctions.map(fn (lookupFunction) => {
                 match ( result ) {
                     case None {
                         result = lookupFunction(fqn);
                     }
                     default {}
                 };
                 lookupFunction
             });
             
             // add to cache if found
             match (result) {
                 case Some {
                     cache.put(fqn, result.value);
                 } 
                 default{}
             };
             
             result
         }
     }
     

     method void addCompilationUnit(unique CompilationUnit cu) {
         DEBUG("    add compilation Unit: " + makeStringFromQualifiedIdentifier(cu.packageName));
 
         // add package declarations
         val packages = cu.packageName.identifiers;
         var curName = packages.get(0).name;
         var i = 1;
         if(!cache.containsKey(curName)) {
            val packageSymbol = sf.makePackageSymbol(curName,sf.makeTopSymbol());
            cache.put(curName, packageSymbol);
         };
         while {i < packages.length();} {
            curName = curName + "." + packages.get(i).name;
            if(!cache.containsKey(curName)) {
                val packageSymbol = sf.makePackageSymbol(curName,sf.makeTopSymbol());
                cache.put(curName, packageSymbol);
            };
            i = i + 1;
         };
         
         val packageSymbol = cache.get(curName);
         
         // add top-level symbols    
         cu.decls.map(fn(d) => {
            val declName = curName + "." + d.name.name;
            ifElse(cache.containsKey(declName)) {
                ERROR("Name " + declName + " already declared.");
            }{
                var declSymbol = sf.makeTopSymbol;
                match(d) {
                    case FieldDecl {
                        sf.makeFieldSymbol(d.name.name, d, packageSymbol);
                    }
                    case MethodDecl {
                        sf.makeMethodSymbol(d.name.name, d, packageSymbol);
                    }
                    case StateDecl {
                        sf.makeStateSymbol(d.name.name, d, packageSymbol);
                    }
                    case StateValDecl {
                        sf.makeStateValSymbol(d.name.name, d, packageSymbol);
                    }
                    default {
                        DEBUG("Default??? = " + d.toString());
                    }
                };
                cache.put(declName, declSymbol);
            }
         });
     }
     

     method /* Option<DeclType> */ lookupFromPlaidSource(immutable String fqn) {
         var /* Option<DeclType> */ result = new None;
         
         DEBUG("searching for '" + fqn + "' plaid source code in classpath");
         classpath.map(fn (item) => {
             match (result) {
                 case None {
                     val unique File path = (java.io.File.new(item)).getAbsoluteFile();
                     DEBUG("  searching classpath: " + path);
                     
                     ifElse  ( path.isFile() && path.toString().endsWith(".jar") ) {
                         DEBUG("  dive into JAR file ... " );
                         val unique JarFile jarFile = java.util.jar.JarFile.new(path);
                         val entries = jarFile.entries();
                         while { entries.hasMoreElements() }{
                             val entry = entries.nextElement();
                             if ( entry.toString().equals(fqn.replace(".", fileSeparator)+ ".plaid") ) {
                                 DEBUG("    found: " + fqn.replace(".", fileSeparator)+ ".plaid");
                                 result = loadTypeFromPlaidSourceStream(fqn, jarFile.getInputStream(entry));
                             };
                             val packageName = fqn.substring(0, fqn.length() - (fqn.length()- fqn.lastIndexOf("."))).replace(".", fileSeparator)+ fileSeparator +"package.plaid";
                             if ( entry.toString().equals(packageName) ) {
                                 result = loadTypeFromPlaidSourceStream(fqn, jarFile.getInputStream(entry));
                             };
                         };
                     }{
                         // check for file specification
                         val fqnFile = java.io.File.new(path.toString() + fileSeparator + fqn.replace(".", fileSeparator)+ ".plaid");
                         DEBUG("    checking for file: " + fqnFile.toString() );
                         ifElse ( fqnFile.exists() ) {
                             DEBUG("  try loading definition from file: " + fqnFile.toString());
                             result = loadTypeFromPlaidSourceStream(fqn, java.io.FileInputStream.new(fqnFile));
                         }{
                             DEBUG("  specification file does not exists");
                         };

                         // check for definition in package
                         match (result) {
                             case None {
                                 val packageFile = java.io.File.new(fqnFile.getParent().toString() + fileSeparator + "package.plaid");
                                 if ( packageFile.exists() ) {
                                     DEBUG("  checking package definition: " + packageFile.toString());
                                     result = loadTypeFromPlaidSourceStream(fqn, java.io.FileInputStream.new(packageFile));
                                 }
                             }
                             default {}
                         }
                     }
                 }
                 default { /* we are done */ }
             }
         });
         
         result;
     }


     method /* Option<DeclType> */ loadTypeFromPlaidSourceStream(immutable String fqn, unique InputStream fqnStream) {
         //val typeName = fqn.substring(fqn.lastIndexOf(".")+1);
         val parser = plaid.parser.Parser.new(fqnStream);
         ifElse ( parser.hasCompilationUnit() ) {
             val javaAST = parser.getCompilationUnit();
             val translator = new ASTTranslator;
             val plaidAST = translator.translateAST(javaAST);
             addCompilationUnit(plaidAST);
             ifElse ( cache.containsKey(fqn) ) {
                INFO("Resolver found " + fqn);
                createSome(cache.get(fqn))
             }{
                NONE
             }
         }{
            NONE
         }
     }
}