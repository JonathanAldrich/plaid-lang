/**
 * Copyright (c) 2010 The Plaid Group (see AUTHORS file)
 * 
 * This file is part of Plaid Programming Language.
 *
 * Plaid Programming Language is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 *  Plaid Programming Language is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Plaid Programming Language.  If not, see <http://www.gnu.org/licenses/>.
 */
package plaid.compiler.resolver;

import plaid.compiler.Resolver;
import plaid.compiler.Symbol;
import plaid.compiler.symbol.SymbolFactory;
import plaid.compiler.ERROR;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_HIGH;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.DEBUG_PRIO_LOW;
import plaid.compiler.INFO;
import plaid.compiler.util.classpathToList;

import plaid.ast.parsed.FieldDecl;
import plaid.ast.parsed.MethodDecl;
import plaid.ast.parsed.StateDecl;
import plaid.ast.parsed.StateValDecl;
import plaid.ast.translator.ASTTranslator;
import plaid.ast.util.makeStringFromQualifiedIdentifier;
import plaid.ast.util.makeQualifiedIdentifierFromString;


state ClasspathResolver case of Resolver {
     val /* Map<String, Symbol> */ cache = java.util.HashMap.new();
     val immutable String  fileSeparator = java.lang.System.getProperty("file.separator");
     val /* List<String> */ classpath;
     val sf = new SymbolFactory;
     val /* Set<String> */ visitedFiles = java.util.HashSet.new();
     val unique List javaClasspath = classpathToList(java.lang.System.getProperty("java.class.path"));
     

     method /*Option<Symbol>*/ lookup(immutable String fqn) {
         DEBUG(DEBUG_PRIO_HIGH, "<ClasspathResolver> looking for '" + fqn + "'");
         ifElse ( cache.containsKey(fqn) ) {
             DEBUG(DEBUG_PRIO_HIGH, "<ClasspathResolver> found '" + fqn + "' in cache");
             createSome(cache.get(fqn));
         }{
             val /* List<...> */ lookupFunctions = makeEmptyList();
             lookupFunctions.add(this.lookupFromPlaidSource);
             lookupFunctions.add(this.lookupPackages);

             // search through              
             var /* Option<DeclType> */ result = NONE;
             lookupFunctions.map(fn (lookupFunction) => {
                 match ( result ) {
                     case None {
                         result = lookupFunction(fqn);
                     }
                     default {}
                 };
                 lookupFunction
             });
             
             // add to cache if found
             match (result) {
                 case Some {
                     cache.put(fqn, result.value);
                 } 
                 default{}
             };
             
             result
         }
     }
     

     method immutable Boolean define(immutable String fqn, shared Symbol symbol) {
         DEBUG(DEBUG_PRIO_MEDIUM, "<ClasspathResolver>    DEFINE '" + fqn + "'");
         if ( cache.containsKey(fqn) ) {
             WARNING("<ClasspathResolver> Overriding existing definition of '" + fqn + "'");
         };
         cache.put(fqn, symbol);
     }


     method void addCompilationUnit(unique CompilationUnit cu) {
         DEBUG(DEBUG_PRIO_MEDIUM, "<ClasspathResolver>    resolver add compilation unit");
 
         // add package declarations
         val packages = cu.packageName.identifiers;
         var curName = packages.get(0).name;
         var i = 1;
         if(!cache.containsKey(curName)) {
            val packageSymbol = sf.makePackageSymbol(curName,sf.makeTopSymbol());
            cache.put(curName, packageSymbol);
            DEBUG(DEBUG_PRIO_HIGH, "<ClasspathResolver>    ADD '" +  curName + "'");
         };
         while {i < packages.length();} {
            curName = curName + "." + packages.get(i).name;
            if(!cache.containsKey(curName)) {
                val packageSymbol = sf.makePackageSymbol(curName,sf.makeTopSymbol());
                cache.put(curName, packageSymbol);
                DEBUG(DEBUG_PRIO_HIGH, "<ClasspathResolver>    ADD '" +  curName + "'");
            };
            i = i + 1;
         };
         
         val packageSymbol = cache.get(curName);
         
         // add top-level symbols    
         cu.decls.map(fn(d) => {
            val declName = curName + "." + d.name.name;
            ifElse(cache.containsKey(declName)) {
                ERROR("<ClasspathResolver> Name " + declName + " already declared.");
            }{
                DEBUG(DEBUG_PRIO_HIGH, "<ClasspathResolver>    ADD '" +  declName + "'");
                var declSymbol = sf.makeTopSymbol();
                match(d) {
                    case FieldDecl {
                        declSymbol = sf.makeFieldSymbol(d.name.name, d, packageSymbol);
                    }
                    case MethodDecl {
                        declSymbol = sf.makeMethodSymbol(d.name.name, d, packageSymbol);
                    }
                    case StateDecl {
                        declSymbol = sf.makeStateSymbol(d.name.name, d, packageSymbol);
                    }
                    case StateValDecl {
                        declSymbol = sf.makeStateValSymbol(d.name.name, d, packageSymbol);
                    }
                };
                cache.put(declName, declSymbol);
            };
            
            d
         });
     }

     method /* Option<Symbol> */ lookupPackages(immutable String fqn) {
         DEBUG(DEBUG_PRIO_LOW, "<ClasspathResolver> searching for '" + fqn + "' package in classpath");
         var /* Option<Symbol> */ result = NONE;
         

         classpath.map(fn (item) => {
             match (result) {
                 case None {
                     val unique File path = (java.io.File.new(item)).getAbsoluteFile();
                     DEBUG(DEBUG_PRIO_LOW, "<ClasspathResolver>   searching classpath: " + path);
                     
                     var immutable Boolean found = false;                     
                     ifElse  ( path.isFile() && path.toString().endsWith(".jar") ) {
                         DEBUG(DEBUG_PRIO_LOW, "<ClasspathResolver>     dive into JAR file ... " );
                         val unique JarFile jarFile = java.util.jar.JarFile.new(path);
                         val entries = jarFile.entries();
                         while { entries.hasMoreElements() }{
                             val entry = entries.nextElement();
                             val entryName = entry.toString(); 
                             val fqnDirName = fqn.replace(".", fileSeparator);
                             ifElse ( entryName.equals(fqnFileName)  ) {                             
                                 DEBUG(DEBUG_PRIO_MEDIUM, "<ClasspathResolver>    found: " + fqnDirName );
                                 found = true;
                             }{
                                 DEBUG(DEBUG_PRIO_LOW, "<ClasspathResolver>     directory: '" + fqnDir.toString() +"' does not exists.");
                             };

                         };
                     }{
                         val fqnDir = java.io.File.new(path.toString() + fileSeparator + fqn.replace(".", fileSeparator)).getAbsoluteFile();
                         DEBUG(DEBUG_PRIO_MEDIUM, "<ClasspathResolver>     checking for directory: '" + fqnDir.toString() +"'");
                         ifElse ( fqnDir.exists() ) {
                             DEBUG(DEBUG_PRIO_LOW, "<ClasspathResolver>     directory: '" + fqnDir.toString() +"' exists.");
                             found = true;
                         }{
                             DEBUG(DEBUG_PRIO_LOW, "<ClasspathResolver>     directory: '" + fqnDir.toString() +"' does not exists.");
                         };
                     };
                     
                     if ( found ) {
                         var currentSymbol = sf.makeTopSymbol();
                         // add to cache
                         val qi = makeQualifiedIdentifierFromString(fqn);
                         qi.identifiers.map(fn (id) => {
                             currentSymbol = sf.makePackageSymbol(id, currentSymbol);

                             // check if we already have a symbol for this
                             val fqnSymbol = makeStringFromQualifiedIdentifier(currentSymbol.getQualifiedIdentifier());
                             ifElse ( cache.containsKey(fqnSymbol) ) {
                                 currentSymbol = cache.get(fqnSymbol);
                             }{
                                 cache.put(fqnSymbol, currentSymbol);
                             };                                 
                     
                             // create result 
                             result = createSome(currentSymbol);
                         });
                     };
                 }
                 case Some  {}
             }
         });
         
         result
     }
     
     method /* Option<Symbol> */ lookupFromPlaidSource(immutable String fqn) {
         var /* Option<Symbol> */ result = NONE;
         
         DEBUG(DEBUG_PRIO_LOW, "<ClasspathResolver> searching for '" + fqn + "' plaid source code in classpath");
         classpath.map(fn (item) => {
             match (result) {
                 case None {
                     val unique File path = (java.io.File.new(item)).getAbsoluteFile();
                     DEBUG(DEBUG_PRIO_LOW, "<ClasspathResolver>   searching classpath: " + path);
                     
                     ifElse  ( path.isFile() && path.toString().endsWith(".jar") ) {
                         DEBUG(DEBUG_PRIO_LOW, "<ClasspathResolver>     dive into JAR file ... " );
                         val unique JarFile jarFile = java.util.jar.JarFile.new(path);
                         val entries = jarFile.entries();
                         while { entries.hasMoreElements() }{
                             
                             val entry = entries.nextElement();
                             val entryName = entry.toString(); 
                             val fqnFileName = fqn.replace(".", fileSeparator)+ ".plaid";
                             val absFileName = path.getAbsolutePath()+ fileSeparator + fqnFileName;
                             if ( entryName.equals(fqnFileName) && (!visitedFiles.contains(absFileName)) ) {                             
                                 DEBUG(DEBUG_PRIO_MEDIUM, "<ClasspathResolver>    found: " + fqn.replace(".", fileSeparator)+ ".plaid");
                                 visitedFiles.add(absFileName);
                                 result = loadTypeFromPlaidSourceStream(fqn, jarFile.getInputStream(entry));
                             };
                             match (result) {
                                 case None {
                                     val packageName = fqn.substring(0, fqn.length() - (fqn.length()- fqn.lastIndexOf("."))).replace(".", fileSeparator)+ fileSeparator +"package.plaid";
                                     val absPackageFileName = packageName + fileSeparator + packageName;                                     
                                     if ( entryName.equals(packageName) && (!visitedFiles.contains(absPackageFileName))) {
                                         DEBUG(DEBUG_PRIO_MEDIUM, "<ClasspathResolver>     found: " + packageName);
                                         visitedFiles.add(absPackageFileName);
                                         result = loadTypeFromPlaidSourceStream(fqn, jarFile.getInputStream(entry));
                                     };
                                 }
                                 case Some { result }
                             }
                         };
                     }{
                         // check for file specification
                         val fqnFile = java.io.File.new(path.toString() + fileSeparator + fqn.replace(".", fileSeparator)+ ".plaid").getAbsoluteFile();
                         DEBUG(DEBUG_PRIO_MEDIUM, "<ClasspathResolver>     checking for file: " + fqnFile.toString() );
                         ifElse ( fqnFile.exists() && (!visitedFiles.contains(fqnFile.getAbsolutePath())) ) {
                             DEBUG(DEBUG_PRIO_MEDIUM, "<ClasspathResolver>       try loading definition from file: " + fqnFile.toString());
                             visitedFiles.add(fqnFile.getAbsolutePath());
                             result = loadTypeFromPlaidSourceStream(fqn, java.io.FileInputStream.new(fqnFile));
                         }{
                             DEBUG(DEBUG_PRIO_LOW, "<ClasspathResolver>       specification file does not exists");
                         };

                         // check for definition in package
                         match (result) {
                             case None {                           
                                 val packageFile = java.io.File.new(fqnFile.getParent().toString() + fileSeparator + "package.plaid");
                                  DEBUG(DEBUG_PRIO_MEDIUM, "<ClasspathResolver>     checking for package file: " + packageFile.toString() );
                                 ifElse ( packageFile.exists() && (!visitedFiles.contains(packageFile.getAbsolutePath())) ) {
                                     DEBUG(DEBUG_PRIO_MEDIUM, "<ClasspathResolver>     checking package definition: " + packageFile.toString());
                                     visitedFiles.add(packageFile.getAbsolutePath());
                                     result = loadTypeFromPlaidSourceStream(fqn, java.io.FileInputStream.new(packageFile));
                                 }{
                                     DEBUG(DEBUG_PRIO_MEDIUM, "<ClasspathResolver>       package file does not exist");
                                 }
                             }
                             default {}
                         }
                     }
                 }
                 default { /* we are done */ }
             };
             
             item
         });
         
         result;
     }


     method /* Option<Symbol> */ loadTypeFromPlaidSourceStream(immutable String fqn, 
      unique InputStream fqnStream) {
         val parser = plaid.parser.Parser.new(fqnStream);
         ifElse ( parser.hasCompilationUnit() ) {
             val javaAST = parser.getCompilationUnit();
             val translator = new ASTTranslator;
             val plaidAST = translator.translateAST(javaAST);
             addCompilationUnit(plaidAST);
             ifElse ( cache.containsKey(fqn) ) {
                DEBUG(DEBUG_PRIO_HIGH, "<ClasspathResolver>      found '" + fqn + "'");
                createSome(cache.get(fqn))
             }{
                NONE
             }
         }{
            ERROR("<ClasspathResolver>     Could not parse '" + fqn + "'");
            NONE
         }
     }
}