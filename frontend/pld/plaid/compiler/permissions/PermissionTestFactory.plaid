/**
 * Copyright (c) 2010 The Plaid Group (see AUTHORS file)
 * 
 * This file is part of Plaid Programming Language.
 *
 * Plaid Programming Language is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 *  Plaid Programming Language is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Plaid Programming Language.  If not, see <http://www.gnu.org/licenses/>.
 */

package plaid.compiler.permissions;

import plaid.lang.testing.TestFactory;
import plaid.lang.testing.Test;

import plaid.collections.makeLinkedList;

import plaid.compiler.tests.TypesForTests;

state PermissionTestFactory case of TestFactory {
	
	method unique List<unique Test> createTests() {
		val tests = makeLinkedList();
		val test = fn(name,body) => { tests.add(mktest(name, body)) };
		var t = new None;  //dummy variable to get around match scoping bug
		
		val types = new TypesForTests;
		types.initPermissions();

		/********** UNIQUE *************/
		test("Unique is writable", fn(ctx) => {
			ctx.assertTrue(UNIQUE.isWritable());
		});
		
		test("Unique guarantees state", fn(ctx) => {
			ctx.assertTrue(UNIQUE.guaranteesState());
		});
		
		test("Unique ==", fn(ctx) => { 
      ctx.assertTrue(UNIQUE == UNIQUE);
      ctx.assertFalse(UNIQUE == IMMUTABLE);
      ctx.assertFalse(UNIQUE == SHARED);
      ctx.assertFalse(UNIQUE == LOCALIMMUTABLE);
      ctx.assertFalse(UNIQUE == LOCALSHARED);
      ctx.assertFalse(UNIQUE == NONEP);
      ctx.assertFalse(UNIQUE == DYNAMICP);
      ctx.assertFalse(UNIQUE == types.permBi3u);
      ctx.assertFalse(UNIQUE == types.permBs1u);
    });
    
    test("Unique toString", fn(ctx) => { 
      ctx.assertTrue(UNIQUE.toString().equals("unique"));
    });
		
		test("Unique splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (UNIQUE.splitPerm(UNIQUE)) {
					case Some {
						match (UNIQUE.splitPerm(UNIQUE).value) {
							case NonePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(IMMUTABLE)) {
					case Some {
						match (UNIQUE.splitPerm(IMMUTABLE).value) {
							case ImmutablePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(SHARED)) {
					case Some {
						match (UNIQUE.splitPerm(SHARED).value) {
							case SharedPermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(NONEP)) {
					case Some {
						match (UNIQUE.splitPerm(NONEP).value) {
							case UniquePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(LOCALIMMUTABLE)) {
					case Some {
						t = UNIQUE.splitPerm(LOCALIMMUTABLE).value;
						match (t) {
							case BorrowedPermission { 
								ifElse( t.thePerm == IMMUTABLE &&
										t.originalPerm == UNIQUE &&
										t.splitCount == 1 )
								{ true }
								{ false }
							}
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(LOCALSHARED)) {
					case Some {
						t = UNIQUE.splitPerm(LOCALSHARED).value;
						match (t) {
							case BorrowedPermission { 
								ifElse( t.thePerm == SHARED &&
										t.originalPerm == UNIQUE &&
										t.splitCount == 1 )
								{ true }
								{ false }
							}
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(types.permBi3u)) {
					case Some { false }
					case None { true }
				}
			);
		  ctx.assertTrue(
        match (UNIQUE.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Unique returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (UNIQUE.returnPerm(UNIQUE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(IMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(SHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(LOCALIMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(LOCALSHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(types.permBi3u)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(NONEP)) {
				case Some {
					match (UNIQUE.returnPerm(NONEP).value) {
						case UniquePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(DYNAMICP)) {
        case Some { false }
        case None { true }
      });
		});

		test("Unique isSubPermOf", fn(ctx) => {	
			ctx.assertTrue(UNIQUE.isSubPermOf(UNIQUE));
			ctx.assertTrue(UNIQUE.isSubPermOf(IMMUTABLE));
			ctx.assertTrue(UNIQUE.isSubPermOf(SHARED));
			ctx.assertTrue(UNIQUE.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertTrue(UNIQUE.isSubPermOf(LOCALSHARED));
			ctx.assertTrue(UNIQUE.isSubPermOf(NONEP));
			ctx.assertFalse(UNIQUE.isSubPermOf(types.permBi3u));
			ctx.assertFalse(UNIQUE.isSubPermOf(DYNAMICP));
		});
		
		test("Unique greatestLowerBound", fn (ctx) => {
			t = UNIQUE.greatestLowerBound(UNIQUE);
			ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
			t = UNIQUE.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
			t = UNIQUE.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = UNIQUE.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = UNIQUE.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = UNIQUE.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = UNIQUE.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = UNIQUE.greatestLowerBound(types.permBi3u);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
			
		});
		
		test("split field permissions from unique receiver", fn (ctx) => {
      t = splitFieldPermission(UNIQUE,UNIQUE,UNIQUE);
      ctx.assertTrue(match(t) { case Some { t.value == NONEP } case None { false } });
      t = splitFieldPermission(UNIQUE,UNIQUE,IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = splitFieldPermission(UNIQUE,UNIQUE,SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      t = splitFieldPermission(UNIQUE,UNIQUE,LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == types.permBs1u } case None { false } });
      t = splitFieldPermission(UNIQUE,UNIQUE,NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = splitFieldPermission(UNIQUE,types.permBi2u,LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == types.permBi3u } case None { false } });
      t = splitFieldPermission(UNIQUE,SHARED,LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
    });
		
		/********** IMMUTABLE *************/
		
		test("Immutable is not writable", fn(ctx) => {
			ctx.assertFalse(IMM.isWritable());
		});
		
		test("Immutable guarantees state", fn(ctx) => {
			ctx.assertTrue(IMM.guaranteesState());
		});
		
		test("Immutable ==", fn(ctx) => { 
      ctx.assertFalse(IMM == UNIQUE);
      ctx.assertTrue(IMM == IMMUTABLE);
      ctx.assertFalse(IMM == SHARED);
      ctx.assertFalse(IMM == LOCALIMMUTABLE);
      ctx.assertFalse(IMM == LOCALSHARED);
      ctx.assertFalse(IMM == NONEP);
      ctx.assertFalse(IMM == types.permBi3u);
      ctx.assertFalse(IMM == DYNAMICP);
    });
    
    test("Immutable toString", fn(ctx) => { 
      ctx.assertTrue(IMM.toString().equals("immutable"));
    });
		
		test("Immutable splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (IMM.splitPerm(UNIQUE)) {
					case Some { false }
					case None { true }
				}
			);
			t = IMM.splitPerm(IMMUTABLE);
			ctx.assertTrue(
				match (t ) {
					case Some {
						match (t.value) {
							case ImmutablePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (IMM.splitPerm(SHARED)) {
					case Some { false }
					case None { true }
				}
			);
			t = IMM.splitPerm(LOCALIMMUTABLE);
			ctx.assertTrue(
				match (t) {
					case Some {
						match (t.value) {
							case ImmutablePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (IMM.splitPerm(LOCALSHARED)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (IMM.splitPerm(NONEP)) {
					case Some {
						match (IMM.splitPerm(NONEP).value) {
							case ImmutablePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (IMM.splitPerm(types.permBi3u)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
        match (IMM.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Immutable returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (IMM.returnPerm(UNIQUE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (IMM.returnPerm(IMMUTABLE)) {
				case Some {
					match (IMM.returnPerm(IMMUTABLE).value) {
						case ImmutablePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (IMM.returnPerm(SHARED)) {
				case Some { false }
				case None { true }
			});
			t = IMM.returnPerm(LOCALIMMUTABLE);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case ImmutablePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (IMM.returnPerm(LOCALSHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (IMM.returnPerm(types.permBi3u)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (IMM.returnPerm(NONEP)) {
				case Some {
					match (IMM.returnPerm(NONEP).value) {
						case ImmutablePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (IMM.returnPerm(DYNAMICP)) {
        case Some { false }
        case None { true }
      });
		});

		test("Immutable isSubPermOf", fn(ctx) => {	
			ctx.assertFalse(IMM.isSubPermOf(UNIQUE));
			ctx.assertTrue(IMM.isSubPermOf(IMMUTABLE));
			ctx.assertTrue(IMM.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertFalse(IMM.isSubPermOf(SHARED));
			ctx.assertFalse(IMM.isSubPermOf(LOCALSHARED));
			ctx.assertFalse(IMM.isSubPermOf(types.permBi3u));
			ctx.assertTrue(IMM.isSubPermOf(NONEP));
			ctx.assertFalse(IMM.isSubPermOf(DYNAMICP));
		});
		
		test("Immutable greatestLowerBound", fn (ctx) => {
      t = IMM.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = IMM.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = IMM.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = IMM.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = IMM.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = IMM.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = IMM.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = IMM.greatestLowerBound(types.permBi3u);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
    });
    
    test("split field permissions from immutable receiver", fn (ctx) => {
      t = splitFieldPermission(IMMUTABLE,UNIQUE,UNIQUE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(IMMUTABLE,UNIQUE,IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = splitFieldPermission(IMMUTABLE,UNIQUE,LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = splitFieldPermission(IMMUTABLE,UNIQUE,NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = splitFieldPermission(IMMUTABLE,UNIQUE,SHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(IMMUTABLE,UNIQUE,LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(IMMUTABLE,SHARED,LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      t = splitFieldPermission(IMMUTABLE,IMMUTABLE,LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(IMMUTABLE,IMMUTABLE,IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
    });
		
		/********** SHARED *************/
		
		test("Shared is writable", fn(ctx) => {
			ctx.assertTrue(SHARED.isWritable());
		});
		
		test("Shared does not guarantee state", fn(ctx) => {
			ctx.assertFalse(SHARED.guaranteesState());
		});
		
		test("Shared ==", fn(ctx) => { 
      ctx.assertFalse(SHARED == UNIQUE);
      ctx.assertFalse(SHARED == IMMUTABLE);
      ctx.assertTrue(SHARED == SHARED);
      ctx.assertFalse(SHARED == LOCALIMMUTABLE);
      ctx.assertFalse(SHARED == LOCALSHARED);
      ctx.assertFalse(SHARED == NONEP);
      ctx.assertFalse(SHARED == types.permBi3u);
      ctx.assertFalse(SHARED == DYNAMICP);
    });
    
    test("Shared toString", fn(ctx) => { 
      ctx.assertTrue(SHARED.toString().equals("shared"));
    });
		
		test("Shared splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (SHARED.splitPerm(UNIQUE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (SHARED.splitPerm(SHARED)) {
					case Some {
						match (SHARED.splitPerm(SHARED).value) {
							case SharedPermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (SHARED.splitPerm(IMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			t = SHARED.splitPerm(LOCALSHARED);
			ctx.assertTrue(
				match (t) {
					case Some {
						match (t.value) {
							case SharedPermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (SHARED.splitPerm(LOCALIMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (SHARED.splitPerm(NONEP)) {
					case Some {
						match (SHARED.splitPerm(NONEP).value) {
							case SharedPermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (SHARED.splitPerm(types.permBi3u)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
        match (SHARED.splitPerm(types.permBs1u)) {
          case Some { false }
          case None { true }
        }
      );
			ctx.assertTrue(
        match (SHARED.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Shared returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (SHARED.returnPerm(UNIQUE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (SHARED.returnPerm(SHARED)) {
				case Some {
					match (SHARED.returnPerm(SHARED).value) {
						case SharedPermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (SHARED.returnPerm(IMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			t = SHARED.returnPerm(LOCALSHARED);
			ctx.assertTrue(
				match (t) {
					case Some {
						match (t.value) {
							case SharedPermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (SHARED.returnPerm(LOCALIMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (SHARED.returnPerm(types.permBi3u)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(match (SHARED.returnPerm(NONEP)) {
				case Some {
					match (SHARED.returnPerm(NONEP).value) {
						case SharedPermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(
        match (SHARED.returnPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Shared isSubPermOf", fn(ctx) => {	
			ctx.assertFalse(SHARED.isSubPermOf(UNIQUE));
			ctx.assertFalse(SHARED.isSubPermOf(IMMUTABLE));
			ctx.assertFalse(SHARED.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertTrue(SHARED.isSubPermOf(SHARED));
			ctx.assertTrue(SHARED.isSubPermOf(LOCALSHARED));
			ctx.assertFalse(SHARED.isSubPermOf(types.permBi3u));
			ctx.assertTrue(SHARED.isSubPermOf(NONEP));
			ctx.assertFalse(SHARED.isSubPermOf(DYNAMICP));
		});
		
		test("Shared greatestLowerBound", fn (ctx) => {
		  t = SHARED.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = SHARED.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = SHARED.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      t = SHARED.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = SHARED.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      t = SHARED.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      t = SHARED.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = SHARED.greatestLowerBound(types.permBi3u);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
		});
		
		 test("split field permissions from shared receiver", fn (ctx) => {
      t = splitFieldPermission(SHARED,UNIQUE,UNIQUE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(SHARED,UNIQUE,SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = splitFieldPermission(SHARED,UNIQUE,LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = splitFieldPermission(SHARED,UNIQUE,NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = splitFieldPermission(SHARED,UNIQUE,IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(SHARED,UNIQUE,LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(SHARED,IMMUTABLE,LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = splitFieldPermission(SHARED,SHARED,SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      t = splitFieldPermission(SHARED,SHARED,LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      //not a valid test situation and not the behavior
      //t = splitFieldPermission(SHARED,types.permBs1u,LOCALSHARED);
      //ctx.assertTrue(match(t) { case Some { t.value == types.permBs2u } case None { false } });
    });
		
		/********** NONE *************/
		
		test("None is not writable", fn(ctx) => {
			ctx.assertFalse(NONEP.isWritable());
		});
		
		test("None does not guarantee state", fn(ctx) => {
			ctx.assertFalse(NONEP.guaranteesState());
		});
		
		test("None ==", fn(ctx) => { 
      ctx.assertFalse(NONEP == UNIQUE);
      ctx.assertFalse(NONEP == IMMUTABLE);
      ctx.assertFalse(NONEP == SHARED);
      ctx.assertFalse(NONEP == LOCALIMMUTABLE);
      ctx.assertFalse(NONEP == LOCALSHARED);
      ctx.assertTrue(NONEP == NONEP);
      ctx.assertFalse(NONEP == types.permBi3u);
      ctx.assertFalse(NONEP == DYNAMICP);
    });
    
    test("None toString", fn(ctx) => { 
      ctx.assertTrue(NONEP.toString().equals("none"));
    });
		
		test("None splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (NONEP.splitPerm(UNIQUE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (NONEP.splitPerm(SHARED)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (NONEP.splitPerm(IMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (NONEP.splitPerm(LOCALSHARED)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (NONEP.splitPerm(LOCALIMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (NONEP.splitPerm(NONEP)) {
					case Some {
						match (NONEP.splitPerm(NONEP).value) {
							case NonePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
        match (NONEP.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("None returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (NONEP.returnPerm(UNIQUE)) {
				case Some {
					match (NONEP.returnPerm(UNIQUE).value) {
						case UniquePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (NONEP.returnPerm(SHARED)) {
				case Some {
					match (NONEP.returnPerm(SHARED).value) {
						case SharedPermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (NONEP.returnPerm(IMMUTABLE)) {
				case Some {
					match (NONEP.returnPerm(IMMUTABLE).value) {
						case ImmutablePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			t = NONEP.returnPerm(LOCALSHARED);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case LocalPermission { 
							ifElse ( t.value.thePerm == SHARED )
							{ true }
							{ false }
						}
						default { false }
					} 
				}
				case None { false }
			});
			t = NONEP.returnPerm(LOCALIMMUTABLE);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case LocalPermission { 
							ifElse ( t.value.thePerm == IMMUTABLE )
							{ true }
							{ false }
						}
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (NONEP.returnPerm(NONEP)) {
				case Some {
					match (NONEP.returnPerm(NONEP).value) {
						case NonePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (NONEP.returnPerm(types.permBi3u)) {
				case Some { false }
				case None { true }
			});
			ctx.assertFalse(match (NONEP.returnPerm(DYNAMICP)) {
        case Some { false }
        case None { true }
      });
		});

		test("None isSubPermOf", fn(ctx) => {	
			ctx.assertFalse(NONEP.isSubPermOf(UNIQUE));
			ctx.assertFalse(NONEP.isSubPermOf(IMMUTABLE));
			ctx.assertFalse(NONEP.isSubPermOf(SHARED));
			ctx.assertFalse(NONEP.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertFalse(NONEP.isSubPermOf(LOCALSHARED));
			ctx.assertFalse(NONEP.isSubPermOf(types.permBi3u));
			ctx.assertTrue(NONEP.isSubPermOf(NONEP));
			ctx.assertFalse(NONEP.isSubPermOf(DYNAMICP));
		});
		
		test("NONE greatestLowerBound", fn (ctx) => {
      t = NONEP.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = NONEP.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = NONEP.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      t = NONEP.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == LOCALIMMUTABLE } case None { false } });
      t = NONEP.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == LOCALSHARED } case None { false } });
      t = NONEP.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == NONEP } case None { false } });
      t = NONEP.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = NONEP.greatestLowerBound(types.permBi3u);
      ctx.assertTrue(match(t) { case Some { t.value == types.permBi3u } case None { true } });
    });
    
    test("split field permissions from none receiver", fn (ctx) => {
      t = splitFieldPermission(NONEP,UNIQUE,UNIQUE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(NONEP,UNIQUE,SHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(NONEP,UNIQUE,LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(NONEP,UNIQUE,NONEP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(NONEP,UNIQUE,IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(NONEP,UNIQUE,LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(NONEP,IMMUTABLE,LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
    });
		
		
		/********** LOCAL *************/
		
		test("Local is writable if underlying permission is", fn(ctx) => {
			ctx.assertFalse(LOCALIMMUTABLE.isWritable());
			ctx.assertTrue(LOCALSHARED.isWritable());
		});
		
		test("Local guarantees state if underlying permission does", fn(ctx) => {
			ctx.assertTrue(LOCALIMMUTABLE.guaranteesState());
			ctx.assertFalse(LOCALSHARED.guaranteesState());
		});
		
		test("Local ==", fn(ctx) => { 
      ctx.assertFalse(LOCALIMMUTABLE == UNIQUE);
      ctx.assertFalse(LOCALIMMUTABLE == IMMUTABLE);
      ctx.assertFalse(LOCALIMMUTABLE == SHARED);
      ctx.assertTrue(LOCALIMMUTABLE == LOCALIMMUTABLE);
      ctx.assertFalse(LOCALIMMUTABLE == LOCALSHARED);
      ctx.assertFalse(LOCALIMMUTABLE == NONEP);
      ctx.assertFalse(LOCALIMMUTABLE == types.permBi3u);
      ctx.assertFalse(LOCALIMMUTABLE == DYNAMICP);
    });
    
    test("Local toString", fn(ctx) => { 
      ctx.assertTrue(LOCALIMMUTABLE.toString().equals("local immutable"));
      ctx.assertTrue(LOCALSHARED.toString().equals("local shared"));
    });
		
		test("Local splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (LOCALIMMUTABLE.splitPerm(UNIQUE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (LOCALIMMUTABLE.splitPerm(SHARED)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (LOCALIMMUTABLE.splitPerm(IMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (LOCALIMMUTABLE.splitPerm(LOCALSHARED)) {
					case Some { false }
					case None { true }
				}
			);
			t = LOCALIMMUTABLE.splitPerm(LOCALIMMUTABLE);
			ctx.assertTrue(
				match (t) {
					case Some { 
						match (t.value) {
							case BorrowedPermission {
								t.value.thePerm == IMMUTABLE &&
								t.value.originalPerm == LOCALIMMUTABLE &&
								t.value.splitCount == 1
							}
							default { false }
						}
 					}
					case None { false }
				}
			);
			t = LOCALIMMUTABLE.splitPerm(NONEP);
			ctx.assertTrue(
				match (t) {
					case Some {
						match (t.value) {
							case LocalPermission { t.value.thePerm == IMMUTABLE }
							default { false }
						}
					}
					case None { false }
				}
			);
      ctx.assertTrue(
        match (LOCALIMMUTABLE.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Local returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(UNIQUE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(IMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(SHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(LOCALIMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(LOCALSHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(types.permBi3u)) {
				case Some { false }
				case None { true }
			});
			t = LOCALIMMUTABLE.returnPerm(NONEP);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case LocalPermission { t.value.thePerm == IMMUTABLE }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(DYNAMICP)) {
        case Some { false }
        case None { true }
      });
		});

		test("local isSubPermOf", fn(ctx) => {	
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(UNIQUE));
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(IMMUTABLE));
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(SHARED));
			ctx.assertTrue(LOCALIMMUTABLE.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(LOCALSHARED));
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(types.permBi3u));
			ctx.assertTrue(LOCALIMMUTABLE.isSubPermOf(NONEP));
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(DYNAMICP));
			
		});
		
		test("Local greatestLowerBound", fn (ctx) => {
      t = LOCALIMMUTABLE.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == LOCALIMMUTABLE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == LOCALIMMUTABLE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = LOCALIMMUTABLE.greatestLowerBound(types.permBi3u);
      ctx.assertTrue(match(t) { case Some { t.value == types.permBi3u } case None { true } });
      t = LOCALIMMUTABLE.greatestLowerBound(types.permBs1u);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
		});
		
		test("split field permissions from local receiver", fn (ctx) => {
      t = splitFieldPermission(LOCALIMMUTABLE,UNIQUE,UNIQUE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(LOCALIMMUTABLE,UNIQUE,SHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(LOCALIMMUTABLE,UNIQUE,NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = splitFieldPermission(LOCALIMMUTABLE,UNIQUE,IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(LOCALSHARED,UNIQUE,LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == types.permBs1u } case None { false } });
      t = splitFieldPermission(LOCALIMMUTABLE,types.permBi2u,LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == types.permBi3u } case None { false } });
    });
	
			/********** Borrowed *************/
		
		//declared above - here for ease of looking
		//val types.permBs1u = makeBorrowedPerm(SHARED,UNIQUE,1);
		//val types.permBi3u = makeBorrowedPerm(IMM,UNIQUE,3); (same as types.permBi3u)
		
		test("Borrowed is writable if underlying permission is", fn(ctx) => {
			ctx.assertFalse(types.permBi3u.isWritable());
			ctx.assertTrue(types.permBs1u.isWritable());
		});
		
		test("Borrowed guarantees state if underlying permission does", fn(ctx) => {
			ctx.assertTrue(types.permBi3u.guaranteesState());
			ctx.assertFalse(types.permBs1u.guaranteesState());
		});
    
    test("Borrowed ==", fn(ctx) => { 
      ctx.assertFalse(types.permBi3u == UNIQUE);
      ctx.assertFalse(types.permBi3u == IMMUTABLE);
      ctx.assertFalse(types.permBi3u == SHARED);
      ctx.assertFalse(types.permBi3u == LOCALIMMUTABLE);
      ctx.assertFalse(types.permBi3u == LOCALSHARED);
      ctx.assertFalse(types.permBi3u == NONEP);
      ctx.assertTrue(types.permBi3u == types.permBi3u);
      ctx.assertFalse(types.permBi3u == types.permBs1u);
      ctx.assertFalse(types.permBi3u == DYNAMICP);
    });
    
    test("types.permBi3u toString", fn(ctx) => { 
      ctx.assertTrue(types.permBs1u.toString().equals("borrow(local shared, unique, 1)"));
      ctx.assertTrue(types.permBi3u.toString().equals("borrow(local immutable, unique, 3)"));
    });
		
		test("Borrowed splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (types.permBs1u.splitPerm(UNIQUE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (types.permBs1u.splitPerm(SHARED)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (types.permBs1u.splitPerm(IMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			t = types.permBs1u.splitPerm(LOCALSHARED);
			ctx.assertTrue(
				match (t) {
					case Some { 
						match (t.value) {
							case BorrowedPermission { 
								t.value.thePerm == SHARED &&
								t.value.originalPerm == UNIQUE &&
								t.value.splitCount == 2
							}
							default { false }
						}
					}
					case None { true }
				}
			);
			ctx.assertTrue(
				match (types.permBs1u.splitPerm(LOCALIMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			t = types.permBs1u.splitPerm(NONEP);
			ctx.assertTrue(
				match (t) {
					case Some {
						match (t.value) {
							case BorrowedPermission { 
								t.value.thePerm == SHARED &&
								t.value.originalPerm == UNIQUE &&
								t.value.splitCount == 1
							}
							default { false }
						}
					}
					case None { false }
				}
			);
		  ctx.assertTrue(
        match (types.permBs1u.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Borrowed returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (types.permBs1u.returnPerm(UNIQUE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (types.permBs1u.returnPerm(IMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (types.permBs1u.returnPerm(SHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (types.permBs1u.returnPerm(LOCALIMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			t = types.permBi3u.returnPerm(LOCALIMMUTABLE);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case BorrowedPermission { 
								t.value.thePerm == IMMUTABLE &&
								t.value.originalPerm == UNIQUE &&
								t.value.splitCount == 2
							}
						default { false }
					} 
				}
				case None { false }
			});
			t = types.permBs1u.returnPerm(LOCALSHARED);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case UniquePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (types.permBs1u.returnPerm(types.permBi3u)) {
				case Some { false }
				case None { true }
			});
			t = types.permBs1u.returnPerm(NONEP);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case BorrowedPermission { 
								t.value.thePerm == SHARED &&
								t.value.originalPerm == UNIQUE &&
								t.value.splitCount == 1
							}
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (types.permBs1u.returnPerm(DYNAMICP)) {
        case Some { false }
        case None { true }
      });
		});

		test("borrow isSubPermOf", fn(ctx) => {	
			ctx.assertFalse(types.permBs1u.isSubPermOf(UNIQUE));
			ctx.assertFalse(types.permBs1u.isSubPermOf(IMMUTABLE));
			ctx.assertFalse(types.permBs1u.isSubPermOf(SHARED));
			ctx.assertFalse(types.permBs1u.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertTrue(types.permBs1u.isSubPermOf(LOCALSHARED));
			ctx.assertFalse(types.permBs1u.isSubPermOf(types.permBi3u));
			ctx.assertTrue(types.permBs1u.isSubPermOf(NONEP));
			ctx.assertFalse(types.permBs1u.isSubPermOf(DYNAMICP));
		});
		
		test("borrow greatestLowerBound", fn (ctx) => {
      t = types.permBi3u.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = types.permBi3u.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = types.permBi3u.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = types.permBi3u.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == types.permBi3u } case None { false } });
      t = types.permBi3u.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = types.permBi3u.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == types.permBi3u } case None { false } });
      t = types.permBi3u.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = types.permBi3u.greatestLowerBound(types.permBi3u);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = types.permBi3u.greatestLowerBound(types.permBs1u);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
    });
    
    test("split field permissions from types.permBi3u receiver", fn (ctx) => {
      t = splitFieldPermission(types.permBi3u,UNIQUE,UNIQUE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(types.permBi3u,UNIQUE,SHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(types.permBi3u,UNIQUE,NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = splitFieldPermission(types.permBi3u,UNIQUE,IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(types.permBs2u,UNIQUE,LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == types.permBs1u } case None { false } });
      t = splitFieldPermission(types.permBi3u,types.permBi2u,LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == types.permBi3u } case None { false } });
    });
	
	   /********** Dynamic *************/
    
    test("Dynamic is writable", fn(ctx) => {
      ctx.assertTrue(DYNAMICP.isWritable());
    });
    
    test("Dynamic does not guarantee state", fn(ctx) => {
      ctx.assertFalse(DYNAMICP.guaranteesState());
    });
    
    test("Dynamic ==", fn(ctx) => { 
      ctx.assertFalse(DYNAMICP == UNIQUE);
      ctx.assertFalse(DYNAMICP == IMMUTABLE);
      ctx.assertFalse(DYNAMICP == SHARED);
      ctx.assertFalse(DYNAMICP == LOCALIMMUTABLE);
      ctx.assertFalse(DYNAMICP == LOCALSHARED);
      ctx.assertFalse(DYNAMICP == NONEP);
      ctx.assertFalse(DYNAMICP == types.permBi3u);
      ctx.assertTrue(DYNAMICP == new DynamicPermission);
    });
    
    test("Dynamic toString", fn(ctx) => { 
      ctx.assertTrue(DYNAMICP.toString().equals("dynamic"));
    });
    
    test("Dynamic splitting", fn(ctx) => {
      //splitting
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(UNIQUE)) {
          case Some { false }
          case None { true }
        }
      );
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(SHARED)) {
          case Some { false }
          case None { true }
        }
      );
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(IMMUTABLE)) {
          case Some { false }
          case None { true }
        }
      );
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(LOCALIMMUTABLE)) {
          case Some { false }
          case None { true }
        }
      );
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(NONEP)) {
          case Some { false }
          case None { true }
        }
      );
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(types.permBi3u)) {
          case Some { false }
          case None { true }
        }
      );
      t = DYNAMICP.splitPerm(new DynamicPermission);
      ctx.assertTrue(
        match (t) {
          case Some { t.value == DYNAMICP }
          case None { false }
        }
      );
    });
    
    test("Dynamic returns", fn(ctx) => {
      //joining
      ctx.assertTrue(match (DYNAMICP.returnPerm(UNIQUE)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(IMMUTABLE)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(SHARED)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(LOCALIMMUTABLE)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(LOCALSHARED)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(NONEP)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(types.permBi3u)) {
        case Some { false }
        case None { true }
      });
      t = DYNAMICP.returnPerm(new DynamicPermission);
      ctx.assertTrue(match (t) {
        case Some {
          t.value == DYNAMICP 
        }
        case None { false }
      });
    });

    test("dynamic isSubPermOf", fn(ctx) => { 
      ctx.assertFalse(DYNAMICP.isSubPermOf(UNIQUE));
      ctx.assertFalse(DYNAMICP.isSubPermOf(IMMUTABLE));
      ctx.assertFalse(DYNAMICP.isSubPermOf(SHARED));
      ctx.assertFalse(DYNAMICP.isSubPermOf(LOCALIMMUTABLE));
      ctx.assertFalse(DYNAMICP.isSubPermOf(LOCALSHARED));
      ctx.assertFalse(DYNAMICP.isSubPermOf(types.permBi3u));
      ctx.assertFalse(DYNAMICP.isSubPermOf(NONEP));
      ctx.assertTrue(DYNAMICP.isSubPermOf(new DynamicPermission));
    });
    
    test("dynamic greatestLowerBound", fn (ctx) => {
      t = DYNAMICP.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(types.permBi3u);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { t.value == DYNAMICP } case None { false } });
    });
    
    test("split field permissions from dynamic receiver", fn (ctx) => {
      t = splitFieldPermission(DYNAMICP,UNIQUE,UNIQUE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(DYNAMICP,UNIQUE,SHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(DYNAMICP,UNIQUE,NONEP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(DYNAMICP,UNIQUE,IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(DYNAMICP,UNIQUE,LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = splitFieldPermission(DYNAMICP,types.permBi2u,LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
    });
    
		/********** Globals *************/
		
		test("global definitions", fn(ctx) => { 
      ctx.assertTrue(UNIQUE == new UniquePermission);
      ctx.assertTrue(IMMUTABLE == new ImmutablePermission);
      ctx.assertTrue(IMM == new ImmutablePermission);
      ctx.assertTrue(SHARED == new SharedPermission);
      ctx.assertTrue(NONEP == new NonePermission);
      ctx.assertTrue(LOCALIMMUTABLE == new LocalPermission { val thePerm = new ImmutablePermission; });
      ctx.assertTrue(LOCALIMM == new LocalPermission { val thePerm = new ImmutablePermission; });
      ctx.assertTrue(LOCALSHARED == new LocalPermission { val thePerm = new SharedPermission; });
      ctx.assertTrue(DYNP == new DynamicPermission);
      ctx.assertTrue(DYNAMICP == new DynamicPermission);
    });
    
		tests
	}
	
	
}