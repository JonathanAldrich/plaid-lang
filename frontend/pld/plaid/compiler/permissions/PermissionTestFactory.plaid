/**
 * Copyright (c) 2010 The Plaid Group (see AUTHORS file)
 * 
 * This file is part of Plaid Programming Language.
 *
 * Plaid Programming Language is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 *  Plaid Programming Language is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Plaid Programming Language.  If not, see <http://www.gnu.org/licenses/>.
 */

package plaid.compiler.permissions;

import plaid.lang.testing.TestFactory;
import plaid.lang.testing.Test;

import plaid.collections.makeLinkedList;

state PermissionTestFactory case of TestFactory {
	
	method unique List<unique Test> createTests() {
		val tests = makeLinkedList();
		val test = fn(name,body) => { tests.add(mktest(name, body)) };
		var t = new None;  //dummy variable to get around match scoping bug
		val borrowed = makeBorrowedPerm(IMM,UNIQUE,3);
		val borrowedS1 = makeBorrowedPerm(SHARED,UNIQUE,1);
    val borrowedI3 = borrowed;

		/********** UNIQUE *************/
		test("Unique is writable", fn(ctx) => {
			ctx.assertTrue(UNIQUE.isWritable());
		});
		
		test("Unique guarantees state", fn(ctx) => {
			ctx.assertTrue(UNIQUE.guaranteesState());
		});
		
		test("Unique ==", fn(ctx) => { 
      ctx.assertTrue(UNIQUE == UNIQUE);
      ctx.assertFalse(UNIQUE == IMMUTABLE);
      ctx.assertFalse(UNIQUE == SHARED);
      ctx.assertFalse(UNIQUE == LOCALIMMUTABLE);
      ctx.assertFalse(UNIQUE == LOCALSHARED);
      ctx.assertFalse(UNIQUE == NONEP);
      ctx.assertFalse(UNIQUE == DYNAMICP);
      ctx.assertFalse(UNIQUE == borrowed);
      ctx.assertFalse(UNIQUE == borrowedS1);
    });
    
    test("Unique toString", fn(ctx) => { 
      ctx.assertTrue(UNIQUE.toString().equals("unique"));
    });
		
		test("Unique splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (UNIQUE.splitPerm(UNIQUE)) {
					case Some {
						match (UNIQUE.splitPerm(UNIQUE).value) {
							case NonePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(IMMUTABLE)) {
					case Some {
						match (UNIQUE.splitPerm(IMMUTABLE).value) {
							case ImmutablePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(SHARED)) {
					case Some {
						match (UNIQUE.splitPerm(SHARED).value) {
							case SharedPermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(NONEP)) {
					case Some {
						match (UNIQUE.splitPerm(NONEP).value) {
							case UniquePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(LOCALIMMUTABLE)) {
					case Some {
						t = UNIQUE.splitPerm(LOCALIMMUTABLE).value;
						match (t) {
							case BorrowedPermission { 
								ifElse( t.thePerm == IMMUTABLE &&
										t.originalPerm == UNIQUE &&
										t.splitCount == 1 )
								{ true }
								{ false }
							}
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(LOCALSHARED)) {
					case Some {
						t = UNIQUE.splitPerm(LOCALSHARED).value;
						match (t) {
							case BorrowedPermission { 
								ifElse( t.thePerm == SHARED &&
										t.originalPerm == UNIQUE &&
										t.splitCount == 1 )
								{ true }
								{ false }
							}
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (UNIQUE.splitPerm(borrowed)) {
					case Some { false }
					case None { true }
				}
			);
		  ctx.assertTrue(
        match (UNIQUE.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Unique returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (UNIQUE.returnPerm(UNIQUE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(IMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(SHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(LOCALIMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(LOCALSHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(borrowed)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(NONEP)) {
				case Some {
					match (UNIQUE.returnPerm(NONEP).value) {
						case UniquePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (UNIQUE.returnPerm(DYNAMICP)) {
        case Some { false }
        case None { true }
      });
		});

		test("Unique isSubPermOf", fn(ctx) => {	
			ctx.assertTrue(UNIQUE.isSubPermOf(UNIQUE));
			ctx.assertTrue(UNIQUE.isSubPermOf(IMMUTABLE));
			ctx.assertTrue(UNIQUE.isSubPermOf(SHARED));
			ctx.assertTrue(UNIQUE.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertTrue(UNIQUE.isSubPermOf(LOCALSHARED));
			ctx.assertTrue(UNIQUE.isSubPermOf(NONEP));
			ctx.assertFalse(UNIQUE.isSubPermOf(borrowed));
			ctx.assertFalse(UNIQUE.isSubPermOf(DYNAMICP));
		});
		
		test("Unique greatestLowerBound", fn (ctx) => {
			t = UNIQUE.greatestLowerBound(UNIQUE);
			ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
			t = UNIQUE.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
			t = UNIQUE.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = UNIQUE.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = UNIQUE.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = UNIQUE.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = UNIQUE.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = UNIQUE.greatestLowerBound(borrowed);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
			
		});
		
		/********** IMMUTABLE *************/
		
		test("Immutable is not writable", fn(ctx) => {
			ctx.assertFalse(IMM.isWritable());
		});
		
		test("Immutable guarantees state", fn(ctx) => {
			ctx.assertTrue(IMM.guaranteesState());
		});
		
		test("Immutable ==", fn(ctx) => { 
      ctx.assertFalse(IMM == UNIQUE);
      ctx.assertTrue(IMM == IMMUTABLE);
      ctx.assertFalse(IMM == SHARED);
      ctx.assertFalse(IMM == LOCALIMMUTABLE);
      ctx.assertFalse(IMM == LOCALSHARED);
      ctx.assertFalse(IMM == NONEP);
      ctx.assertFalse(IMM == borrowed);
      ctx.assertFalse(IMM == DYNAMICP);
    });
    
    test("Immutable toString", fn(ctx) => { 
      ctx.assertTrue(IMM.toString().equals("immutable"));
    });
		
		test("Immutable splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (IMM.splitPerm(UNIQUE)) {
					case Some { false }
					case None { true }
				}
			);
			t = IMM.splitPerm(IMMUTABLE);
			ctx.assertTrue(
				match (t ) {
					case Some {
						match (t.value) {
							case ImmutablePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (IMM.splitPerm(SHARED)) {
					case Some { false }
					case None { true }
				}
			);
			t = IMM.splitPerm(LOCALIMMUTABLE);
			ctx.assertTrue(
				match (t) {
					case Some {
						match (t.value) {
							case ImmutablePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (IMM.splitPerm(LOCALSHARED)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (IMM.splitPerm(NONEP)) {
					case Some {
						match (IMM.splitPerm(NONEP).value) {
							case ImmutablePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (IMM.splitPerm(borrowedI3)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
        match (IMM.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Immutable returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (IMM.returnPerm(UNIQUE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (IMM.returnPerm(IMMUTABLE)) {
				case Some {
					match (IMM.returnPerm(IMMUTABLE).value) {
						case ImmutablePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (IMM.returnPerm(SHARED)) {
				case Some { false }
				case None { true }
			});
			t = IMM.returnPerm(LOCALIMMUTABLE);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case ImmutablePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (IMM.returnPerm(LOCALSHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (IMM.returnPerm(borrowed)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (IMM.returnPerm(NONEP)) {
				case Some {
					match (IMM.returnPerm(NONEP).value) {
						case ImmutablePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (IMM.returnPerm(DYNAMICP)) {
        case Some { false }
        case None { true }
      });
		});

		test("Immutable isSubPermOf", fn(ctx) => {	
			ctx.assertFalse(IMM.isSubPermOf(UNIQUE));
			ctx.assertTrue(IMM.isSubPermOf(IMMUTABLE));
			ctx.assertTrue(IMM.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertFalse(IMM.isSubPermOf(SHARED));
			ctx.assertFalse(IMM.isSubPermOf(LOCALSHARED));
			ctx.assertFalse(IMM.isSubPermOf(borrowed));
			ctx.assertTrue(IMM.isSubPermOf(NONEP));
			ctx.assertFalse(IMM.isSubPermOf(DYNAMICP));
		});
		
		test("Immutable greatestLowerBound", fn (ctx) => {
      t = IMM.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = IMM.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = IMM.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = IMM.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = IMM.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = IMM.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = IMM.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = IMM.greatestLowerBound(borrowed);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
    });
		
		/********** SHARED *************/
		
		test("Shared is writable", fn(ctx) => {
			ctx.assertTrue(SHARED.isWritable());
		});
		
		test("Shared does not guarantee state", fn(ctx) => {
			ctx.assertFalse(SHARED.guaranteesState());
		});
		
		test("Shared ==", fn(ctx) => { 
      ctx.assertFalse(SHARED == UNIQUE);
      ctx.assertFalse(SHARED == IMMUTABLE);
      ctx.assertTrue(SHARED == SHARED);
      ctx.assertFalse(SHARED == LOCALIMMUTABLE);
      ctx.assertFalse(SHARED == LOCALSHARED);
      ctx.assertFalse(SHARED == NONEP);
      ctx.assertFalse(SHARED == borrowed);
      ctx.assertFalse(SHARED == DYNAMICP);
    });
    
    test("Shared toString", fn(ctx) => { 
      ctx.assertTrue(SHARED.toString().equals("shared"));
    });
		
		test("Shared splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (SHARED.splitPerm(UNIQUE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (SHARED.splitPerm(SHARED)) {
					case Some {
						match (SHARED.splitPerm(SHARED).value) {
							case SharedPermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (SHARED.splitPerm(IMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			t = SHARED.splitPerm(LOCALSHARED);
			ctx.assertTrue(
				match (t) {
					case Some {
						match (t.value) {
							case SharedPermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (SHARED.splitPerm(LOCALIMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (SHARED.splitPerm(NONEP)) {
					case Some {
						match (SHARED.splitPerm(NONEP).value) {
							case SharedPermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (SHARED.splitPerm(borrowedI3)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
        match (SHARED.splitPerm(borrowedS1)) {
          case Some { false }
          case None { true }
        }
      );
			ctx.assertTrue(
        match (SHARED.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Shared returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (SHARED.returnPerm(UNIQUE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (SHARED.returnPerm(SHARED)) {
				case Some {
					match (SHARED.returnPerm(SHARED).value) {
						case SharedPermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (SHARED.returnPerm(IMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			t = SHARED.returnPerm(LOCALSHARED);
			ctx.assertTrue(
				match (t) {
					case Some {
						match (t.value) {
							case SharedPermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
				match (SHARED.returnPerm(LOCALIMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (SHARED.returnPerm(borrowed)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(match (SHARED.returnPerm(NONEP)) {
				case Some {
					match (SHARED.returnPerm(NONEP).value) {
						case SharedPermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(
        match (SHARED.returnPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Shared isSubPermOf", fn(ctx) => {	
			ctx.assertFalse(SHARED.isSubPermOf(UNIQUE));
			ctx.assertFalse(SHARED.isSubPermOf(IMMUTABLE));
			ctx.assertFalse(SHARED.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertTrue(SHARED.isSubPermOf(SHARED));
			ctx.assertTrue(SHARED.isSubPermOf(LOCALSHARED));
			ctx.assertFalse(SHARED.isSubPermOf(borrowed));
			ctx.assertTrue(SHARED.isSubPermOf(NONEP));
			ctx.assertFalse(SHARED.isSubPermOf(DYNAMICP));
		});
		
		test("Shared greatestLowerBound", fn (ctx) => {
		  t = SHARED.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = SHARED.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = SHARED.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      t = SHARED.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = SHARED.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      t = SHARED.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      t = SHARED.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = SHARED.greatestLowerBound(borrowed);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
		});
		
		/********** NONE *************/
		
		test("None is not writable", fn(ctx) => {
			ctx.assertFalse(NONEP.isWritable());
		});
		
		test("None does not guarantee state", fn(ctx) => {
			ctx.assertFalse(NONEP.guaranteesState());
		});
		
		test("None ==", fn(ctx) => { 
      ctx.assertFalse(NONEP == UNIQUE);
      ctx.assertFalse(NONEP == IMMUTABLE);
      ctx.assertFalse(NONEP == SHARED);
      ctx.assertFalse(NONEP == LOCALIMMUTABLE);
      ctx.assertFalse(NONEP == LOCALSHARED);
      ctx.assertTrue(NONEP == NONEP);
      ctx.assertFalse(NONEP == borrowed);
      ctx.assertFalse(NONEP == DYNAMICP);
    });
    
    test("None toString", fn(ctx) => { 
      ctx.assertTrue(NONEP.toString().equals("none"));
    });
		
		test("None splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (NONEP.splitPerm(UNIQUE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (NONEP.splitPerm(SHARED)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (NONEP.splitPerm(IMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (NONEP.splitPerm(LOCALSHARED)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (NONEP.splitPerm(LOCALIMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (NONEP.splitPerm(NONEP)) {
					case Some {
						match (NONEP.splitPerm(NONEP).value) {
							case NonePermission { true }
							default { false }
						}
					}
					case None { false }
				}
			);
			ctx.assertTrue(
        match (NONEP.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("None returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (NONEP.returnPerm(UNIQUE)) {
				case Some {
					match (NONEP.returnPerm(UNIQUE).value) {
						case UniquePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (NONEP.returnPerm(SHARED)) {
				case Some {
					match (NONEP.returnPerm(SHARED).value) {
						case SharedPermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (NONEP.returnPerm(IMMUTABLE)) {
				case Some {
					match (NONEP.returnPerm(IMMUTABLE).value) {
						case ImmutablePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			t = NONEP.returnPerm(LOCALSHARED);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case LocalPermission { 
							ifElse ( t.value.thePerm == SHARED )
							{ true }
							{ false }
						}
						default { false }
					} 
				}
				case None { false }
			});
			t = NONEP.returnPerm(LOCALIMMUTABLE);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case LocalPermission { 
							ifElse ( t.value.thePerm == IMMUTABLE )
							{ true }
							{ false }
						}
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (NONEP.returnPerm(NONEP)) {
				case Some {
					match (NONEP.returnPerm(NONEP).value) {
						case NonePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (NONEP.returnPerm(borrowed)) {
				case Some { false }
				case None { true }
			});
			ctx.assertFalse(match (NONEP.returnPerm(DYNAMICP)) {
        case Some { false }
        case None { true }
      });
		});

		test("None isSubPermOf", fn(ctx) => {	
			ctx.assertFalse(NONEP.isSubPermOf(UNIQUE));
			ctx.assertFalse(NONEP.isSubPermOf(IMMUTABLE));
			ctx.assertFalse(NONEP.isSubPermOf(SHARED));
			ctx.assertFalse(NONEP.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertFalse(NONEP.isSubPermOf(LOCALSHARED));
			ctx.assertFalse(NONEP.isSubPermOf(borrowed));
			ctx.assertTrue(NONEP.isSubPermOf(NONEP));
			ctx.assertFalse(NONEP.isSubPermOf(DYNAMICP));
		});
		
		test("NONE greatestLowerBound", fn (ctx) => {
      t = NONEP.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = NONEP.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = NONEP.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == SHARED } case None { false } });
      t = NONEP.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == LOCALIMMUTABLE } case None { false } });
      t = NONEP.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == LOCALSHARED } case None { false } });
      t = NONEP.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == NONEP } case None { false } });
      t = NONEP.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = NONEP.greatestLowerBound(borrowed);
      ctx.assertTrue(match(t) { case Some { t.value == borrowed } case None { true } });
    });
		
		
		/********** LOCAL *************/
		
		test("Local is writable if underlying permission is", fn(ctx) => {
			ctx.assertFalse(LOCALIMMUTABLE.isWritable());
			ctx.assertTrue(LOCALSHARED.isWritable());
		});
		
		test("Local guarantees state if underlying permission does", fn(ctx) => {
			ctx.assertTrue(LOCALIMMUTABLE.guaranteesState());
			ctx.assertFalse(LOCALSHARED.guaranteesState());
		});
		
		test("Local ==", fn(ctx) => { 
      ctx.assertFalse(LOCALIMMUTABLE == UNIQUE);
      ctx.assertFalse(LOCALIMMUTABLE == IMMUTABLE);
      ctx.assertFalse(LOCALIMMUTABLE == SHARED);
      ctx.assertTrue(LOCALIMMUTABLE == LOCALIMMUTABLE);
      ctx.assertFalse(LOCALIMMUTABLE == LOCALSHARED);
      ctx.assertFalse(LOCALIMMUTABLE == NONEP);
      ctx.assertFalse(LOCALIMMUTABLE == borrowed);
      ctx.assertFalse(LOCALIMMUTABLE == DYNAMICP);
    });
    
    test("Local toString", fn(ctx) => { 
      ctx.assertTrue(LOCALIMMUTABLE.toString().equals("local immutable"));
      ctx.assertTrue(LOCALSHARED.toString().equals("local shared"));
    });
		
		test("Local splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (LOCALIMMUTABLE.splitPerm(UNIQUE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (LOCALIMMUTABLE.splitPerm(SHARED)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (LOCALIMMUTABLE.splitPerm(IMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (LOCALIMMUTABLE.splitPerm(LOCALSHARED)) {
					case Some { false }
					case None { true }
				}
			);
			t = LOCALIMMUTABLE.splitPerm(LOCALIMMUTABLE);
			ctx.assertTrue(
				match (t) {
					case Some { 
						match (t.value) {
							case BorrowedPermission {
								t.value.thePerm == IMMUTABLE &&
								t.value.originalPerm == LOCALIMMUTABLE &&
								t.value.splitCount == 1
							}
							default { false }
						}
 					}
					case None { false }
				}
			);
			t = LOCALIMMUTABLE.splitPerm(NONEP);
			ctx.assertTrue(
				match (t) {
					case Some {
						match (t.value) {
							case LocalPermission { t.value.thePerm == IMMUTABLE }
							default { false }
						}
					}
					case None { false }
				}
			);
      ctx.assertTrue(
        match (LOCALIMMUTABLE.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Local returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(UNIQUE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(IMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(SHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(LOCALIMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(LOCALSHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(borrowed)) {
				case Some { false }
				case None { true }
			});
			t = LOCALIMMUTABLE.returnPerm(NONEP);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case LocalPermission { t.value.thePerm == IMMUTABLE }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (LOCALIMMUTABLE.returnPerm(DYNAMICP)) {
        case Some { false }
        case None { true }
      });
		});

		test("local isSubPermOf", fn(ctx) => {	
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(UNIQUE));
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(IMMUTABLE));
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(SHARED));
			ctx.assertTrue(LOCALIMMUTABLE.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(LOCALSHARED));
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(borrowed));
			ctx.assertTrue(LOCALIMMUTABLE.isSubPermOf(NONEP));
			ctx.assertFalse(LOCALIMMUTABLE.isSubPermOf(DYNAMICP));
			
		});
		
		test("Local greatestLowerBound", fn (ctx) => {
      t = LOCALIMMUTABLE.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == IMMUTABLE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == LOCALIMMUTABLE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { t.value == UNIQUE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == LOCALIMMUTABLE } case None { false } });
      t = LOCALIMMUTABLE.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = LOCALIMMUTABLE.greatestLowerBound(borrowedI3);
      ctx.assertTrue(match(t) { case Some { t.value == borrowedI3 } case None { true } });
      t = LOCALIMMUTABLE.greatestLowerBound(borrowedS1);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
		});
	
			/********** Borrowed *************/
		
		//declared above - here for ease of looking
		//val borrowedS1 = makeBorrowedPerm(SHARED,UNIQUE,1);
		//val borrowedI3 = makeBorrowedPerm(IMM,UNIQUE,3); (same as borrowed)
		
		test("Borrowed is writable if underlying permission is", fn(ctx) => {
			ctx.assertFalse(borrowedI3.isWritable());
			ctx.assertTrue(borrowedS1.isWritable());
		});
		
		test("Borrowed guarantees state if underlying permission does", fn(ctx) => {
			ctx.assertTrue(borrowedI3.guaranteesState());
			ctx.assertFalse(borrowedS1.guaranteesState());
		});
    
    test("Borrowed ==", fn(ctx) => { 
      ctx.assertFalse(borrowed == UNIQUE);
      ctx.assertFalse(borrowed == IMMUTABLE);
      ctx.assertFalse(borrowed == SHARED);
      ctx.assertFalse(borrowed == LOCALIMMUTABLE);
      ctx.assertFalse(borrowed == LOCALSHARED);
      ctx.assertFalse(borrowed == NONEP);
      ctx.assertTrue(borrowed == borrowed);
      ctx.assertFalse(borrowed == borrowedS1);
      ctx.assertFalse(borrowed == DYNAMICP);
    });
    
    test("borrowed toString", fn(ctx) => { 
      ctx.assertTrue(borrowedS1.toString().equals("borrow(local shared, unique, 1)"));
      ctx.assertTrue(borrowedI3.toString().equals("borrow(local immutable, unique, 3)"));
    });
		
		test("Borrowed splitting", fn(ctx) => {
			//splitting
			ctx.assertTrue(
				match (borrowedS1.splitPerm(UNIQUE)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (borrowedS1.splitPerm(SHARED)) {
					case Some { false }
					case None { true }
				}
			);
			ctx.assertTrue(
				match (borrowedS1.splitPerm(IMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			t = borrowedS1.splitPerm(LOCALSHARED);
			ctx.assertTrue(
				match (t) {
					case Some { 
						match (t.value) {
							case BorrowedPermission { 
								t.value.thePerm == SHARED &&
								t.value.originalPerm == UNIQUE &&
								t.value.splitCount == 2
							}
							default { false }
						}
					}
					case None { true }
				}
			);
			ctx.assertTrue(
				match (borrowedS1.splitPerm(LOCALIMMUTABLE)) {
					case Some { false }
					case None { true }
				}
			);
			t = borrowedS1.splitPerm(NONEP);
			ctx.assertTrue(
				match (t) {
					case Some {
						match (t.value) {
							case BorrowedPermission { 
								t.value.thePerm == SHARED &&
								t.value.originalPerm == UNIQUE &&
								t.value.splitCount == 1
							}
							default { false }
						}
					}
					case None { false }
				}
			);
		  ctx.assertTrue(
        match (borrowedS1.splitPerm(DYNAMICP)) {
          case Some { false }
          case None { true }
        }
      );
		});
		
		test("Borrowed returns", fn(ctx) => {
			//joining
			ctx.assertTrue(match (borrowedS1.returnPerm(UNIQUE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (borrowedS1.returnPerm(IMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (borrowedS1.returnPerm(SHARED)) {
				case Some { false }
				case None { true }
			});
			ctx.assertTrue(match (borrowedS1.returnPerm(LOCALIMMUTABLE)) {
				case Some { false }
				case None { true }
			});
			t = borrowedI3.returnPerm(LOCALIMMUTABLE);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case BorrowedPermission { 
								t.value.thePerm == IMMUTABLE &&
								t.value.originalPerm == UNIQUE &&
								t.value.splitCount == 2
							}
						default { false }
					} 
				}
				case None { false }
			});
			t = borrowedS1.returnPerm(LOCALSHARED);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case UniquePermission { true }
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (borrowedS1.returnPerm(borrowed)) {
				case Some { false }
				case None { true }
			});
			t = borrowedS1.returnPerm(NONEP);
			ctx.assertTrue(match (t) {
				case Some {
					match (t.value) {
						case BorrowedPermission { 
								t.value.thePerm == SHARED &&
								t.value.originalPerm == UNIQUE &&
								t.value.splitCount == 1
							}
						default { false }
					} 
				}
				case None { false }
			});
			ctx.assertTrue(match (borrowedS1.returnPerm(DYNAMICP)) {
        case Some { false }
        case None { true }
      });
		});

		test("borrow isSubPermOf", fn(ctx) => {	
			ctx.assertFalse(borrowedS1.isSubPermOf(UNIQUE));
			ctx.assertFalse(borrowedS1.isSubPermOf(IMMUTABLE));
			ctx.assertFalse(borrowedS1.isSubPermOf(SHARED));
			ctx.assertFalse(borrowedS1.isSubPermOf(LOCALIMMUTABLE));
			ctx.assertTrue(borrowedS1.isSubPermOf(LOCALSHARED));
			ctx.assertFalse(borrowedS1.isSubPermOf(borrowed));
			ctx.assertTrue(borrowedS1.isSubPermOf(NONEP));
			ctx.assertFalse(borrowedS1.isSubPermOf(DYNAMICP));
		});
		
		test("borrow greatestLowerBound", fn (ctx) => {
      t = borrowedI3.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = borrowedI3.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = borrowedI3.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = borrowedI3.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { t.value == borrowedI3 } case None { false } });
      t = borrowedI3.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = borrowedI3.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { t.value == borrowedI3 } case None { false } });
      t = borrowedI3.greatestLowerBound(DYNAMICP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = borrowedI3.greatestLowerBound(borrowedI3);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = borrowedI3.greatestLowerBound(borrowedS1);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
    });
	
	   /********** Dynamic *************/
    
    test("Dynamic is writable", fn(ctx) => {
      ctx.assertTrue(DYNAMICP.isWritable());
    });
    
    test("Dynamic does not guarantee state", fn(ctx) => {
      ctx.assertFalse(DYNAMICP.guaranteesState());
    });
    
    test("Dynamic ==", fn(ctx) => { 
      ctx.assertFalse(DYNAMICP == UNIQUE);
      ctx.assertFalse(DYNAMICP == IMMUTABLE);
      ctx.assertFalse(DYNAMICP == SHARED);
      ctx.assertFalse(DYNAMICP == LOCALIMMUTABLE);
      ctx.assertFalse(DYNAMICP == LOCALSHARED);
      ctx.assertFalse(DYNAMICP == NONEP);
      ctx.assertFalse(DYNAMICP == borrowed);
      ctx.assertTrue(DYNAMICP == new DynamicPermission);
    });
    
    test("Dynamic toString", fn(ctx) => { 
      ctx.assertTrue(DYNAMICP.toString().equals("dynamic"));
    });
    
    test("Dynamic splitting", fn(ctx) => {
      //splitting
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(UNIQUE)) {
          case Some { false }
          case None { true }
        }
      );
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(SHARED)) {
          case Some { false }
          case None { true }
        }
      );
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(IMMUTABLE)) {
          case Some { false }
          case None { true }
        }
      );
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(LOCALIMMUTABLE)) {
          case Some { false }
          case None { true }
        }
      );
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(NONEP)) {
          case Some { false }
          case None { true }
        }
      );
      ctx.assertTrue(
        match (DYNAMICP.splitPerm(borrowed)) {
          case Some { false }
          case None { true }
        }
      );
      t = DYNAMICP.splitPerm(new DynamicPermission);
      ctx.assertTrue(
        match (t) {
          case Some { t.value == DYNAMICP }
          case None { false }
        }
      );
    });
    
    test("Dynamic returns", fn(ctx) => {
      //joining
      ctx.assertTrue(match (DYNAMICP.returnPerm(UNIQUE)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(IMMUTABLE)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(SHARED)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(LOCALIMMUTABLE)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(LOCALSHARED)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(NONEP)) {
        case Some { false }
        case None { true }
      });
      ctx.assertTrue(match (DYNAMICP.returnPerm(borrowed)) {
        case Some { false }
        case None { true }
      });
      t = DYNAMICP.returnPerm(new DynamicPermission);
      ctx.assertTrue(match (t) {
        case Some {
          t.value == DYNAMICP 
        }
        case None { false }
      });
    });

    test("dynamic isSubPermOf", fn(ctx) => { 
      ctx.assertFalse(DYNAMICP.isSubPermOf(UNIQUE));
      ctx.assertFalse(DYNAMICP.isSubPermOf(IMMUTABLE));
      ctx.assertFalse(DYNAMICP.isSubPermOf(SHARED));
      ctx.assertFalse(DYNAMICP.isSubPermOf(LOCALIMMUTABLE));
      ctx.assertFalse(DYNAMICP.isSubPermOf(LOCALSHARED));
      ctx.assertFalse(DYNAMICP.isSubPermOf(borrowed));
      ctx.assertFalse(DYNAMICP.isSubPermOf(NONEP));
      ctx.assertTrue(DYNAMICP.isSubPermOf(new DynamicPermission));
    });
    
    test("dynamic greatestLowerBound", fn (ctx) => {
      t = DYNAMICP.greatestLowerBound(UNIQUE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(IMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(SHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(LOCALIMMUTABLE);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(LOCALSHARED);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(NONEP);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(borrowedI3);
      ctx.assertTrue(match(t) { case Some { false } case None { true } });
      t = DYNAMICP.greatestLowerBound(DYNAMICP);
      java.lang.System.out.println("*******" + t.toString());
      ctx.assertTrue(match(t) { case Some { t.value == DYNAMICP } case None { false } });
    });
    
		/********** Globals *************/
		
		test("global definitions", fn(ctx) => { 
      ctx.assertTrue(UNIQUE == new UniquePermission);
      ctx.assertTrue(IMMUTABLE == new ImmutablePermission);
      ctx.assertTrue(IMM == new ImmutablePermission);
      ctx.assertTrue(SHARED == new SharedPermission);
      ctx.assertTrue(NONEP == new NonePermission);
      ctx.assertTrue(LOCALIMMUTABLE == new LocalPermission { val thePerm = new ImmutablePermission; });
      ctx.assertTrue(LOCALIMM == new LocalPermission { val thePerm = new ImmutablePermission; });
      ctx.assertTrue(LOCALSHARED == new LocalPermission { val thePerm = new SharedPermission; });
      ctx.assertTrue(DYNP == new DynamicPermission);
      ctx.assertTrue(DYNAMICP == new DynamicPermission);
    });
		tests
	}
	
	
}