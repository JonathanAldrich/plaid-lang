package plaid.compiler.permissions;

import plaid.compiler.AP;

/**
 *	Shared Permission
 */
state SharedPermission case of SymmetricPerm {
	var /* Option<ID> */ groupID = new None;
	
	//shared references can write
	method immutable Boolean isWritable()[immutable SharedPermission >> void] { true }

	//shared references do not have their state guaranteed
	method immutable Boolean guaranteesState()[immutable SharedPermission >> void] { false }

	method immutable Boolean ==(immutable Permission >> void p2)[immutable SharedPermission >> void] {
		match(p2) {
			case SharedPermission { true }
			default { false }
		};
	}
	
	method immutable String toString()[immutable SharedPermission >> void] {
	    match (groupID) {
	        case Some {
	            "shared<" + groupID.value.name.toString() +">"
	        }
		    default {
		        "shared"
		    }
		};
	}

	// Shared can only be split up into more shared or pure or none or dyn
	method unique Option<immutable Permission> 
			splitPerm(immutable Permission >> void p2)
					 [immutable SharedPermission >> void] 
	{
		match(p2) {
			case SharedPermission { makeSome(this) }	// shared => shared/shared
			case LocalPermission {
				ifElse(p2.thePerm == SHARED)
					{ makeSome(SHARED) }
					{ new None }
			}
			case NonePermission { makeSome(this) }		// shared => none/shared
			default { new None }
			
			//unused cases
			//case PurePermission { makeSome(this) }	// shared => pure/shared
			//case DynPermission { createSOme(this) }	// shared => Dyn/shared  KBN - is this correct?
		};
	}
	
	//shared can coexist with dyn, shared, none, and pure permissions
	method unique Option<immutable Permission> 
			join(immutable Permission >> void p2)
				[immutable SharedPermission >> void] 
	{
		match (p2) {
			case SharedPermission { makeSome(this) } //shared/shared => shared
			case LocalPermission {
				ifElse(p2.thePerm == SHARED)
					{ makeSome(SHARED) }
					{ new None }
			}
			case NonePermission { makeSome(this) } //shared/none => shared
			default { new None }  //everything else can't coexist - return nothing
			
			//unused cases
			//case DynPermission { makeSome(p2) } //shared/dyn => dyn
			//case PurePermission { makeSome(this) } //shared/pure => shared
		}	
	}
	
	//you can join two shareds into unique or full permissions, otherwise, you better
	//be joining to shared
	method unique Option<immutable Permission> 
		joinTo(immutable Permission >> void p2, immutable Permission >> void target)
			  [immutable SharedPermision >> void] 
	{
		match (target) {
			case UniquePermission { //share + share = Unique
				match (p2) {
					case SharedPermission { makeSome(target) }
					default { new None }
				}
			}
			case SharedPermission { this.join(p2) }
			default { new None }
		
			//unused cases
			//case FullPermission { //share + share = Full
			//	match (p2) {
			//		case SharedPermission { makeSome(target) }
			//		default { new None }
			//	}
			//}
		}
		
		
	}
	
	//Immutable is at the same level on different branches of the lattice than Shared,
	//in this case the upper bound is FULL
	method immutable Permission leastUpperBound(immutable Permission p2)[immutable SharedPermission] {
		match (p2) {
			case UniquePermission { UNIQUE }
			case ImmutablePermission { UNIQUE }
			case SharedPermission { SHARED }
			case LocalPermission {
				ifElse(p2.thePerm == SHARED)
					{ SHARED }
					{ UNIQUE }
			}
			case NonePermission { SHARED }
			default { UNIQUE }  //error - not a permission, default to UNIQUE - KBN error handling?
			
			//unused cases
			//case DynPermission { DYNP }
			//case FullPermission { FULL }
			//case ImmutablePermission { FULL }
			//case PurePermission { SHARED }
		}
	}
	
	//Immutable is at the same level on different branches of the lattice than Shared,
	//in this case the lower bound is PURE
	method immutable Permission greatestLowerBound(immutable Permission p2)[immutable SharedPermission] {
		match (p2) {
			case UniquePermission { SHARED }
			case ImmutablePermission { NONEP }
			case SharedPermission { SHARED }
			case LocalPermission {
				ifElse(p2.thePerm == SHARED)
					{ LOCALSHARED }
					{ NONEP }
			}
			case NonePermission { NONEP }
			default { NONEP } //error - not a permission, default to NONEP - KBN error handling? 
			
			//unused cases
			//case PurePermission { PURE }
			//case FullPermission { SHARED }
			//case ImmutablePermission { PURE }
			//case DynPermission { DYNP }
		}
	}
}