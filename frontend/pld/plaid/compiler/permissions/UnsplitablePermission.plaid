package plaid.compiler.permissions;

import plaid.compiler.*;

state UnsplitablePermission  case of BasePermission {
    val immutable Permission thePerm;

	/**
	 * Returns true if the permission allows writing to object
	 * fields.  Returns false otherwise.
	 */
	method immutable Boolean isWritable() {
	    this.thePerm.isWriteable();
	}
	
	
	/**
	 * Returns true if the permission guarantees that the state of
	 * of the object does not change and false otherwise.  
	 * Weak permissions (none, pure, shared) return false, 
	 * and strong permissions (unique, full, immutable) return true
	 */
	method immutable Boolean guaranteesState() {
	    this.thePerm.guaranteeState();
	}
	
	/**
	 * Compares this permission to the specified permission.  If they are of the
	 * same type, then they are considered equal.  Returns true if the two
	 * permissions are equal and false otherwise.
	 */
	method immutable Boolean ==(immutable Permission p2) {
	    this.thePerm == p2 
	}
	
	/** 
	 * for Printing
	 */
	method immutable String toString() {
	    "Unsplitable(" + this.thePerm.toString() + ")"
	}
	
	/**
	 * determines whether the current permission can be split into
	 * the requested source permission.  
	 * If it can, the function returns Some(residualPerm),
	 *    where newPerm is the residue after splitting.  
	 * If it cannot, it returns None
       *   Preconditions:
       *     None
       *   Errors:
       *     None
       */
	method immutable ?Permission splitPerm(immutable Permission p2) {
	    DEBUG(DEBUG_PRIO_LOW, "<UnsplitablePermission> splitPerm(" + p2.toString() + ")");
	    match ( p2 ) {
	        case NonePermission { this } 
	        default { unit }  
	    }
	}
	
	/**
	 * determines the result of returning a permission to the
	 * receiving Permission.  The typechecker should ensure that
	 * this is well-formed via other checks.  Thus, it must
	 * be possible to join the permissions, in other words,
	 * it must be possible to split the incoming permission
	 * with the receiving permission as the residue.
	 *   Preconditions:
	 *     exists p' such that p'.split(p2) == Some(this)
	 *   Errors:
	 *     If precondition not met, error will be called
	 */
	method immutable ?Permission returnPerm(immutable Permission p2) {
	    this.thePerm.returnPerm(p2)
	}

	/**
	 * returns true if this permission is a subpermission of the permission p2
	 *   in other words, the receiver is "stronger" than p2
	 *   or, anything that can be pulled from p2 can be pulled from this permission
	 *   or, p2 can be pulled from this permission
	 * returns false otherwise
	 *   Preconditions:
   *     None
   *   Errors:
   *     None
	 */
	override method immutable Boolean isSubPermOf(immutable Permission p2) {
        match ( p2 ) {
            case NonePermission { true } 
            default { false }
        }
	}

  /**
   *  the least upper bound, p, of p1 and p2 is the strongest permission that 
   *  can be pulled from p1 and p2.  
   *  In other words, p is a superpermission of p1 and p2
   * 
   *  Because of dynamic permissions, we do not form a join bounded lattice, so we cannot always
   *  guarantee a least upper bound.  If one is a superpermission of the other, then we can
   *  return that.  Otherwise, as long as we don't have a dynamic permission and a
   *  non-dynamic permission, we must have one borrowed permission.  If the other
   *  permission is on the same "branch", then a local is returned, otherwise we
   *  return a none permission.
   *   Preconditions:
   *     None
   *   Errors:
   *     None
   */
  override method immutable ?Permission leastUpperBound(immutable Permission p2) {
      this.thePerm.leastUpperBound(p2)                                           
  }
}