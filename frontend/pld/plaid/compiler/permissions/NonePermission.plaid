package plaid.compiler.permissions;

import plaid.compiler.AP;


/**
 *	None permission
 */
state NonePermission case of AP {
	
	// none provides no write abilities
	method immutable Boolean isWritable()[immutable NonePermission >> void] { false }

	// none does not guarantee the state of the object
	method immutable Boolean guaranteesState()[immutable NonePermission >> void] { false }
	
	method immutable Boolean ==(immutable Permission >> void p2)[immutable NonePermission >> void] {
		match(p2) {
			case NonePermission { true }
			default { false }
		};
	}
	
	method immutable String toString()[immutable Permission >> void] {
		"none"
	}

	//Only None can be split from None
	method /*unique Option<immutable Permission>*/ splitPerm(immutable Permission >> void p2)
															[immutable NonePermission >> void] 
	{
		match(p2) {
			// none => none/none
			case NonePermission { makeSome(this) }
			default { new None }
			
			//unused cases
			//case DynPermission { makeSome(this) }  // none => dyn/none KBN - correct?
		};
	}
	
	//none can coexist with anything, so always just take the other permission
	method unique Option<immutable Permission> join(immutable Permission >> void p2)
													   [immutable NonePermission >> void] {
		makeSome(p2);
	}
	
	//can only join to None
	method unique Option<immutable Permission> 
		joinTo(immutable Permission >> void p2, immutable Permission >> void target)
			  [immutable NonePermission >> void] 
	{
		ifElse (p2 == target) 
			{ makeSome(target) }
			{ new None }
	}
	
	//upper bound will always be the other permission
	method immutable Permission leastUpperBound(immutable Permission >>void p2)[immutable NonePermission >> void] {
		match (p2) {
			case UniquePermission { UNIQUE }
			case ImmutablePermission { IMMUTABLE }
			case SharedPermission { SHARED }
			case LocalPermission { p2 }
			case NonePermission { NONEP }
			default { UNIQUE; }  //error - not a permission, default to UNIQUE - KBN error handling?

			//unused cases
			//case DynPermission { DYNP }
			//case FullPermission { FULL }
			//case PurePermission { PURE }
		}
	}
	
	//lower bound will always be None (or Dyn)
	method immutable Permission greatestLowerBound(immutable Permission p2)[immutable NonePermission] {
		match (p2) {
			case UniquePermission { NONEP }
			case ImmutablePermission { NONEP }
			case SharedPermission { NONEP }
			case LocalPermission { NONEP }
			case NonePermission { NONEP }
			default { NONEP } //error - not a permission, default to NONEP - KBN error handling? 
			
			//unused cases
			//case DynPermission { DYNP }
			//case FullPermission { NONEP }
			//case PurePermission { NONEP }
		}	
	}
}