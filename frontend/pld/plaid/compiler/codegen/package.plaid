package plaid.compiler.codegen;

import java.lang.StringBuilder;
import java.lang.System;

import plaid.ast.parsed.*;

import plaid.compiler.COMPILER_CONFIGURATION;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_LOW;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.DEBUG_PRIO_HIGH;
import plaid.compiler.symbolForAST;

import plaid.compiler.symbol.*;


import plaid.fastruntime.NamingConventions;
import plaid.fastruntime.util.FileGen;

method LOG (immutable String msg) {
	DEBUG(DEBUG_PRIO_LOW, "<CodeGenPass> " + msg);
}

method ERROR(immutable String msg) {
	plaid.compiler.ERROR("<CodeGenPass> INTERNAL ERROR: " + msg);
}

method codegenCU(immutable ParsedCompilationUnit node) {
	val idGen = new IdGen;
	LOG("generating code for ParsedCompilationUnit");
	val qiPackage = node.packageName.identifiers.map( fn(id) => { id.name } );
	val packageString = makeSeperatedString(qiPackage, ".");
	val stringbuilderlist = node.decls.map( fn(item) => {val result = StringBuilder.new(); result} );
	val declsSbList = node.decls.zip(stringbuilderlist);
	//first = decl, second = StringBuilder
	declsSbList.map( fn(item) => { codegenTopLevelDecl(item.first(), packageString, item.second(), idGen); } );
	stringbuilderlist.map( fn(item) => { DEBUG(DEBUG_PRIO_HIGH, item.toString()); } );
	
	//create directories and files for java source output
	declsSbList.map( fn(item) => {
		val declName = item.first().name.name;
		val sep = System.getProperty("file.separator");
		val qiDir = makeSeperatedString(qiPackage, sep);
		val outputDir = COMPILER_CONFIGURATION().tempDir;
		val codeString = item.second().toString();
		FileGen.createOutputFile(declName, outputDir, codeString, qiDir);
	} );
}

method codegenTopLevelDecl(immutable ParsedDecl node, immutable String packageName, shared StringBuilder sb, shared IdGen idgen) {
	LOG("generating code for Top Level Decl");
	match(node) {
		case ParsedConcreteMethodDecl {
			LOG("generating code for top-level concrete method decl");
			sb.append("package " + packageName + ";\n");
			sb.append("public class " + node.name.name + "{\n");
			
			// begin invoke method
			sb.append("public static plaid.fastruntime.PlaidObject invoke$plaid(");
			val addComma = fn(arg1) => { arg1.name.name + "," };
			if (node.arguments.size() > 0) {
				val argStringList = node.arguments.map(addComma);
				val argString = argStringList.reduce("", fn(s1,s2) => {s1 + s2});
				sb.append(argString.substring(0, argString.length() - 1));
			};
			sb.append(") {\n");
			
			//method body
			codegenMethodBody(node.body, sb, idgen);
			
			sb.append("}\n"); // end invoke method
			
			//begin main method
			if(node.arguments.size() == 0) {
				sb.append("public static void main(String[] args) {\n");
				sb.append("invoke$plaid();\n");
				sb.append("}\n"); // end main method
			};
			
			sb.append("}\n"); // end class
		}
		case ParsedConcreteFieldDecl {
			LOG("generating code for top-level concrete field decl");
		}
		case ParsedConcreteStateDecl {
			LOG("generating code for top-level concrete state decl");
		}
		case ParsedConcreteStateDecl {
			LOG("generating code for top-level concrete state val decl");
		}
		default {
			ERROR("Found unexpected node as top-level decl");
		}
	}
}
	
method codegenMethodBody(immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen) {
	LOG("generating code for method body block expression");
	val y = idgen.getId();
	sb.append("plaid.fastruntime.PlaidObject " + y + ";\n");
	node.statements.map( fn(item) => { codegenStmt(item, sb, idgen, y); } );
	sb.append("return " + y + ";\n");
}

method codegenStmt(immutable Stmt node, shared StringBuilder sb, shared IdGen idgen, 
		immutable String y) {
	LOG("generating code for statement");
	match(node) {
		case ParsedDereference {
			LOG("generating code for dereference");
			//TODO: check if left is a Java class
			val symbolLeft = symbolForAST(node.left);
			val symbolRight = symbolForAST(node.right);
			match(symbolLeft.value) {
				case JavaClassSymbol {
					match(symbolRight) {
						case Some {
							match(symbolRight.value) {
								case JavaStaticFieldSymbol  {
									sb.append(y + " = plaid.fastruntime.Util.JAVA_GEN.createPlaidJavaObject(" + node.left.name + "." + node.right.name + ");\n");
								}
								default {
									ERROR("Unexpected symbol for the right side of a dereference of Java class");
								}
							}
						}
						default {
							ERROR("Found no symbol for the right side of a dereference of Java class.");
						}
					}
				}
				default {
					ERROR("Unexpected Symbol type for left of dereference.");
				}
			}			
		}
		case ParsedApplication {
			LOG("generating code for application");
			val argumentExpr = node.argument;
			match(argumentExpr) {
				case ParsedArgumentExpr {
					val yList = argumentExpr.args.map( fn(item) => { idgen.getId(); } );
					yList.map( fn(yItem) => { sb.append("plaid.fastruntime.PlaidObject " + yItem + ";\n"); } );
					val argsYs = argumentExpr.args.zip(yList);
					argsYs.map( fn(item) => { codegenStmt(item.first(), sb, idgen, item.second()); } );
					val functionExpr = node.function;
					match(functionExpr) {
						case ParsedDereference {
							//generate code for method call
							
							// preliminaries
							val receiverExpr = functionExpr.left;
							var receiverString = "";
							match(receiverExpr) {
								case ParsedIdentifier {
									// primitive case, no need to delegate to further code generation
									receiverString = receiverExpr.name;
								}
								default {
									// complex case need to delegate to codegenStmt
									receiverString = idgen.getId();
									sb.append("plaid.fastruntime.PlaidObject " + receiverString + ";\n");
									codegenStmt(receiverExpr, sb, idgen, receiverString);
								}
							};
							val methodId = functionExpr.right;
							
							//assign result to y
							sb.append(y + " = ");
							
							//generate interface
							//plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(methodId.name, yList.size());
							
							//cast
							sb.append("(");
							sb.append("(" + NamingConventions.getGeneratedInterfaceName(methodId.name, yList.size()) + ")");
							sb.append(receiverString);
							sb.append(".getDispatch()");
							sb.append(")");
							//.<METHOD_NAME>(<ARGS>)
							sb.append("." + methodId.name + "(");
							sb.append(receiverString + ","); // receiver
							sb.append(makeSeperatedString(yList, ",")); //normal arguments
							sb.append(");\n");
						} 
						case ParsedIdentifier {
							//function application
							sb.append(y +  " = " + functionExpr.name + ".invoke$plaid(");
							sb.append(makeSeperatedString(yList, ","));
							sb.append(");\n");
						}
						default {
							ERROR("<CodeGenPass> Unexpected node type as function field of Application node");
						}
					}
				}
				default {
					ERROR("<CodeGenPass> Unexpected node type as argument field of Application node");
				}
			};
		}
		case ParsedStringLiteral {
			sb.append(y + " = plaid.fastruntime.Util.string(\"" + node.value + "\");\n");
		}
		default {
			LOG("generating code for " + node.nodeName());
			sb.append(node.nodeName() + "\n");
		}
	}
}
	
method makeSeperatedString(immutable List<String> stringList, immutable String sep) {
	val addSep = fn(s1, s2) => {s1 + sep + s2};
	val toReturn = stringList.reduceLeft("", addSep);
	toReturn.substring(1,toReturn.length());
}