package plaid.compiler.codegen;

import java.lang.StringBuilder;
import java.lang.System;

import plaid.ast.parsed.*;

import plaid.compiler.COMPILER_CONFIGURATION;
import plaid.compiler.AEMINIUM_MODE;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_LOW;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.DEBUG_PRIO_HIGH;
import plaid.compiler.symbolForAST;

import plaid.compiler.symbol.*;

import plaid.compiler.aeminium.*;

import plaid.collections.LinkedList;
import plaid.collections.makeLinkedList;

import plaid.fastruntime.NamingConventions;
import plaid.fastruntime.CompilerUtil;
import plaid.fastruntime.util.FileGen;

method LOG (immutable String msg) {
	DEBUG(DEBUG_PRIO_LOW, "<CodeGenPass> " + msg);
}

//TODO: update errors
method ERROR(immutable Token t, immutable String msg) {
	plaid.compiler.report_ERROR(t," INTERNAL ERROR: " + msg, "", "CodeGenPass");
}

state CodeGenOps {
    method codegenCU(immutable CodeGenOps ops, unique Job job, immutable ParsedCompilationUnit node);
    method codegenTopLevelDecl(immutable CodeGenOps ops, immutable ParsedDecl node, immutable String packageName, shared StringBuilder sb, shared IdGen idgen);
    method codegenInnerDecl(immutable CodeGenOps ops, immutable ParsedDecl node,  shared StringBuilder sb, shared IdGen idgen, isAnonymous);
    method codegenMethodBody(immutable CodeGenOps ops, immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen);
    method codegenStmtBlock(immutable CodeGenOps ops, immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen, immutable String y);
    method codegenStmt(immutable CodeGenOps ops, immutable Stmt node, shared StringBuilder sb, shared IdGen idgen, immutable String y);
    method codegenLambda(immutable CodeGenOps ops, args, body, sb, idgen, y);
    method codegenStateExpr(immutable CodeGenOps ops, immutable ParsedStateExpr node, shared StringBuilder sb, shared IdGen idgen, 
                            immutable String st);
    method codegenObjectValue(immutable CodeGenOps ops, immutable ParsedStateExpr node, shared StringBuilder sb, shared IdGen idgen, 
                            immutable String fullyQualifiedClassName, immutable String ov, immutable String hashMapId);
    method codegenApplication(immutable CodeGenOps ops, immutable ParsedExpr functionExpr, immutable List args, 
	    					  shared StringBuilder sb, shared IdGen idgen, 
		    				  immutable String y);
	method void codegenMain(immutable String methodName, unique StringBuilder sb);
	method void createLocalVariable(immutable String name, unique StringBuilder sb, immutable Boolean isFinal);
	method void setLocalVariable(immutable String varName, immutable String value, unique StringBuilder sb);
	method immutable String getLocalVariable(immutable String varName);
	method void codegenMemberBodies(immutable CodeGenOps ops, immutable ParsedStateExpr node, shared StringBuilder sb, shared IdGen idgen);
}

method unique SequentialCodeGenOps makeSequentialCodeGenOps() {
    new SequentialCodeGenOps;
}

state SequentialCodeGenOps {
    method codegenCU(immutable CodeGenOps ops, unique Job job, immutable ParsedCompilationUnit node) {
        val idGen = new IdGen;
        LOG("generating code for ParsedCompilationUnit");
        val qiPackage = node.packageName.identifiers.map( fn(id) => { id.name } );
        val sep = System.getProperty("file.separator");
        val packageDir = makeSeperatedString(qiPackage, sep);
        val packageString = makeSeperatedString(qiPackage, ".");
        val stringbuilderlist = node.decls.map( fn(item) => {val result = StringBuilder.new(); result} );
        val declsSbList = node.decls.zip(stringbuilderlist);
        
        //first = decl, second = StringBuilder
        declsSbList.map( fn(item) => {
           //builtin annotation means no code-generation
           val immutable Boolean isBuiltIn = 
              item.first().annotations.exists(
              fn (annotation) => { annotation.name.name == NamingConventions.BUILTIN_ANNOTATION }
              );
           
           match (isBuiltIn) {
              case True { // if it is built in do not generate code
                item.second().append(NamingConventions.BUILTIN_ANNOTATION);
              }
              case False {
                val declName = NamingConventions.getGeneratedIdentifier(item.first().name.name);
           
                val outputDir = COMPILER_CONFIGURATION().tempDir;
                ops.codegenTopLevelDecl(ops, item.first(), packageString, item.second(), idGen); 
              }
            }
        } );
        
        stringbuilderlist.map( fn(item) => { DEBUG(DEBUG_PRIO_HIGH, item.toString()); } );
        
        //create directories and files for java source output
        declsSbList.map( fn(item) => {
            val declName = NamingConventions.getGeneratedIdentifier(item.first().name.name);
            val outputDir = COMPILER_CONFIGURATION().tempDir;
            val codeString = item.second().toString();
            match (codeString == NamingConventions.BUILTIN_ANNOTATION) {
                case True { /* no op*/ }  //builtin means no code should be generated
                case False {
                    FileGen.createOutputFile(declName, outputDir, codeString, packageDir);
            
                    // generated file name to list of generated files
                    val immutable String path = outputDir + java.lang.System.getProperty("file.separator") + packageDir + System.getProperty("file.separator") + declName + ".java";
                    job.addGeneratedFile(path);
                }
            };
        } );
    }
    
    method codegenTopLevelDecl(immutable CodeGenOps ops, immutable ParsedDecl node, immutable String packageName, shared StringBuilder sb, shared IdGen idgen) {
        LOG("generating code for Top Level Decl");
        match(node) {
            case ParsedConcreteMethodDecl {
                LOG("generating code for top-level concrete method decl");
                
                sb.append("package " + packageName + ";\n");
                
                sb.append("public class " + NamingConventions.getGeneratedIdentifier(node.name.name) + "{\n");
                
                // begin invoke method
                sb.append("public static plaid.fastruntime.PlaidObject " + NamingConventions.GENERATED_METHOD_NAME + "(");
                
                val argStringList = node.arguments.map(fn(arg1) => {"final plaid.fastruntime.PlaidObject " + arg1.name.name});
                sb.append(makeSeperatedString(argStringList, ","));
                sb.append(") {\n");
                
                //method body
                ops.codegenMethodBody(ops, node.body, sb, idgen);
                
                sb.append("}\n"); // end invoke method
                
                //begin main method
                if(node.arguments.size() == 0) {
                    ops.codegenMain(NamingConventions.GENERATED_METHOD_NAME, sb);
                };
                
                sb.append("}\n"); // end class
            }
            case ParsedConcreteFieldDecl {
                LOG("generating code for top-level concrete field decl");
                
                sb.append("package " + packageName + ";\n");			
                sb.append("public class " + NamingConventions.getGeneratedIdentifier(node.name.name) + "{\n");
            
                val fieldName = NamingConventions.GENERATED_FIELD_NAME;
            
                sb.append("public static final plaid.fastruntime.PlaidObject " + fieldName + ";\n");
                sb.append("static {\n");
                
                // field initializer body
                val exprVarName = idgen.getId();
                ops.createLocalVariable(exprVarName, sb, true);
                ops.codegenStmt(ops, node.expression, sb, idgen, exprVarName);
                //sb.append("" + fieldName + " = " + exprVarName + ";\n");
                sb.append("" + fieldName + " = " + ops.getLocalVariable(exprVarName) + ";\n");
                
                sb.append("}\n"); //end static block
                sb.append("}\n"); //end class
                
            }
            case ParsedConcreteStateDecl {
                LOG("generating code for top-level concrete state decl");
                sb.append("package " + packageName + ";\n");
                sb.append("public class " + NamingConventions.getGeneratedIdentifier(node.name.name) + "{\n");
                
                val fullyQualifiedClassName = packageName + "." + node.name.name;
                val sbStateInitializer = java.lang.StringBuilder.new();
                
                //generate tag
                val tag = java.util.UUID.randomUUID().toString();
                
                //add parent if exists
                val parentObjectValueId = idgen.getId();
                sbStateInitializer.append("final plaid.fastruntime.ObjectValue "+ parentObjectValueId + " = ");
                match(node.caseOf) {
                    case ParsedEmptyQualifiedIdentifier {
                        sbStateInitializer.append("null;\n");  //no parent
                    }
                    case ParsedQualifiedIdentifier {
                        val caseofSymbolOption = symbolForAST(node.caseOf);
                        match(caseofSymbolOption) {
                            case Some {
                                val caseofSymbol = caseofSymbolOption.getValue();
                                match(caseofSymbol) {
                                    case StateSymbol {
                                        val caseOfFQN = " " + NamingConventions.getGeneratedFQN(caseofSymbol.getFQN());
                                        sbStateInitializer.append(caseOfFQN + "." + NamingConventions.GENERATED_STATE_NAME + ".getObjectValue();\n");
                                    }
                                    default{
                                        ERROR(node.caseOf.token, "Case of identifier symbol is unexpected value, " + caseOfSymbol.symbolType() + ".");
                                    }
                                }
                            } case None {
                                ERROR(node.caseOf.token, "no symbol for case of identifier");
                            }
                        }
                    }
                };
                
                //generate state binding
                val innerObjectValueId = idgen.getId();
                //map to put any dynamic definitions in
                val hashMapId = idgen.getId();
                sbStateInitializer.append("java.util.Map<java.lang.String, plaid.fastruntime.PlaidLambda> " + hashMapId + " = ");
                sbStateInitializer.append("new java.util.HashMap<java.lang.String, plaid.fastruntime.PlaidLambda>();\n");
                sbStateInitializer.append("final plaid.fastruntime.ObjectValue "+ innerObjectValueId + ";\n");
                codegenObjectValue(ops, node.stateBinding, sbStateInitializer, idgen, fullyQualifiedClassName, innerObjectValueId, hashMapId, true);
                
                //generate code for member bodies
                ops.codegenMemberBodies(ops, node.stateBinding, sb, idgen);
                
                //create dimension value to represent the state
                val stateObjectValueId = idgen.getId();
                sbStateInitializer.append("final plaid.fastruntime.ObjectValue "+ stateObjectValueId + " = ");
                sbStateInitializer.append("plaid.fastruntime.Util.getDimensionValue(\"" + tag + "\", " +  innerObjectValueId + ", " + parentObjectValueId + ");\n");
                
                
                sbStateInitializer.append("" + NamingConventions.GENERATED_STATE_NAME + " = plaid.fastruntime.Util.makeDynState(" + stateObjectValueId + ", " + hashMapId + ");\n");
                
                //generate static field containing PlaidState
                sb.append("public static final plaid.fastruntime.PlaidState " + NamingConventions.GENERATED_STATE_NAME + ";\n");
                sb.append("static {\n");
                sb.append(sbStateInitializer.toString());
                sb.append("}\n");
                
                sb.append("}\n"); // end class
            }  // end case ParsedConcreteStateDecl
            default {
                ERROR(node.token, "Found unexpected node as top-level decl");
            }
        }
    }
    
    
    
    method codegenInnerDecl(immutable CodeGenOps ops, immutable ParsedDecl node,  shared StringBuilder sb, shared IdGen idgen, isAnonymous) {
        match (node) {
            case ParsedConcreteMethodDecl {
                // begin invoke method
                match(isAnonymous) {
                    case False{
                        val methodName = NamingConventions.getGeneratedIdentifier(node.name.name);
                        sb.append("public static plaid.fastruntime.PlaidObject " + methodName + "(");
                    }
                    case True {
                        sb.append("@Override\n");
                        sb.append("public plaid.fastruntime.PlaidObject invoke$plaid(");
                    }
                };
                sb.append("final plaid.fastruntime.PlaidObject " + NamingConventions.GENERATED_THIS);
                if(node.arguments.size() > 0) {
                    sb.append(",");
                    val argsList = node.arguments.map(fn(arg1) => {" final plaid.fastruntime.PlaidObject " + arg1.name.name});
                    sb.append(makeSeperatedString(argsList,","));
                };
                
                sb.append(") {\n");
                
                //method body
                ops.codegenMethodBody(ops, node.body, sb, idgen);
                
                sb.append("}\n"); // end invoke method
            }
            case ParsedConcreteFieldDecl {
                // generate static field to contain initialization code for fields.
                // begin invoke method
                match(isAnonymous) { 
                    case False {
                        sb.append("public static plaid.fastruntime.PlaidFieldInitializer " + node.name.name + ";\n"); // field declaration
                        
                        //preliminiaries
                        sb.append("static {\n");
                        sb.append(node.name.name + " = new plaid.fastruntime.PlaidFieldInitializer() { \n");
                    }
                    default { 
                        // no-op 
                    }
                };
                sb.append("@Override\n");
                sb.append("public plaid.fastruntime.PlaidObject invoke$plaid() {\n");
                
                //body of invoke, generate code for expression, return the value
                val exprVarName = idgen.getId();
                ops.createLocalVariable(exprVarName, sb, true);
                ops.codegenStmt(ops, node.expression, sb, idgen, exprVarName);
                sb.append("return " + ops.getLocalVariable(exprVarName) + ";\n");
                
                //finalize
                sb.append("}\n"); // end invoke$plaidmethod
                match(isAnonymous) { 
                    case False {
                        sb.append("};\n"); // end FieldInitializer anonymous class
                        sb.append("}\n"); // end static
                    }
                    default { 
                        // no-op 
                    }
                }; 
            }
            case ParsedAbstractFieldDecl {
                //no-op
            }
            case ParsedAbstractMethodDecl {
                //no-op
            }
            default {
                ERROR(node.token, "Found unexpected node as inner decl");
            }
        }
    }
        
    method codegenMethodBody(immutable CodeGenOps ops, immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen) {
        LOG("generating code for method body block expression");
        ifElse(node.statements.size() > 0) {
            val y = idgen.getId();
            ops.createLocalVariable(y, sb, true);
            ops.codegenStmtBlock(ops, node, sb, idgen, y);
            sb.append("return " + ops.getLocalVariable(y) + ";\n");
        } {
            sb.append("return plaid.fastruntime.Util.unit();\n");
        }
    }
    
    method codegenStmtBlock(immutable CodeGenOps ops, immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen, immutable String y) {
        LOG("generating code for case body block expression");
        ifElse(node.statements.size() > 0) {
            //node.statements.map( fn(item) => { ops.codegenStmt(ops, item, sb, idgen, y); } );
            var stmtCount = 0;
            while { stmtCount < node.statements.size() - 1 }{
                // create 
                val yy = idgen.getId();
                ops.createLocalVariable(yy, sb, true);
                val stmt = node.statements.get(stmtCount).value;
                ops.codegenStmt(ops, stmt, sb, idgen, yy);
                stmtCount = stmtCount + 1;
            };
            
            // create last statement with provided variable
            val stmt = node.statements.get(stmtCount).value;
            stmtCount = stmtCount + 1;
            ops.codegenStmt(ops, stmt, sb, idgen, y);
        } {
            ops.setLocalVariable(y, "plaid.fastruntime.Util.unit()", sb);
        }
    }
    
    method codegenStmt(immutable CodeGenOps ops, immutable Stmt node, shared StringBuilder sb, shared IdGen idgen, 
            immutable String y) {
        LOG("generating code for statement '" + node.nodeName() + "'");
        match(node) {
            case ParsedAtomicBlock {
                ERROR(node.token, "Enable AEminium to use atomic blocks");
            }
            case ParsedMethodCall { //TODO: factor out commonalities with application
                val receiverExpr = node.receiver;
                val argumentExpr = node.argument;
                val methodId = node.methodId;
                val yList = argumentExpr.args.map( fn(item) => { idgen.getId(); } );
                val methodSymbolOpt = symbolForAST(methodId);
                match (methodSymbolOpt) {
                    case Some {
                        val methodSymbol = methodSymbolOpt.value;
                        match (methodSymbol) {
                            case JavaConstructorSymbol {  //Java constructors and static methods handled the same
                                codegenJavaStaticMethod(ops, node.receiver, methodSymbol, yList, sb, y);
                            }
                            case JavaStaticMethodSymbol {
                                codegenJavaStaticMethod(ops, node.receiver, methodSymbol, yList, sb, y);
                            }
                            default {
                                ERROR(functionExpr.token, "method id unexpectedly has a symbol " + methodSymbol.symbolType());
                            }
                        }
                    }
                    case None {
						val methodName = NamingConventions.getGeneratedIdentifier(methodId.name);
					
						yList.map( fn(yItem) => { ops.createLocalVariable(yItem, sb, true) });
						val argsYs = argumentExpr.args.zip(yList);
						argsYs.map( fn(item) => { ops.codegenStmt(ops, item.first(), sb, idgen, item.second()); } );
							
						//generate code for method call
						 var receiverString = idgen.getId();
						ops.createLocalVariable(receiverString, sb, true);
						ops.codegenStmt(ops, receiverExpr, sb, idgen, receiverString);
												
						//generate interface
						plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(methodName, yList.size());
			
						val methodInterfaceName = NamingConventions.getGeneratedInterfaceName(methodName, yList.size());
						val dispatch = ops.getLocalVariable(receiverString) + ".getDispatch()";
												
						//cast
						val ysb = java.lang.StringBuilder.new();
						ysb.append("(");
						ysb.append("(" + methodInterfaceName + ")");
						ysb.append(dispatch);
						ysb.append(")");
						//.<METHOD_NAME>(<RECEIVER>,<ARGS>)
						ysb.append("." + methodName + "(");
						ysb.append(ops.getLocalVariable(receiverString)); // receiver
						if(yList.size() > 0) {
							ysb.append(",");
						};
						ysb.append(makeSeperatedString(yList.map(fn (yItem) => { ops.getLocalVariable(yItem)}), ",")); //normal arguments
						ysb.append(")");
						
						// assign result to y
						ops.setLocalVariable(y, ysb.toString(), sb);
					}
				}
            }
            case ParsedDereference {
                LOG("generating code for dereference");
                val symbolLeftOption = symbolForAST(node.left);
                val symbolRightOption = symbolForAST(node.right);
                var symbolLeft = "";
                val javaDeref = match(symbolLeftOption) {
                    case Some {
                        symbolLeft = symbolLeftOption.getValue();
                        match(symbolLeft) {
							case JavaClassSymbol {
								match(symbolRightOption) {
									case Some {
										match(symbolRightOption.getValue()) {
											case JavaStaticFieldSymbol  {
												val parent = symbolLeft.owner;
												val classFQN = symbolLeft.getFQN();
												ops.setLocalVariable(y, "plaid.fastruntime.Util.javaToPlaid(" + classFQN + "." + node.right.name + ")", sb);
											}
											case JavaStaticMethodSymbol {
												ERROR(node.token, "java methods cannot be dereferenced except as a part of an application/method call");
											}
											case JavaConstructorSymbol {
												ERROR(node.token, "java constructors cannot be dereferenced except as a part of an application/method call");
											}
											default {
												ERROR(node.token, "Unexpected symbol for the right side of a dereference of Java class");
											}
										}
									}
									default {
										ERROR(node.token, "Found no symbol for the right side of a dereference of Java class.");
									}
								};
								true
							}
							default { false }
						}			
                    }
                    case None { false }
                };
                match (javaDeref) {
                 	case False {
                 		// generated code for receiver expression
						val receiverId = idgen.getId();
						ops.createLocalVariable(receiverId, sb, true);
						ops.codegenStmt(ops, node.left, sb, idgen, receiverId);
						
						//getter preliminaries
						val getterName = NamingConventions.getGetterName(NamingConventions.getGeneratedIdentifier(node.right.name));
						plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(getterName, 0);
						val ifaceName = NamingConventions.getGeneratedInterfaceFullyQualifiedName(getterName, 0);
						
						//call getter and assign result to y
						val ysb = java.lang.StringBuilder.new();
						ysb.append("("); // parentheses around casted object
						ysb.append("(" + ifaceName + ")");
						ysb.append("" + ops.getLocalVariable(receiverId) + ".getDispatch()");
						ysb.append(")"); // end parentheses around casted object  
						ysb.append("." + getterName + "(" + ops.getLocalVariable(receiverId) + ")");
						ops.setLocalVariable(y, ysb.toString(), sb);
                 	}
                 	case True { /*code already generated -no op */ }
                }
            }
            case ParsedAssignment {
                //generate code for value to assign
            	val valueId = idgen.getId();
				ops.createLocalVariable(valueId, sb, true);
				ops.codegenStmt(ops, node.value, sb, idgen, valueId);
                
                match(node.target) {
                    case ParsedEmptyExpr { // assignment to local variable
						sb.append(node.field.name + ".value = " + ops.getLocalVariable(valueId) + ";\n");
						ops.setLocalVariable(y, "plaid.fastruntime.Util.unit()", sb);
                    }
                    default { // assignment to field of an object
                        //TODO: deal with assignment to java static fields, very unimportant use case
                        
                        // generated code for receiver expression
                        val receiverId = idgen.getId();
                        ops.createLocalVariable(receiverId, sb, true);
                        ops.codegenStmt(ops, node.target, sb, idgen, receiverId);
                        
                        val setterName = NamingConventions.getSetterName(NamingConventions.getGeneratedIdentifier(node.field.name));
                        plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(setterName, 1);
                        val ifaceName = NamingConventions.getGeneratedInterfaceFullyQualifiedName(setterName, 1);
                        val ysb = java.lang.StringBuilder.new();
                        ysb.append("("); // paretheses around casted object
                        ysb.append("(" + ifaceName + ")");
                        ysb.append("" + ops.getLocalVariable(receiverId) + ".getDispatch()");
                        ysb.append(")"); // end parentheses around casted object  
                        ysb.append("." + setterName + "(" + ops.getLocalVariable(receiverId) + ", " + ops.getLocalVariable(valueId) +")");
                        ops.setLocalVariable(y, ysb.toString(), sb);
                    }
                }
            }
            case ParsedApplication {
                LOG("generating code for application");
                val argumentExpr = node.argument;
                match(argumentExpr) {
                    case ParsedArgumentExpr {
                        ops.codegenApplication(ops, node.function, argumentExpr.args, sb, idgen, y);
                    }
                    default { 
                        val argList = makeLinkedList();
                        argList.add(argumentExpr);
                        ops.codegenApplication(ops, node.function, argList, sb, idgen, y);
                    }
                };
            }
            case ParsedStringLiteral {
                ops.setLocalVariable(y, "plaid.fastruntime.Util.string(\"" + node.value + "\")", sb);
            }
            case ParsedIntLiteral {
                ops.setLocalVariable(y, "plaid.fastruntime.Util.integer(" + node.value + ")", sb);
            }
            case ParsedDoubleLiteral {
                ops.setLocalVariable(y, "plaid.fastruntime.Util.float64(" + node.value + ")", sb);
            }
            case ParsedInfixOperatorExpr {
                //preliminaries
                val op = node.operator;
                val methodName = convertOpStringToMethodName(op.name);
                
                // generate code for receiver
                val receiverString = idgen.getId();
                ops.createLocalVariable(receiverString, sb, true);
                ops.codegenStmt(ops, node.left, sb, idgen, receiverString);
                
                //generate code for argument
                val argId = idgen.getId();
                ops.createLocalVariable(argId, sb, true);
                ops.codegenStmt(ops, node.right, sb, idgen, argId);
                
                //generate interface
                plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(methodName, 1);
                                
                //cast
                val ysb = java.lang.StringBuilder.new();
                ysb.append("(");
                ysb.append("(" + NamingConventions.getGeneratedInterfaceName(methodName, 1) + ")");
                ysb.append(receiverString);
                ysb.append(".getDispatch()");
                ysb.append(")");
                //.<METHOD_NAME>(<ARGS>)
                ysb.append("." + methodName + "(");
                ysb.append(ops.getLocalVariable(receiverString) + ","); // receiver
                ysb.append(ops.getLocalVariable(argId)); //normal arguments
                ysb.append(")");
                            
                //assign result to y
                ops.setLocalVariable(y, ysb.toString(), sb);
            }
            case ParsedUnaryOperatorExpr {
                //preliminaries
                val op = node.operator;
                val methodName = convertOpStringToMethodName(op.name);
                
                // generate code for receiver
                val receiverString = idgen.getId();
                ops.createLocalVariable(receiverString, sb, true);
                ops.codegenStmt(ops, node.expression, sb, idgen, receiverString);
                
                //generate interface
                plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(methodName, 0);
                                
                //cast
                val ysb = java.lang.StringBuilder.new();
                ysb.append("(");
                ysb.append("(" + NamingConventions.getGeneratedInterfaceName(methodName, 0) + ")");
                ysb.append(receiverString);
                ysb.append(".getDispatch()");
                ysb.append(")");
                //.<METHOD_NAME>(<ARGS>)
                ysb.append("." + methodName + "(");
                ysb.append(ops.getLocalVariable(receiverString) + ")"); // receiver only arg
                            
                //assign result to y
                ops.setLocalVariable(y, ysb.toString(), sb);
            }
            case ParsedVarDecl {
                
                //run the initializer
                val exprVarName = idgen.getId();
                ops.createLocalVariable(exprVarName, sb, true);
                ops.codegenStmt(ops, node.expr, sb, idgen, exprVarName);
                
                //create local variable (assignable if a var)
                match (node.specifier) {
                	case ParsedVarSpecifier {
                		sb.append("final plaid.fastruntime.PlaidAssignable " + node.id.name + " = ");
                		sb.append("new plaid.fastruntime.PlaidAssignable();\n");
                		sb.append(node.id.name + ".value = " + ops.getLocalVariable(exprVarName) + ";\n");
                		
                	}
                	case ParsedValSpecifier {
						ops.createLocalVariable(node.id.name, sb, true);
						ops.setLocalVariable(node.id.name, ops.getLocalVariable(exprVarName), sb);
                	}
                };
                
            	//return unit
                ops.setLocalVariable(y, "plaid.fastruntime.Util.unit()",sb);
            }
            case ParsedIdentifier {
                // need to ensure that this is never called if ParsedIdentifier refers to a JavaClass
                // we cannot assign java class value to PlaidObject variable
                val symbolOption = symbolForAST(node);
                match(symbolOption) {
                    case Some {
                        val symbol = symbolOption.getValue();
                        match(symbol) {
                            case JavaClassSymbol {
                                ERROR(node.token, "Identifier cannot refer to Java class in ParsedIdentifier case of codegenStmt.");
                            }
                            case VariableSymbol {
								LOG("Testing if " + node.name + " is a var");
                                val varName = match (node.name.equals("this")) {
                                    case True { NamingConventions.GENERATED_THIS; }
                                	case False {
										match (symbol.isVar()) {
											case True {
												node.name + ".value";
											}
											case False {
												node.name;
											}
										}
									}
                                };
                                
                                ops.setLocalVariable(y, ops.getLocalVariable(varName), sb);
                            }
                            case FieldSymbol {
                                val parentSymbol = symbol.owner;
                                match(parentSymbol) {
                                    case PackageSymbol {
                                        val ysb = java.lang.StringBuilder.new();
                                        ysb.append(parentSymbol.getFQN());
                                        ysb.append(".");
                                        ysb.append(NamingConventions.getGeneratedIdentifier(node.name));
                                        ysb.append("." + NamingConventions.GENERATED_FIELD_NAME);
                                        ops.setLocalVariable(y, ysb.toString(), sb);
                                    }
                                    default {
                                        ERROR(node.token, "Identifier's symbol is a field symbol, but parent is not a PackageSymbol instead it is, "+ parentSymbol.symbolType());
                                    }
                                }
                            }
                            case StateSymbol {
                                val stateFQN = NamingConventions.getGeneratedFQN(symbol.getFQN());
                                ops.setLocalVariable(y, stateFQN + "." + NamingConventions.GENERATED_STATE_NAME, sb);
                            }
                            case MethodSymbol {
                                ERROR(node.token, "Methods are not first class values, therefore this should not be called.");
                            }
                            default {
                                ERROR(node.token, "Identifier has unexpected symbol '" + symbol.symbolType() + "'.");
                            }
                        };
                    } case None {
                        ERROR(node.token, "No symbol found for identifier. (Identifier named " + node.name + ")");
                    }
                };
                
            }
            case ParsedNewInstance {
                val stateId = idgen.getId();
                sb.append("plaid.fastruntime.PlaidState " + stateId + ";\n");
                
                //codegen the state
                ops.codegenStateExpr(ops, node.stateExpr, sb, idgen, stateId);
                
                //instantiate the object
                ops.setLocalVariable(y, stateId + ".instantiate()", sb);
            }
            case ParsedStateChange {
                val stateId = idgen.getId();
                sb.append("plaid.fastruntime.PlaidState " + stateId + ";\n");
                
                //codegen the state
                ops.codegenStateExpr(ops, node.stateExpr, sb, idgen, stateId);
                
                val exprId = idgen.getId();
                sb.append("plaid.fastruntime.PlaidObject " + exprId + ";\n");
                
                //codegen the expression
                ops.codegenStmt(ops, node.expression, sb, idgen, exprId);
                
                //call change state on the object
                sb.append(exprId + ".changeState(" + stateId +");\n");
                ops.setLocalVariable(y, exprId, sb);
            }
            case ParsedMatch {
                LOG("generating code for match");
                val exprVarName = idgen.getId();
                ops.createLocalVariable(exprVarName, sb, true);
                ops.codegenStmt(ops, node.expression, sb, idgen, exprVarName);
                
                val caseStringList = new LinkedList;
                node.caseList.map(fn(c) => {
                    match(c) {
                        case ParsedPatternCase {
                            val patternSymbolOption = symbolForAST(c.pattern);
                            match(patternSymbolOption) {
                                case Some {
                                    
                                    val patternSymbol = patternSymbolOption.getValue();
                                    match (patternSymbol) {
                                        case StateSymbol {
                                            val caseSB = StringBuilder.new();
                                            caseSB.append("if(" + ops.getLocalVariable(exprVarName) + ".getDispatch().matches(");
                                            val patternFQN = "" + NamingConventions.getGeneratedFQN(patternSymbol.getFQN());
                                            caseSB.append(patternFQN + "." + NamingConventions.GENERATED_STATE_NAME + ".getTopTag())) {\n");
                                            val bodyVarName = idgen.getId();
                                            ops.createLocalVariable(bodyVarName, sb, true);
                                            ops.codegenStmtBlock(ops, c.body, caseSB, idgen, bodyVarName);
                                            ops.setLocalVariable(y, ops.getLocalVariable(bodyVarName), caseSB);
                                            caseSB.append("}\n");
                                            caseStringList.addLast(caseSB.toString());
                                        }
                                        case JavaClassSymbol {
                                        	val javaCaseSB = StringBuilder.new();
                                        	javaCaseSB.append("if((" + ops.getLocalVariable(exprVarName) + " instanceof ");
                                        	javaCaseSB.append("plaid.fastruntime.PlaidJavaObject) && ");
                                        	javaCaseSB.append("( ((plaid.fastruntime.PlaidJavaObject) ");
                                        	javaCaseSB.append(ops.getLocalVariable(exprVarName) + ").getJavaObject() instanceof ");
                                        	javaCaseSB.append(patternSymbol.clazz.getCanonicalName() + ")) { \n");
											val bodyVarName = idgen.getId();
                                            ops.createLocalVariable(bodyVarName, sb, true);
                                            ops.codegenStmtBlock(ops, c.body, javaCaseSB, idgen, bodyVarName);
                                            ops.setLocalVariable(y, ops.getLocalVariable(bodyVarName), javaCaseSB);
                                            javaCaseSB.append("}\n");
                                            caseStringList.addLast(javaCaseSB.toString());
                                        }
                                        default {
                                            ERROR(c.token, "Case pattern has unexpected symbol '" + patternSymbol.symbolType() + "'.");
                                        }
                                    }
                                }
                                case None {
                                    ERROR(c.token, "No symbol found for pattern in case.")
                                }			
                            };
                        }
                        case ParsedDefaultCase {
                            val caseSB = StringBuilder.new();
                            val bodyVarName = idgen.getId();
                            caseSB.append("{\n");
                            caseSB.append("plaid.fastruntime.PlaidObject " + bodyVarName + ";\n");
                            ops.codegenStmtBlock(ops, c.body, caseSB, idgen, bodyVarName);
                            ops.setLocalVariable(y, ops.getLocalVariable(bodyVarName), caseSB);
                            caseSB.append("}\n");
                            caseStringList.addLast(caseSB.toString());
                        }
                    };
                });
                val caseString = makeSeperatedString(caseStringList, "else ");
                sb.append(caseString);
                val lastCase = node.caseList.get(node.caseList.size() - 1).getValue();
                match (lastCase) {
                    case ParsedPatternCase {
                        sb.append("else {\n");
                        sb.append("throw new plaid.fastruntime.errors.PlaidIllegalOperationException(\"Pattern match exausted.\");\n");
                        sb.append("}\n");
                    }
                    case ParsedDefaultCase {
                        //no-op
                    }
                }
            }
            case ParsedBlockExpr {
                // this should not be called if parent node is ConcreteMethodDecl, Case, Split, o r
                //delegate to lambda expression code generator
                ops.codegenLambda(ops, new LinkedList, node, sb, idgen, y);
            }
            case ParsedLambda {
                ops.codegenLambda(ops, node.arguments, node.body, sb, idgen, y);
            }
            case ParsedUnitLiteral {
                ops.setLocalVariable(y, "plaid.fastruntime.Util.unit()", sb);
            }
            default {
                ERROR(node.token, "Unexpected stmt node type,"+ node.nodeName() +" encountered.");
            }
        }
    }
    
    method codegenLambda(immutable CodeGenOps ops, args, body, sb, idgen, y) {
        sb.append(y + " = new plaid.fastruntime.PlaidLambda$" + args.size() + "() {\n");
        sb.append("public plaid.fastruntime.PlaidObject invoke$plaid(");
        if(args.size() > 0) {
            val argList = args.map(fn(arg) => {"final plaid.fastruntime.PlaidObject " + arg.name.name});
            sb.append(makeSeperatedString(argList, ","));
        };
        sb.append(")"); // end argument list
        sb.append(" {\n"); // begin invoke method body
        match(body) {
            case ParsedBlockExpr {
                val toReturn = idgen.getId();
                ops.createLocalVariable(toReturn, sb, true);
                ops.codegenStmtBlock(ops, body, sb, idgen, toReturn);
                sb.append("return " + ops.getLocalVariable(toReturn) + ";\n");
            }
            default {
                val toReturn = idgen.getId();
                ops.createLocalVariable(toReturn, sb, true);
                ops.codegenStmt(ops, body, sb, idgen, toReturn);
                sb.append("return " + ops.getLocalVariable(toReturn) + ";\n");
            }
        };
        sb.append("}\n"); // end invoke method
        sb.append("};\n"); // end anonymous inner class
    }
    
    
    // this method should not be called from a top level state declaration, only from inside a method body or field iniatilizer
    // Precondition: st is declared in the generated Java code as a plaid.fastruntime.PlaidState
    method codegenStateExpr(immutable CodeGenOps ops, immutable ParsedStateExpr node, shared StringBuilder sb, shared IdGen idgen, 
                            immutable String st) {
        val staticState = match(node) {
            case ParsedStateRef {
                match(node.specializations.size() > 0) {
                    case True {
                        false;
                    }
                    case False {
                        val stateExprId = idgen.getId();
                        ops.createLocalVariable(stateExprId, sb, true);
                        ops.codegenStmt(ops, node.stateExpr, sb, idgen, stateExprId);
                
                        //cast to PlaidState
                        val unspecializedStateId = idgen.getId();
                        sb.append(st + " = (plaid.fastruntime.PlaidState)" + ops.getLocalVariable(stateExprId) + ";\n");
                        true;
                    }
                } // match(specializations.size() > 0)
            } // end case ParsedStateRef
            default {
                false;
            }
        }; // end match(node)
        match(staticState) {
            case True {
                // no hash-map needed, because state is statically declared
                // no-op
            }
            case False {
                val objectValueId = idgen.getId();
                sb.append("plaid.fastruntime.ObjectValue " + objectValueId + ";\n");

                //hash map for dynamically defined members
                val hashMapId = idgen.getId();
                sb.append("java.util.Map<java.lang.String, plaid.fastruntime.PlaidLambda> " + hashMapId + " = ");
                sb.append("new java.util.HashMap<java.lang.String, plaid.fastruntime.PlaidLambda>();\n");       
                        
                //codegen the state
                ops.codegenObjectValue(ops, node, sb, idgen, "", objectValueId, hashMapId, false);
                sb.append(st + " = plaid.fastruntime.Util.makeDynState(" + objectValueId + ", " + hashMapId + ");\n");
            }
        } // match(staticState) 
    } // end method codegenStateExpr
    
    // Precondition: ov is declared in the generated Java code as a plaid.fastruntime.ObjectValue
    // Precondition: if node is or contains a DeclList, then fullyQualifiedClassName must be the name of the class the state is compiled to
    method codegenObjectValue(immutable CodeGenOps ops, immutable ParsedStateExpr node, shared StringBuilder sb, shared IdGen idgen, 
    						immutable String fullyQualifiedClassName, immutable String ov, immutable String hashMapId, immutable Boolean isStatic) {
        match(node) {
            case ParsedStateRef {
                val stateExprId = idgen.getId();
                ops.createLocalVariable(stateExprId, sb, true);
                ops.codegenStmt(ops, node.stateExpr, sb, idgen, stateExprId);
                
                //cast to PlaidState
                val unspecializedStateId = idgen.getId();
                sb.append("plaid.fastruntime.PlaidState " + ops.getLocalVariable(unspecializedStateId) + " = (plaid.fastruntime.PlaidState)" + ops.getLocalVariable(stateExprId) + ";\n");
                
                val unspecializedObjectValue = idgen.getId();
                sb.append("final plaid.fastruntime.ObjectValue " + unspecializedObjectValue + " = " + unspecializedStateId + ".getObjectValue();\n");
                
                match(node.specializations.size() > 0) {
                    case True {   
                        
                        var currentObjectValueId = unspecializedObjectValue;
                        
                        node.specializations.map(
                            fn(declorstateop) => {
                                
                                match(declorstateop) {
                                    case ParsedStateOpRename {
                                    	val nextId = idgen.getId();
                                		sb.append("final plaid.fastruntime.ObjectValue " + nextId + " = ");
                                        sb.append(currentObjectValueId + ".rename(" + declorstateop.from.name + ", " + declorstateop.to.name + ");\n");
                                        currentObjectValueId = nextId;
                                    }
                                    case ParsedStateOpRemove {
                                    	val nextId = idgen.getId();
                                		sb.append("final plaid.fastruntime.ObjectValue " + nextId + " = ");
                                        sb.append(currentObjectValueId + ".remove(" + declorstateop.name.name + ");\n");
                                        currentObjectValueId = nextId;
                                    }
                                    default { //method or field
                                        val anonId = idgen.getId();
                                        sb.append("final plaid.fastruntime.PlaidLambda " + anonId + " = ");
                                        
                                        //decl
                                        match(declorstateop){
                                            case ParsedConcreteFieldDecl {
                                                sb.append("new plaid.fastruntime.PlaidLambda$0() {\n");
                                            }
                                            case ParsedConcreteMethodDecl {
                                                val lambdaSize = declorstateop.arguments.size() + 1;
                                                sb.append("new plaid.fastruntime.PlaidLambda$" + lambdaSize + "() {\n");
                                            }
                                        };
                                        ops.codegenInnerDecl(ops, declorstateop, sb, idgen, true);
                                        sb.append("};\n"); // end anonymous inner class
                                        
                                        sb.append(hashMapId + ".put(\"" + declorstateop.name.name + "\",");
                                        sb.append(anonId + ");\n");
                                        
                                        val nextId = idgen.getId();
                                		sb.append("final plaid.fastruntime.ObjectValue " + nextId + " = ");
                                        sb.append(currentObjectValueId + ".remove(\"" + declorstateop.name.name + "\");\n");
                                        val nextNextId = idgen.getId();
                                        sb.append("final plaid.fastruntime.ObjectValue " + nextNextId + " = ");
                                        
                                        match(declorstateop) {
                                            case ParsedConcreteMethodDecl {
                                                sb.append(nextId + ".addDynMethod(\"" + declorstateop.name.name + "\"," 
                                                    + declorstateop.arguments.size() + ");\n");
                                            }
                                            case ParsedConcreteFieldDecl {
                                                var settable = "";
                                                match(declorstateop.specifier) {
                                                    case ParsedValSpecifier {
                                                        settable = "false";
                                                    }
                                                    case ParsedVarSpecifier {
                                                        settable = "true";
                                                    }
                                                    case EmptySpecifier {
                                                        ABORT("TODO: lookup field specializer in specialized state");
                                                    }
                                                };
                                                sb.append(nextId + ".addDynField(" + settable + ", \"" + declorstateop.name.name + "\");\n");
                                            }
                                        };
                                        currentObjectValueId = nextNextId;
                                    }
                                }; //end match(declorstateop) 
                            }
                        ); //end map
                        
                        sb.append(ov + " = " + currentObjectValueId + ";\n");
                    }
                    case False {
                        ops.setLocalVariable(ov , ops.getLocalVariable(unspecializedObjectValue), sb);
                    }
                } // end match specializations.size()
            } // end case ParsedStateRef
            case ParsedDeclList {
                var currentObjectValueId = idgen.getId();
                sb.append("final plaid.fastruntime.ObjectValue " + currentObjectValueId + " = plaid.fastruntime.Util.getEmptyObjectValue();\n");
				match(isStatic) {
				    case True { 
        				node.decls.map( fn(innerDecl) => {
        					match(innerDecl) {
        						case ParsedConcreteMethodDecl {
        							val nextId = idgen.getId();
                            		sb.append("final plaid.fastruntime.ObjectValue " + nextId + " = ");
        							sb.append(currentObjectValueId + ".addMethod(\"" + innerDecl.name.name + "\"," 
        								+ innerDecl.arguments.size() + ",\"" + fullyQualifiedClassName + "\");\n");
        							currentObjectValueId = nextId;
        						}
        						case ParsedConcreteFieldDecl {
        							val nextId = idgen.getId();
                            		sb.append("final plaid.fastruntime.ObjectValue " + nextId + " = ");
        							var settable = "";
        							match(innerDecl.specifier) {
        								case ParsedValSpecifier {
        									settable = "false";
        								}
        								case ParsedVarSpecifier {
        									settable = "true";
        								}
        							};
        							sb.append(currentObjectValueId + ".addField(" + settable + ", \"" + innerDecl.name.name + "\"," 
        								+ "\"" + fullyQualifiedClassName + "\");\n");
        							currentObjectValueId = nextId;
        						}
        						case ParsedAbstractFieldDecl {
        							//no-op
        						}
        						case ParsedAbstractMethodDecl {
        							//no-op
        						}
        						default {
        							ERROR(innerDecl.token, "Unsupported inner decl ast node. Node name is " + innerDecl.nodeName());
        						}
        					}; //end match (innerDecl
        
        				} );
				    } // end case True (match isStatic)
				    case False {
				        node.decls.map(
                            fn(innerDecl) => {
                                val anonId = idgen.getId();
                                sb.append("final plaid.fastruntime.PlaidLambda " + anonId + " = ");
                                
                                //decl
                                match(innerDecl){
                                    case ParsedConcreteFieldDecl {
                                        sb.append("new plaid.fastruntime.PlaidLambda$0() {\n");
                                    }
                                    case ParsedConcreteMethodDecl {
                                        val lambdaSize = innerDecl.arguments.size() + 1;
                                        sb.append("new plaid.fastruntime.PlaidLambda$" + lambdaSize + "() {\n");
                                    }
                                };
                                ops.codegenInnerDecl(ops, innerDecl, sb, idgen, true);
                                sb.append("};\n"); // end anonymous inner class
                                
                                sb.append(hashMapId + ".put(\"" + innerDecl.name.name + "\",");
                                sb.append(anonId + ");\n");
                                
                                val nextId = idgen.getId();
                                sb.append("final plaid.fastruntime.ObjectValue " + nextId + " = ");
                                sb.append(currentObjectValueId + ".remove(\"" + innerDecl.name.name + "\");\n");
                                val nextNextId = idgen.getId();
                                sb.append("final plaid.fastruntime.ObjectValue " + nextNextId + " = ");
                                
                                match(innerDecl) {
                                    case ParsedConcreteMethodDecl {
                                        sb.append(nextId + ".addDynMethod(\"" + innerDecl.name.name + "\"," 
                                            + innerDecl.arguments.size() + ");\n");
                                    }
                                    case ParsedConcreteFieldDecl {
                                        var settable = "";
                                        match(innerDecl.specifier) {
                                            case ParsedValSpecifier {
                                                settable = "false";
                                            }
                                            case ParsedVarSpecifier {
                                                settable = "true";
                                            }
                                            case EmptySpecifier {
                                                ABORT("TODO: lookup field specializer in specialized state");
                                            }
                                        };
                                        sb.append(nextId + ".addDynField(" + settable + ", \"" + innerDecl.name.name + "\");\n");
                                    }
                                };
                                currentObjectValueId = nextNextId;
                            }
                        ); //end map
				    }
				}; //end match(isStatic)
				sb.append(ov + " = " + currentObjectValueId + ";\n");
			}
			case ParsedWith {
				val leftObjectValueId = idgen.getId();
				val rightObjectValueId = idgen.getId();
				sb.append("final plaid.fastruntime.ObjectValue " + leftObjectValueId + ";\n");
				sb.append("final plaid.fastruntime.ObjectValue " + rightObjectValueId + ";\n");
				codegenObjectValue(ops, node.r1, sb, idgen, fullyQualifiedClassName, leftObjectValueId, hashMapId, isStatic);
				codegenObjectValue(ops, node.r2, sb, idgen, fullyQualifiedClassName, rightObjectValueId, hashMapId, isStatic);
        		sb.append(ov + " = " + leftObjectValueId + ".with(" + rightObjectValueId + ");\n");
			}
			case ParsedFreeze {
				ERROR(node.token, "Code generator does not support freeze yet. Please check back later.");
			}
			default {
				ERROR(node.token, "Unexpected node type for state expression. Expected StateRef, DeclList, Freeze or With, but got " + node.nodeName());
			}
        }
    }
    

    
    method void createLocalVariable(immutable String name, unique StringBuilder sb, immutable Boolean isFinal ) {
        match ( isFinal ) {
            case True  { sb.append("final plaid.fastruntime.PlaidObject " + name +  ";\n")}
            case False { sb.append("plaid.fastruntime.PlaidObject " + name +  ";\n")}
        }
    }
    
    method void setLocalVariable(immutable String varName, immutable String value, unique StringBuilder sb) {
        sb.append(varName + " = " + value + ";\n")
    }
    
    method immutable String getLocalVariable(immutable String varName) {
        varName
    }
    
    
    method codegenApplication(immutable CodeGenOps ops, immutable ParsedExpr functionExpr, immutable List args, 
                              shared StringBuilder sb, shared IdGen idgen, 
                              immutable String y) {
    
        val yList = args.map( fn(item) => { idgen.getId(); } );
        yList.map( fn(yItem) => { ops.createLocalVariable(yItem, sb, true) });
        val argsYs = args.zip(yList);
        argsYs.map( fn(item) => { ops.codegenStmt(ops, item.first(), sb, idgen, item.second()); } );
        match(functionExpr) {
            case ParsedDereference {
            
                //check if this is a java constructor or static method if so, it will have a symbol
                val rightSymbolOpt = symbolForAST(functionExpr.right);
                match (rightSymbolOpt) {
                    case Some {
                        val rightSymbol = rightSymbolOpt.value;
                        match (rightSymbol) {
                            case JavaConstructorSymbol {  //Java constructors and static methods handled the same
                                codegenJavaStaticMethod(ops, functionExpr.left, rightSymbol, yList, sb, y);
                            }
                            case JavaStaticMethodSymbol {
                                codegenJavaStaticMethod(ops, functionExpr.left, rightSymbol, yList, sb, y);
                            }
                            default {
                                ERROR(functionExpr.token, "method id unexpectedly has a symbol");
                            }
                        }
                    }
                    case None {
                        //generate code for method call
                        
                        // preliminaries
                        val receiverExpr = functionExpr.left;
                        
                        
                        var receiverString = idgen.getId();
                        ops.createLocalVariable(receiverString, sb, true);
                        ops.codegenStmt(ops, receiverExpr, sb, idgen, receiverString);
                        
                        val methodId = functionExpr.right;
                        val mangledMethodName = NamingConventions.getGeneratedIdentifier(methodId.name);
                        
                        
                        
                        //generate interface
                        plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(mangledMethodName, yList.size());
                        
                        //test if method or field with first class function
                        
                        val methodInterfaceName = NamingConventions.getGeneratedInterfaceName(mangledMethodName, yList.size());
                        val dispatch = ops.getLocalVariable(receiverString) + ".getDispatch()";
                        sb.append("if(" + dispatch + " instanceof " + methodInterfaceName + ") {\n");
                        
                        //assign result to y					
                        var ysb = java.lang.StringBuilder.new();
                        //cast
                        ysb.append("(");
                        ysb.append("(" + methodInterfaceName + ")");
                        ysb.append(dispatch);
                        ysb.append(")");
                        //.<METHOD_NAME>(<RECEIVER>,<ARGS>)
                        ysb.append("." + mangledMethodName + "(");
                        ysb.append(ops.getLocalVariable(receiverString)); // receiver
                        if(yList.size() > 0) {
                            ysb.append(",");
                        };
                        ysb.append(makeSeperatedString(yList.map(fn (yItem) =>{ops.getLocalVariable(yItem)}), ",")); //normal arguments
                        ysb.append(")");
                        ops.setLocalVariable(y, ysb, sb);
                        
                        sb.append("}\n"); //end if
                        val getterName = NamingConventions.getGetterName(mangledMethodName);
                        val getterInterfaceName = NamingConventions.getGeneratedInterfaceName(getterName,0);
                        plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(getterName, 0);
                        
                        sb.append("else if(" + dispatch + " instanceof " + getterInterfaceName + ") {\n");
                        
    
                        ysb = java.lang.StringBuilder.new();
                        
                        //cast to lambda
                        ysb.append("(");
                        ysb.append("(plaid.fastruntime.PlaidLambda$"+yList.size()+")");
                        ysb.append("("); //begin getter cast
                        ysb.append("(" + getterInterfaceName + ")");
                        ysb.append(dispatch);
                        ysb.append(")"); // end getter cast
                        ysb.append("." + getterName + "(" + ops.getLocalVariable(receiverString) +")");
                        ysb.append(")"); //end lambda cast
                        ysb.append(".invoke$plaid(");
                        ysb.append(makeSeperatedString(yList.map(fn (yItem) =>{ops.getLocalVariable(yItem)}), ",")); //normal arguments
                        ysb.append(")");
                        ops.setLocalVariable(y, ysb.toString(), sb);
                        
                        sb.append("}\n"); //end else if
                        
                        sb.append("else {\n");
                        sb.append("throw new plaid.fastruntime.errors.PlaidIllegalOperationException(\"No method named " + methodId.name + " found \");\n");
                        sb.append("}\n");
                   
                    }
                }
            } 
            case ParsedIdentifier {
                val symbolOption = symbolForAST(functionExpr);
                match(symbolOption) {
                    case Some { 
                        val idSymbol = symbolOption.getValue();
                        match(idSymbol) {
                            case MethodSymbol {
                                //top-level methods are not fist class values so they must be handled specially
                                val parentSymbol = idSymbol.owner;
                                match(parentSymbol) {
                                    case PackageSymbol {
                                        val ysb = java.lang.StringBuilder.new();
                                        ysb.append(parentSymbol.getFQN());
                                        ysb.append(".");
                                        ysb.append("" + NamingConventions.getGeneratedIdentifier(functionExpr.name));
                                        ysb.append(".invoke$plaid("); // call directly, no need to cast
                                        ysb.append(makeSeperatedString(yList.map(fn (yItem) =>{ops.getLocalVariable(yItem)}), ","));
                                        ysb.append(");\n");
                                        ops.setLocalVariable(y, ysb.toString(), sb);
                                    }
                                    default {
                                        ERROR(functionExpr.token, "Identifier's symbol is a method symbol, but parent is not a PackageSymbol instead it is, "+ parentSymbol.symbolType());
                                    }
                                }
                            }
                            default {
                                val functionExprVarName = idgen.getId();
                                ops.createLocalVariable(functionExprVarName, sb, true);
                                ops.codegenStmt(ops, functionExpr, sb, idgen, functionExprVarName);
                                ops.setLocalVariable(y, "((plaid.fastruntime.PlaidLambda$" + yList.size() + ")" + functionExprVarName + ").invoke$plaid(" + makeSeperatedString(yList.map(fn (yItem) =>{ops.getLocalVariable(yItem)}), ",") + ")", sb);
                            }
                        }
                    }
                    case None {
                        ERROR(functionExpr.token, "No symbol found for identifier. (Identifier named " + functionExpr.name + ")");
                    }
                }
            }
            default {
                val functionExprVarName = idgen.getId();
                ops.createLocalVariable(functionExprVarName, sb, true);
                ops.codegenStmt(ops, functionExpr, sb, idgen, functionExprVarName);
                ops.setLocalVariable(y, "((plaid.fastruntime.PlaidLambda$" + yList.size() + ")" + functionExprVarName + ").invoke$plaid(" + makeSeperatedString(yList.map(fn (yItem) =>{ops.getLocalVariable(yItem)}), ",") + ")", sb);
            }
        }
    }
    
    method codegenJavaStaticMethod(immutable CodeGenOps ops, immutable ParsedExpr classAST, 
                                   immutable Symbol staticMethodSymbol, immutable List argNames, 
                                   shared StringBuilder sb, immutable String y) {
        var left = match (classAST) { //get AST mapped to JavaClassSymbol
            case ParsedDereference { classAST.right }
            case ParsedIdentifier { classAST }
            default { ERROR(classAST.token, "Unexpected AST node at left of java constructor") }
        };
        val leftSymbol = symbolForAST(left).value; //if no symbol, something went wrong earlier
        match (leftSymbol) {
            case JavaClassSymbol {
                val javaClassFQN = leftSymbol.getFQN();
                //static methods/constructors found in plaid.generated.<ClassFQN>
                val ysb = java.lang.StringBuilder.new();
                ysb.append("plaid.generated." + javaClassFQN + "." + staticMethodSymbol.name + "(");
                ysb.append(makeSeperatedString(argNames.map(fn (argItem) =>{ops.getLocalVariable(argItem)}), ",")); //normal arguments
                ysb.append(")");
                ops.setLocalVariable(y, ysb.toString(), sb);
                
                //generate static methods for the JavaClassSymbol
                plaid.fastruntime.Util.JAVA_GEN.saveStaticJavaObject(javaClassFQN);
            }
            default {
                ERROR(classAST.token, "non-JavaClassSymbol found as target of java static method or constructor");
            }	
        }
    }
    
    method void codegenMain(immutable String methodName, unique StringBuilder sb) {
        sb.append("public static void main(String[] args) {\n");
        sb.append("" + methodName + "();\n");
        sb.append("}\n"); // end main method
    }
    
    method void codegenMemberBodies(immutable CodeGenOps ops, immutable ParsedStateExpr theState, shared StringBuilder sb, shared IdGen idgen) {
		match (theState) {
			case ParsedDeclList {
				theState.decls.map(fn (innerDecl) => ops.codegenInnerDecl(ops, innerDecl, sb, idgen, false) );
			}
			case ParsedStateRef { /*no op*/ }
			case ParsedFreeze { /*no op*/ }
			case ParsedWith {
				ops.codegenMemberBodies(ops, theState.r1, sb, idgen);
				ops.codegenMemberBodies(ops, theState.r2, sb, idgen);
			}
		}
	}
}




method convertOpStringToMethodName(immutable String op) {
    NamingConventions.convertOpStringToMethodName(op);
}
    
method makeSeperatedString(immutable LinkedList<String> stringList, immutable String sep) {
    ifElse(stringList.size() > 0) {
        val addSep = fn(s1, s2) => {s1 + sep + s2};
        val toReturn = stringList.reduceLeft("", addSep);
        toReturn.substring(sep.length(),toReturn.length());
    }
    { //
        "";
    }
}