package plaid.compiler.codegen;

import java.lang.StringBuilder;
import java.lang.System;

import plaid.ast.parsed.*;

import plaid.compiler.COMPILER_CONFIGURATION;
import plaid.compiler.AEMINIUM_MODE;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_LOW;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.DEBUG_PRIO_HIGH;
import plaid.compiler.symbolForAST;

import plaid.compiler.symbol.*;

import plaid.compiler.aeminium.*;

import plaid.collections.LinkedList;
import plaid.collections.makeLinkedList;

import plaid.fastruntime.NamingConventions;
import plaid.fastruntime.CompilerUtil;
import plaid.fastruntime.util.FileGen;
import plaid.fastruntime.util.ClassNameCounter;

method LOG (immutable String msg) {
	DEBUG(DEBUG_PRIO_LOW, "<CodeGenPass> " + msg);
}

method ERROR(immutable Token t, immutable String msg) {
	plaid.compiler.report_ERROR(t," INTERNAL ERROR: " + msg, "CodeGenPass");
}

state CodeGenOps {
    method codegenCU(immutable CodeGenOps ops, unique Job job, immutable ParsedCompilationUnit node);
    method codegenTopLevelDecl(immutable CodeGenOps ops, immutable ParsedDecl node, immutable String packageName, shared StringBuilder sb, shared IdGen idgen, classNameCounter);
    method codegenInnerDecl(immutable CodeGenOps ops, immutable ParsedDecl node,  shared StringBuilder sb, shared IdGen idgen, classNameCounter);
    method codegenMethodBody(immutable CodeGenOps ops, immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen, classNameCounter);
    method codegenStmtBlock(immutable CodeGenOps ops, immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen, immutable String y, classNameCounter);
    method codegenStmt(immutable CodeGenOps ops, immutable Stmt node, shared StringBuilder sb, shared IdGen idgen, immutable String y, classNameCounter);
    method codegenLambda(immutable CodeGenOps ops, args, body, sb, idgen, y, classNameCounter);
    method codegenStateExpr(immutable CodeGenOps ops, immutable Stmt node, shared StringBuilder sb, shared IdGen idgen, immutable String y, classNameCounter);
    method codegenApplication(immutable CodeGenOps ops, immutable ParsedExpr functionExpr, immutable List args, 
	    					  shared StringBuilder sb, shared IdGen idgen, 
		    				  immutable String y, classNameCounter);
	method void codegenMain(immutable String methodName, unique StringBuilder sb);
	method void createLocalVariable(immutable String name, unique StringBuilder sb, immutable Boolean isFinal);
	method void setLocalVariable(immutable String varName, immutable String value, unique StringBuilder sb);
	method immutable String getLocalVariable(immutable String varName);
}

state SequentialCodeGenOps {
    method codegenCU(immutable CodeGenOps ops, unique Job job, immutable ParsedCompilationUnit node) {
        plaid.compiler.codegen.codegenCU(ops, job, node);
    }
      
    method codegenTopLevelDecl(immutable CodeGenOps ops, immutable ParsedDecl node, immutable String packageName, shared StringBuilder sb, shared IdGen idgen, classNameCounter) {
        plaid.compiler.codegen.codegenTopLevelDecl(ops, node, packageName, sb, idgen, classNameCounter);
    }
    
    method codegenInnerDecl(immutable CodeGenOps ops, immutable ParsedDecl node,  shared StringBuilder sb, shared IdGen idgen, classNameCounter) {
        plaid.compiler.codegen.codegenInnerDecl(ops, node, sb, idgen, classNameCounter);
    }
    
    method codegenMethodBody(immutable CodeGenOps ops, immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen, classNameCounter) {
        plaid.compiler.codegen.codegenMethodBody(ops, node, sb, idgen, classNameCounter);
    }
    
    method codegenStmtBlock(immutable CodeGenOps ops, immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen, immutable String y, classNameCounter) {
        plaid.compiler.codegen.codegenStmtBlock(ops, node, sb, idgen, y, classNameCounter);
    }
    
    method codegenStmt(immutable CodeGenOps ops, immutable Stmt node, shared StringBuilder sb, shared IdGen idgen, immutable String y, classNameCounter) {
        plaid.compiler.codegen.codegenStmt(ops, node, sb, idgen, y, classNameCounter);
    }
    
    method codegenLambda(immutable CodeGenOps ops, args, body, sb, idgen, y, classNameCounter)  {
        plaid.compiler.codegen.codegenLambda(ops, args, body, sb, idgen, y, classNameCounter);
    }
    
    method codegenStateExpr(immutable CodeGenOps ops, immutable Stmt node, shared StringBuilder sb, shared IdGen idgen, immutable String y, classNameCounter)  {
        plaid.compiler.codegen.codegenStateExpr(ops, node, sb, idgen, y, classNameCounter);
    }
    
    method codegenApplication(immutable CodeGenOps ops, immutable ParsedExpr functionExpr, immutable List args, 
	    					  shared StringBuilder sb, shared IdGen idgen, 
		    				  immutable String y, classNameCounter) {
        plaid.compiler.codegen.codegenApplication(ops, functionExpr, args, sb, idgen, y, classNameCounter);
    }

	method void codegenMain(immutable String methodName, unique StringBuilder sb) {
	    plaid.compiler.codegen.codegenMain(methodName, sb);
	}

    method void createLocalVariable(immutable String name, unique StringBuilder sb, immutable Boolean isFinal) {
        plaid.compiler.codegen.createLocalVariable(name, sb, isFinal);
    }
    
	method void setLocalVariable(immutable String varName, immutable String value, unique StringBuilder sb) {
	    plaid.compiler.codegen.setLocalVariable(varName, value, sb);
	}
	
	method immutable String getLocalVariable(immutable String varName) {
	    plaid.compiler.codegen.getLocalVariable(varName);
	}
}

method unique SequentialCodeGenOps makeSequentialCodeGenOps() {
    new SequentialCodeGenOps;
}

method codegenCU(immutable CodeGenOps ops, unique Job job, immutable ParsedCompilationUnit node) {
	val idGen = new IdGen;
	LOG("generating code for ParsedCompilationUnit");
	val qiPackage = node.packageName.identifiers.map( fn(id) => { id.name } );
	val sep = System.getProperty("file.separator");
	val packageDir = makeSeperatedString(qiPackage, sep);
	val packageString = makeSeperatedString(qiPackage, ".");
	val stringbuilderlist = node.decls.map( fn(item) => {val result = StringBuilder.new(); result} );
	val declsSbList = node.decls.zip(stringbuilderlist);
	
	//first = decl, second = StringBuilder
	declsSbList.map( fn(item) => {
	   val declName = NamingConventions.getGeneratedIdentifier(item.first().name.name);
       
       val outputDir = COMPILER_CONFIGURATION().tempDir;
       val classNameCounter = ClassNameCounter.new(declName, outputDir, packageDir);
	   ops.codegenTopLevelDecl(ops, item.first(), packageString, item.second(), idGen, classNameCounter); 
	} );
	
	stringbuilderlist.map( fn(item) => { DEBUG(DEBUG_PRIO_HIGH, item.toString()); } );
	
	//create directories and files for java source output
	declsSbList.map( fn(item) => {
		val declName = NamingConventions.getGeneratedIdentifier(item.first().name.name);
		val outputDir = COMPILER_CONFIGURATION().tempDir;
		val codeString = item.second().toString();
		FileGen.createOutputFile(declName, outputDir, codeString, packageDir);
		
		// generated file name to list of generated files
		val immutable String path = outputDir + java.lang.System.getProperty("file.separator") + packageDir + System.getProperty("file.separator") + declName + ".java";
		job.addGeneratedFile(path);
	} );
}

method codegenTopLevelDecl(immutable CodeGenOps ops, immutable ParsedDecl node, immutable String packageName, shared StringBuilder sb, shared IdGen idgen, classNameCounter) {
	LOG("generating code for Top Level Decl");
	match(node) {
		case ParsedConcreteMethodDecl {
			LOG("generating code for top-level concrete method decl");
			
			sb.append("package " + packageName + ";\n");
			
			sb.append("public class " + NamingConventions.getGeneratedIdentifier(node.name.name) + "{\n");
			
			// begin invoke method
			sb.append("public static plaid.fastruntime.PlaidObject " + NamingConventions.GENERATED_METHOD_NAME + "(");
			
			val argStringList = node.arguments.map(fn(arg1) => {"final plaid.fastruntime.PlaidObject " + arg1.name.name});
			sb.append(makeSeperatedString(argStringList, ","));
			sb.append(") {\n");
			
			//method body
			ops.codegenMethodBody(ops, node.body, sb, idgen, classNameCounter);
			
			sb.append("}\n"); // end invoke method
			
			//begin main method
			if(node.arguments.size() == 0) {
			    ops.codegenMain(NamingConventions.GENERATED_METHOD_NAME, sb);
			};
			
			sb.append("}\n"); // end class
		}
		case ParsedConcreteFieldDecl {
			LOG("generating code for top-level concrete field decl");
			
			sb.append("package " + packageName + ";\n");			
			sb.append("public class " + NamingConventions.getGeneratedIdentifier(node.name.name) + "{\n");
		
			val fieldName = NamingConventions.GENERATED_FIELD_NAME;
		
			sb.append("public static final plaid.fastruntime.PlaidObject " + fieldName + ";\n");
			sb.append("static {\n");
			
			// field initializer body
			val exprVarName = idgen.getId();
			ops.createLocalVariable(exprVarName, sb, false);
			ops.codegenStmt(ops, node.expression, sb, idgen, exprVarName, classNameCounter);
			//sb.append("" + fieldName + " = " + exprVarName + ";\n");
			sb.append("" + fieldName + " = " + ops.getLocalVariable(exprVarName) + ";\n");
			
			sb.append("}\n"); //end static block
			sb.append("}\n"); //end class
			
		}
		case ParsedConcreteStateDecl {
			LOG("generating code for top-level concrete state decl");
			sb.append("package " + packageName + ";\n");
			sb.append("public class " + NamingConventions.getGeneratedIdentifier(node.name.name) + "{\n");
			
			val tag = java.util.UUID.randomUUID().toString();

			val fullyQualifiedClassName = packageName + "." + node.name.name;
			val sbStateInitializer = java.lang.StringBuilder.new();
			
			val ovfId = idgen.getId();
			sbStateInitializer.append("plaid.fastruntime.reference.ObjectValueFactory " + ovfId + " = ");
			sbStateInitializer.append("new plaid.fastruntime.reference.ObjectValueFactory();\n");
			sbStateInitializer.append(ovfId + ".tag(\"" + tag + "\");\n");
			
			match(node.caseOf) {
				case ParsedEmptyQualifiedIdentifier {
					// no -op
				}
				case ParsedQualifiedIdentifier {
					val caseofSymbolOption = symbolForAST(node.caseOf);
					match(caseofSymbolOption) {
						case Some {
							val caseofSymbol = caseofSymbolOption.getValue();
							match(caseofSymbol) {
								case StateSymbol {
									val parent = caseofSymbol.owner;
									//TODO: this will throw an error if class has no parent package
									var packageQualifiedIdentifier = parent.getQualifiedIdentifier();
									val caseofPackageName = makeSeperatedString(packageQualifiedIdentifier.identifiers.map(fn(id) => {id.name}), ".");
									val ovId = idgen.getId();
									sbStateInitializer.append("plaid.fastruntime.ObjectValue " + ovId + " = ");
									val stateSimpleName = node.caseOf.identifiers.get(node.caseOf.identifiers.size() - 1).getValue().name;
									sbStateInitializer.append(caseofPackageName + "." + stateSimpleName + "." + NamingConventions.GENERATED_STATE_NAME + ".getObjectValue();\n");
									sbStateInitializer.append(ovfId + ".parent(" + ovId + ");\n");
								}
								default{
									ERROR(node.caseOf.token, "Case of identifier symbol is unexpected value, " + caseOfSymbol.symbolType() + ".");
								}
							}
						} case None {
							ERROR(node.caseOf.token, "no symbol for case of identifier");
						}
					}
				}
			};
			
			//generate methods and field
			match(node.stateBinding) {
				
				case ParsedDeclList {
					node.stateBinding.decls.map( fn(innerDecl) => { 
						ops.codegenInnerDecl(ops, innerDecl, sb, idgen, classNameCounter);
						match(innerDecl) {
							case ParsedConcreteMethodDecl {
								sbStateInitializer.append(ovfId + ".mthd(\"" + innerDecl.name.name + "\"," 
									+ innerDecl.arguments.size() + ",\"" + fullyQualifiedClassName + "\");\n");
							}
							case ParsedConcreteFieldDecl {
								var settable = "";
								match(innerDecl.specifier) {
									case ParsedValSpecifier {
										settable = "false";
									}
									case ParsedVarSpecifier {
										settable = "true";
									}
								};
								sbStateInitializer.append(ovfId + ".field(" + settable + ", \"" + innerDecl.name.name + "\"," 
									+ "\"" + fullyQualifiedClassName + "\");\n");
							}
							case ParsedAbstractFieldDecl {
								//no-op
							}
							case ParsedAbstractMethodDecl {
								//no-op
							}
							default {
								ERROR(innerDecl.token, "Unsupported inner decl ast node. Node name is " + innerDecl.nodeName());
							}
						}
					} );
				}
				case ParsedWith {
					// add List
				}
				case ParsedFreeze {
					ERROR(node.stateBinding.token, "Code generator does not support freeze yet. Please check back later.");
				}
				default {
					ERROR(node.stateBinding.token, "Found unexpected state binding in concrete state declaration.");
				}
			};
			
			sbStateInitializer.append("plaid.fastruntime.ObjectValue ov = " + ovfId + ".value();\n");
			sbStateInitializer.append("" + NamingConventions.GENERATED_STATE_NAME + " = plaid.fastruntime.Util.DISPATCH_GEN.createStateInstance(ov);\n");
			
			//generate static field containing PlaidState
			sb.append("public static final plaid.fastruntime.PlaidState " + NamingConventions.GENERATED_STATE_NAME + ";\n");
			sb.append("static {\n");
			sb.append(sbStateInitializer.toString());
			sb.append("}\n");
			
			sb.append("}\n"); // end class
		}
		default {
			ERROR(node.token, "Found unexpected node as top-level decl");
		}
	}
}



method codegenInnerDecl(immutable CodeGenOps ops, immutable ParsedDecl node,  shared StringBuilder sb, shared IdGen idgen, classNameCounter) {
	match (node) {
		case ParsedConcreteMethodDecl {
			// begin invoke method
			val methodName = NamingConventions.getGeneratedIdentifier(node.name.name);
			sb.append("public static plaid.fastruntime.PlaidObject " + methodName + "(");
		    
		    sb.append("final plaid.fastruntime.PlaidObject " + NamingConventions.GENERATED_THIS);
		    if(node.arguments.size() > 0) {
		    	sb.append(",");
		    	val argsList = node.arguments.map(fn(arg1) => {" final plaid.fastruntime.PlaidObject " + arg1.name.name});
				sb.append(makeSeperatedString(argsList,","));
		    };
		    
			sb.append(") {\n");
			
			//method body
			ops.codegenMethodBody(ops, node.body, sb, idgen, classNameCounter);
			
			sb.append("}\n"); // end invoke method
		}
		case ParsedConcreteFieldDecl {
			// generate static field to contain initialization code for fields.
			// begin invoke method
			sb.append("public static plaid.fastruntime.PlaidFieldInitializer " + node.name.name + ";\n"); // field declaration
			
			//preliminiaries
			sb.append("static {\n");
			sb.append(node.name.name + " = new plaid.fastruntime.PlaidFieldInitializer() { \n");
			sb.append("@Override\n");
			sb.append("public plaid.fastruntime.PlaidObject invoke$plaid() {\n");
			
			//body of invoke, generate code for expression, return the value
			val exprVarName = idgen.getId();
			ops.createLocalVariable(exprVarName, sb, false);
			ops.codegenStmt(ops, node.expression, sb, idgen, exprVarName, classNameCounter);
			sb.append("return " + ops.getLocalVariable(exprVarName) + ";\n");
			
			//finalize
			sb.append("}\n"); // end invoke$plaidmethod
			sb.append("};\n"); // end FieldInitializer anonymous class
			sb.append("}\n"); // end static
			
		}
		case ParsedAbstractFieldDecl {
			//no-op
		}
		case ParsedAbstractMethodDecl {
			//no-op
		}
		default {
			ERROR(node.token, "Found unexpected node as inner decl");
		}
	}
}
	
method codegenMethodBody(immutable CodeGenOps ops, immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen, classNameCounter) {
	LOG("generating code for method body block expression");
	ifElse(node.statements.size() > 0) {
		val y = idgen.getId();
		ops.createLocalVariable(y, sb, false);
		node.statements.map( fn(item) => { ops.codegenStmt(ops, item, sb, idgen, y, classNameCounter); } );
		sb.append("return " + ops.getLocalVariable(y) + ";\n");
	} {
		sb.append("return plaid.fastruntime.Util.unit();\n");
	}
}

method codegenStmtBlock(immutable CodeGenOps ops, immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen, immutable String y, classNameCounter) {
	LOG("generating code for case body block expression");
	ifElse(node.statements.size() > 0) {
		node.statements.map( fn(item) => { ops.codegenStmt(ops, item, sb, idgen, y, classNameCounter); } );
	} {
		ops.setLocalVariable(y, "plaid.fastruntime.Util.unit()", sb);
	}
}

method codegenStmt(immutable CodeGenOps ops, immutable Stmt node, shared StringBuilder sb, shared IdGen idgen, 
		immutable String y, classNameCounter) {
	LOG("generating code for statement '" + node.nodeName() + "'");
	match(node) {
	    case ParsedAtomicBlock {
	        ERROR(node.token, "Enable AEminium to use atomic blocks");
	    }
		case ParsedMethodCall { //TODO: factor out commonalities with application
			val receiverExpr = node.receiver;
			val argumentExpr = node.argument;
			val methodId = node.methodId;
			val methodName = NamingConventions.getGeneratedIdentifier(methodId.name);
		
			val yList = argumentExpr.args.map( fn(item) => { idgen.getId(); } );
			yList.map( fn(yItem) => { ops.createLocalVariable(yItem, sb, false) });
			val argsYs = argumentExpr.args.zip(yList);
			argsYs.map( fn(item) => { ops.codegenStmt(ops, item.first(), sb, idgen, item.second(), classNameCounter); } );
				
			//generate code for method call
             var receiverString = idgen.getId();
            ops.createLocalVariable(receiverString, sb, false);
            ops.codegenStmt(ops, receiverExpr, sb, idgen, receiverString, classNameCounter);
                                    
			//generate interface
            plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(methodName, yList.size());

            val methodInterfaceName = NamingConventions.getGeneratedInterfaceName(methodName, yList.size());
            val dispatch = ops.getLocalVariable(receiverString) + ".getDispatch()";
                                    
            //cast
            val ysb = java.lang.StringBuilder.new();
            ysb.append("(");
            ysb.append("(" + methodInterfaceName + ")");
            ysb.append(dispatch);
            ysb.append(")");
            //.<METHOD_NAME>(<RECEIVER>,<ARGS>)
            ysb.append("." + methodName + "(");
            ysb.append(ops.getLocalVariable(receiverString)); // receiver
            if(yList.size() > 0) {
                ysb.append(",");
            };
            ysb.append(makeSeperatedString(yList.map(fn (yItem) => { ops.getLocalVariable(yItem)}), ",")); //normal arguments
            ysb.append(")");
            
            // assign result to y
            ops.setLocalVariable(y, ysb.toString(), sb);
		}
		case ParsedDereference {
			LOG("generating code for dereference");
			val symbolLeftOption = symbolForAST(node.left);
			val symbolRightOption = symbolForAST(node.right);
			var symbolLeft = "";
			match(symbolLeftOption) {
				case Some {
					symbolLeft = symbolLeftOption.getValue();
				}
				case None {
					ERROR(node.token, "There was no symbol for the left component of a dereference. The left value is " + node.left.toString());
				}
			};
			match(symbolLeft) {
				case JavaClassSymbol {
					match(symbolRightOption) {
						case Some {
							match(symbolRightOption.getValue()) {
								case JavaStaticFieldSymbol  {
									val parent = symbolLeft.owner;
									val classFQN = symbolLeft.getFQN();
									ops.setLocalVariable(y, "plaid.fastruntime.Util.javaToPlaid(" + classFQN + "." + node.right.name + ")", sb);
								}
								case JavaStaticMethodSymbol {
									ERROR(node.token, "java methods cannot be dereferenced except as a part of an application/method call");
								}
								case JavaConstructorSymbol {
									ERROR(node.token, "java constructors cannot be dereferenced except as a part of an application/method call");
								}
								default {
									ERROR(node.token, "Unexpected symbol for the right side of a dereference of Java class");
								}
							}
						}
						default {
							ERROR(node.token, "Found no symbol for the right side of a dereference of Java class.");
						}
					}
				}
				default {
					// generated code for receiver expression
					val receiverId = idgen.getId();
					ops.createLocalVariable(receiverId, sb, false);
					ops.codegenStmt(ops, node.left, sb, idgen, receiverId, classNameCounter);
					
					//getter preliminaries
					val getterName = NamingConventions.getGetterName(node.right.name);
					plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(getterName, 0);
					val ifaceName = NamingConventions.getGeneratedInterfaceFullyQualifiedName(getterName, 0);
					
                    //call getter and assign result to y
					val ysb = java.lang.StringBuilder.new();
					ysb.append("("); // parentheses around casted object
					ysb.append("(" + ifaceName + ")");
					ysb.append("" + ops.getLocalVariable(receiverId) + ".getDispatch()");
					ysb.append(")"); // end parentheses around casted object  
					ysb.append("." + getterName + "(" + receiverId + ")");
					ops.setLocalVariable(y, ysb.toString(), sb);
				}
			}			
		}
		case ParsedAssignment {
			match(node.target) {
				case ParsedEmptyExpr { // assignment to local variable
				
				}
				default { // assignment to field of an object
					//TODO: deal with assignment to java static fields, very unimportant use case
					
					// generated code for receiver expression
					val receiverId = idgen.getId();
					ops.createLocalVariable(receiverId, sb, false);
					ops.codegenStmt(ops, node.target, sb, idgen, receiverId, classNameCounter);
					
					//generate code for value to assign
					val valueId = idgen.getId();
					ops.createLocalVariable(valueId, sb, false);
					ops.codegenStmt(ops, node.value, sb, idgen, valueId, classNameCounter);
					
					val setterName = NamingConventions.getSetterName(node.field.name);
					plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(setterName, 1);
					val ifaceName = NamingConventions.getGeneratedInterfaceFullyQualifiedName(setterName, 1);
					val ysb = java.lang.StringBuilder.new();
					ysb.append("("); // paretheses around casted object
					ysb.append("(" + ifaceName + ")");
					ysb.append("" + ops.getLocalVariable(receiverId) + ".getDispatch()");
					ysb.append(")"); // end parentheses around casted object  
					ysb.append("." + setterName + "(" + ops.getLocalVariable(receiverId) + ", " + ops.getLocalVariable(valueId) +")");
					ops.setLocalVariable(y, ysb.toString(), sb);
				}
			}
		}
		case ParsedApplication {
			LOG("generating code for application");
			val argumentExpr = node.argument;
			match(argumentExpr) {
				case ParsedArgumentExpr {
					ops.codegenApplication(ops, node.function, argumentExpr.args, sb, idgen, y, classNameCounter);
				}
				default { 
					val argList = makeLinkedList();
					argList.add(argumentExpr);
					ops.codegenApplication(ops, node.function, argList, sb, idgen, y, classNameCounter);
				}
			};
		}
		case ParsedStringLiteral {
			ops.setLocalVariable(y, "plaid.fastruntime.Util.string(\"" + node.value + "\")", sb);
		}
		case ParsedIntLiteral {
			ops.setLocalVariable(y, "plaid.fastruntime.Util.integer(" + node.value + ")", sb);
		}
		case ParsedDoubleLiteral {
			ops.setLocalVariable(y, "plaid.fastruntime.Util.float64(" + node.value + ")", sb);
		}
		case ParsedInfixOperatorExpr {
			//preliminaries
			val op = node.operator;
			val methodName = convertOpStringToMethodName(op.name);
			
			// generate code for receiver
			val receiverString = idgen.getId();
			ops.createLocalVariable(receiverString, sb, false);
			ops.codegenStmt(ops, node.left, sb, idgen, receiverString, classNameCounter);
			
			//generate code for argument
			val argId = idgen.getId();
			ops.createLocalVariable(argId, sb, false);
			ops.codegenStmt(ops, node.right, sb, idgen, argId, classNameCounter);
			
			//generate interface
			plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(methodName, 1);
							
			//cast
			val ysb = java.lang.StringBuilder.new();
			ysb.append("(");
			ysb.append("(" + NamingConventions.getGeneratedInterfaceName(methodName, 1) + ")");
			ysb.append(receiverString);
			ysb.append(".getDispatch()");
			ysb.append(")");
			//.<METHOD_NAME>(<ARGS>)
			ysb.append("." + methodName + "(");
			ysb.append(ops.getLocalVariable(receiverString) + ","); // receiver
			ysb.append(ops.getLocalVariable(argId)); //normal arguments
			ysb.append(")");
						
			//assign result to y
			ops.setLocalVariable(y, ysb.toString(), sb);
		}
		case ParsedVarDecl {
			val exprVarName = idgen.getId();
			ops.createLocalVariable(exprVarName, sb, false);
			ops.codegenStmt(ops, node.expr, sb, idgen, exprVarName, classNameCounter);
			ops.createLocalVariable( node.id.name, sb, true);
			ops.setLocalVariable(node.id.name, ops.getLocalVariable(exprVarName), sb);
		}
		case ParsedIdentifier {
			// need to ensure that this is never called if ParsedIdentifier refers to a JavaClass
			// we cannot assign java class value to PlaidObject variable
			val symbolOption = symbolForAST(node);
			match(symbolOption) {
				case Some {
					val symbol = symbolOption.getValue();
					match(symbol) {
						case JavaClassSymbol {
							ERROR(node.token, "Identifier cannot refer to Java class in ParsedIdentifier case of codegenStmt.");
						}
						case VariableSymbol {
							val varName = ifElse(node.name.equals("this")) {
								NamingConventions.GENERATED_THIS;
							}{
								node.name;
							};
							ops.setLocalVariable(y, ops.getLocalVariable(varName), sb);
						}
						case FieldSymbol {
							val parentSymbol = symbol.owner;
							match(parentSymbol) {
								case PackageSymbol {
								    val ysb = java.lang.StringBuilder.new();
									ysb.append(parentSymbol.getFQN());
									ysb.append(".");
									ysb.append(NamingConventions.getGeneratedIdentifier(node.name));
									ysb.append("." + NamingConventions.GENERATED_FIELD_NAME);
									ops.setLocalVariable(y, ysb.toString(), sb);
								}
								default {
									ERROR(node.token, "Identifier's symbol is a field symbol, but parent is not a PackageSymbol instead it is, "+ parentSymbol.symbolType());
								}
							}
						}
						case StateSymbol {
                            val stateFQN = symbol.getFQN();
                            ops.setLocalVariable(y, stateFQN + "." + NamingConventions.GENERATED_STATE_NAME, sb);
                        }
						case MethodSymbol {
							ERROR(node.token, "Methods are not first class values, therefore this should not be called.");
						}
						default {
							ERROR(node.token, "Identifier has unexpected symbol '" + symbol.symbolType() + "'.");
						}
					};
				} case None {
					ERROR(node.token, "No symbol found for identifier. (Identifier named " + node.name + ")");
				}
			};
			
		}
		case ParsedNewInstance {
			val exprVarName = idgen.getId();
			sb.append("plaid.fastruntime.PlaidState " + exprVarName + ";\n");
			ops.codegenStateExpr(ops, node.stateExpr, sb, idgen, exprVarName, classNameCounter);
			ops.setLocalVariable(y, ops.getLocalVariable(exprVarName) + ".instantiate()", sb);
		}
		case ParsedMatch {
		    LOG("generating code for match");
			val exprVarName = idgen.getId();
			ops.createLocalVariable(exprVarName, sb, false);
			ops.codegenStmt(ops, node.expression, sb, idgen, exprVarName, classNameCounter);
			
			val caseStringList = new LinkedList;
			node.caseList.map(fn(c) => {
				match(c) {
					case ParsedPatternCase {
						val patternSymbolOption = symbolForAST(c.pattern);
						match(patternSymbolOption) {
							case Some {
								
								val patternSymbol = patternSymbolOption.getValue();
								match (patternSymbol) {
									case StateSymbol {
										val caseSB = StringBuilder.new();
										caseSB.append("if(" + ops.getLocalVariable(exprVarName) + ".getDispatch().matches(");
										caseSB.append(patternSymbol.getFQN() + "." + NamingConventions.GENERATED_STATE_NAME + ".getTopTag())) {\n");
										val bodyVarName = idgen.getId();
										ops.createLocalVariable(bodyVarName, sb, false);
										ops.codegenStmtBlock(ops, c.body, caseSB, idgen, bodyVarName, classNameCounter);
										ops.setLocalVariable(y, ops.getLocalVariable(bodyVarName), caseSB);
										caseSB.append("}\n");
										caseStringList.addLast(caseSB.toString());
									}
									default {
										ERROR(c.token, "Case pattern has unexpected symbol '" + patternSymbol.symbolType() + "'.");
									}
								}
							}
							case None {
								ERROR(c.token, "No symbol found for pattern in case.")
							}			
						};
					}
					case ParsedDefaultCase {
						val caseSB = StringBuilder.new();
						val bodyVarName = idgen.getId();
						caseSB.append("{\n");
						caseSB.append("plaid.fastruntime.PlaidObject " + bodyVarName + ";\n");
						ops.codegenStmtBlock(ops, c.body, caseSB, idgen, bodyVarName, classNameCounter);
						ops.setLocalVariable(y, ops.getLocalVariable(bodyVarName), caseSB);
						caseSB.append("}\n");
						caseStringList.addLast(caseSB.toString());
					}
				};
			});
			val caseString = makeSeperatedString(caseStringList, "else ");
			sb.append(caseString);
			val lastCase = node.caseList.get(node.caseList.size() - 1).getValue();
			match (lastCase) {
				case ParsedPatternCase {
					sb.append("else {\n");
					sb.append("throw new plaid.fastruntime.errors.PlaidIllegalOperationException(\"Pattern match exausted.\");\n");
					sb.append("}\n");
				}
				case ParsedDefaultCase {
					//no-op
				}
			}
		}
		case ParsedBlockExpr {
			// this should not be called if parent node is ConcreteMethodDecl, Case, Split, o r
			//delegate to lambda expression code generator
			ops.codegenLambda(ops, new LinkedList, node, sb, idgen, y, classNameCounter);
		}
		case ParsedLambda {
			ops.codegenLambda(ops, node.arguments, node.body, sb, idgen, y, classNameCounter);
		}
		case ParsedUnitLiteral {
		    ops.setLocalVariable(y, "plaid.fastruntime.Util.unit()", sb);
		}
		default {
			ERROR(node.token, "Unexpected stmt node type,"+ node.nodeName() +" encountered.");
		}
	}
}

method codegenLambda(immutable CodeGenOps ops, args, body, sb, idgen, y, classNameCounter) {
	sb.append(y + " = new plaid.fastruntime.PlaidLambda$" + args.size() + "() {\n");
	sb.append("public plaid.fastruntime.PlaidObject invoke$plaid(");
	if(args.size() > 0) {
		val argList = args.map(fn(arg) => {"final plaid.fastruntime.PlaidObject " + arg.name.name});
		sb.append(makeSeperatedString(argList, ","));
	};
	sb.append(")"); // end argument list
	sb.append(" {\n"); // begin invoke method body
	match(body) {
		case ParsedBlockExpr {
			val toReturn = idgen.getId();
			ops.createLocalVariable(y, sb, false);
			body.statements.map( fn(item) => { ops.codegenStmt(ops, item, sb, idgen, y, classNameCounter); } );
			sb.append("return " + ops.getLocalVariable(y) + ";\n");
		}
		default {
			val toReturn = idgen.getId();
			ops.createLocalVariable(y, sb, false);
			ops.codegenStmt(ops, body, sb, idgen, toReturn, classNameCounter);
			sb.append("return " + ops.getLocalVariable(y) + ";\n");
		}
	};
	sb.append("}\n"); // end invoke method
	sb.append("};\n"); // end anonymous inner class
}

method codegenStateExpr(immutable CodeGenOps ops, immutable Stmt node, shared StringBuilder sb, shared IdGen idgen, immutable String y, classNameCounter) {
	match(node) {
		case ParsedStateRef {
            val stateExprId = idgen.getId();
            ops.createLocalVariable(stateExprId, sb, false);
            ops.codegenStmt(ops, node.stateExpr, sb, idgen, stateExprId, classNameCounter);
            
            //cast to PlaidState
            val unspecializedStateId = idgen.getId();
            sb.append("plaid.fastruntime.PlaidState " + ops.getLocalVariable(unspecializedStateId) + " = (plaid.fastruntime.PlaidState)" + ops.getLocalVariable(stateExprId) + ";\n");
            
            match(node.specializations.size() > 0) {
                case True {
                    val anonymousSb = java.lang.StringBuilder.new();        
                    
                    val ovfId = idgen.getId();
                    sb.append("plaid.fastruntime.reference.ObjectValueFactory " + ovfId + " = ");
                    sb.append("new plaid.fastruntime.reference.ObjectValueFactory();\n");
                    val fullyQualifiedClassName = classNameCounter.nextFullyQualifiedClassName();
                    node.specializations.map(
                        fn(declorstateop) => {
                            match(declorstateop) {
                                case ParsedStateOpRename {
                                    // do nothing for now
                                }
                                case ParsedStateOpRemove {
                                    // do nothing for now
                                }
                                default {
                                    //decl
                                    ops.codegenInnerDecl(ops, declorstateop, anonymousSb, idgen, classNameCounter);
                                    match(declorstateop) {
                                        case ParsedConcreteMethodDecl {
                                            sb.append(ovfId + ".mthd(\"" + declorstateop.name.name + "\"," 
                                                + declorstateop.arguments.size() + ",\"" + fullyQualifiedClassName + "\");\n");
                                        }
                                        case ParsedConcreteFieldDecl {
                                            var settable = "";
                                            match(declorstateop.specifier) {
                                                case ParsedValSpecifier {
                                                    settable = "false";
                                                }
                                                case ParsedVarSpecifier {
                                                    settable = "true";
                                                }
                                            };
                                            sb.append(ovfId + ".field(" + settable + ", \"" + declorstateop.name.name + "\"," 
                                                + "\"" + fullyQualifiedClassName + "\");\n");
                                            }
                                        }
                                    }
                                }
                            }
                        );
                    classNameCounter.writeCode(anonymousSb.toString());
                    
                    val specializedValueId = idgen.getId();
                    sb.append("plaid.fastruntime.ObjectValue " + specializedValueId + " = ");
                    sb.append(ovfId + ".value();\n");
                    
                    val fullValueId = idgen.getId();
                    sb.append("plaid.fastruntime.ObjectValue " + fullValueId + " = ");
                    sb.append(unspecializedStateId + ".getObjectValue()");
                    sb.append(".specialize(" + specializedValueId + ");\n" );
                    sb.append(y + " = plaid.fastruntime.Util.DISPATCH_GEN.createStateInstance(" + fullValueId + ");\n");
                }
                case False {
                    ops.setLocalVariable(y , ops.getLocalVariable(unspecializedStateId), sb);
                }
            }
		}
		default {
			ERROR(node.token, "Unepected node type for state state expression. Expected StateRef, got " + node.nodeName());
		}
	}
}

method convertOpStringToMethodName(immutable String op) {
	NamingConventions.convertOpStringToMethodName(op);
}
	
method makeSeperatedString(immutable LinkedList<String> stringList, immutable String sep) {
	ifElse(stringList.size() > 0) {
		val addSep = fn(s1, s2) => {s1 + sep + s2};
		val toReturn = stringList.reduceLeft("", addSep);
		toReturn.substring(sep.length(),toReturn.length());
	}
	{ //
		"";
	}
}

method void createLocalVariable(immutable String name, unique StringBuilder sb, immutable Boolean isFinal ) {
    match ( isFinal ) {
        case True  { sb.append("final plaid.fastruntime.PlaidObject " + name +  ";\n")}
        case False { sb.append("plaid.fastruntime.PlaidObject " + name +  ";\n")}
    }
}

method void setLocalVariable(immutable String varName, immutable String value, unique StringBuilder sb) {
    sb.append(varName + " = " + value + ";\n")
}

method immutable String getLocalVariable(immutable String varName) {
    varName
}


method codegenApplication(immutable CodeGenOps ops, immutable ParsedExpr functionExpr, immutable List args, 
						  shared StringBuilder sb, shared IdGen idgen, 
						  immutable String y, classNameCounter) {

	val yList = args.map( fn(item) => { idgen.getId(); } );
	yList.map( fn(yItem) => { ops.createLocalVariable(yItem, sb, false) });
	val argsYs = args.zip(yList);
	argsYs.map( fn(item) => { ops.codegenStmt(ops, item.first(), sb, idgen, item.second(), classNameCounter); } );
	match(functionExpr) {
		case ParsedDereference {
		
			//check if this is a java constructor or static method if so, it will have a symbol
			val rightSymbolOpt = symbolForAST(functionExpr.right);
			match (rightSymbolOpt) {
				case Some {
					val rightSymbol = rightSymbolOpt.value;
					match (rightSymbol) {
						case JavaConstructorSymbol {  //Java constructors and static methods handled the same
							codegenJavaStaticMethod(ops, functionExpr.left, rightSymbol, yList, sb, y);
						}
						case JavaStaticMethodSymbol {
							codegenJavaStaticMethod(ops, functionExpr.left, rightSymbol, yList, sb, y);
						}
						default {
							ERROR(functionExpr.token, "method id unexpectedly has a symbol");
						}
					}
				}
				case None {
					//generate code for method call
					
					// preliminaries
					val receiverExpr = functionExpr.left;
					
					
					var receiverString = idgen.getId();
					ops.createLocalVariable(receiverString, sb, false);
					ops.codegenStmt(ops, receiverExpr, sb, idgen, receiverString, classNameCounter);
					
					val methodId = functionExpr.right;
					val methodName = NamingConventions.getGeneratedIdentifier(methodId.name);
					
					
					
					//generate interface
					plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(methodName, yList.size());
					
					//test if method or field with first class function
					
					val methodInterfaceName = NamingConventions.getGeneratedInterfaceName(methodName, yList.size());
					val dispatch = ops.getLocalVariable(receiverString) + ".getDispatch()";
					sb.append("if(" + dispatch + " instanceof " + methodInterfaceName + ") {\n");
					
					//assign result to y					
					var ysb = java.lang.StringBuilder.new();
					//cast
					ysb.append("(");
					ysb.append("(" + methodInterfaceName + ")");
					ysb.append(dispatch);
					ysb.append(")");
					//.<METHOD_NAME>(<RECEIVER>,<ARGS>)
					ysb.append("." + methodName + "(");
					ysb.append(ops.getLocalVariable(receiverString)); // receiver
					if(yList.size() > 0) {
						ysb.append(",");
					};
					ysb.append(makeSeperatedString(yList.map(fn (yItem) =>{ops.getLocalVariable(yItem)}), ",")); //normal arguments
					ysb.append(")");
					ops.setLocalVariable(y, ysb, sb);
					
					sb.append("}\n"); //end if
					val getterName = NamingConventions.getGetterName(methodName);
					val getterInterfaceName = NamingConventions.getGeneratedInterfaceName(getterName,0);
					plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(getterName, 0);
					
					sb.append("else if(" + dispatch + " instanceof " + getterInterfaceName + ") {\n");
					

					ysb = java.lang.StringBuilder.new();
					
					//cast to lambda
					ysb.append("(");
					ysb.append("(plaid.fastruntime.PlaidLambda$"+yList.size()+")");
					ysb.append("("); //begin getter cast
					ysb.append("(" + getterInterfaceName + ")");
					ysb.append(dispatch);
					ysb.append(")"); // end getter cast
					ysb.append("." + getterName + "(" + ops.getLocalVariable(receiverString) +")");
					ysb.append(")"); //end lambda cast
					ysb.append(".invoke$plaid(");
					ysb.append(makeSeperatedString(yList.map(fn (yItem) =>{ops.getLocalVariable(yItem)}), ",")); //normal arguments
					ysb.append(")");
					ops.setLocalVariable(y, ysb.toString(), sb);
					
					sb.append("}\n"); //end else if
					
					sb.append("else {\n");
					sb.append("throw new plaid.fastruntime.errors.PlaidIllegalOperationException(\"No method named " + methodId.name + " found \");\n");
					sb.append("}\n");
			   
				}
			}
		} 
		case ParsedIdentifier {
			val symbolOption = symbolForAST(functionExpr);
			match(symbolOption) {
				case Some { 
					val idSymbol = symbolOption.getValue();
					match(idSymbol) {
						case MethodSymbol {
							//top-level methods are not fist class values so they must be handled specially
							val parentSymbol = idSymbol.owner;
							match(parentSymbol) {
								case PackageSymbol {
									val ysb = java.lang.StringBuilder.new();
									ysb.append(parentSymbol.getFQN());
									ysb.append(".");
									ysb.append("" + NamingConventions.getGeneratedIdentifier(functionExpr.name));
									ysb.append(".invoke$plaid("); // call directly, no need to cast
									ysb.append(makeSeperatedString(yList.map(fn (yItem) =>{ops.getLocalVariable(yItem)}), ","));
									ysb.append(");\n");
									ops.setLocalVariable(y, ysb.toString(), sb);
								}
								default {
									ERROR(functionExpr.token, "Identifier's symbol is a method symbol, but parent is not a PackageSymbol instead it is, "+ parentSymbol.symbolType());
								}
							}
						}
						default {
							val functionExprVarName = idgen.getId();
							ops.createLocalVariable(functionExprVarName, sb, false);
							ops.codegenStmt(ops, functionExpr, sb, idgen, functionExprVarName, classNameCounter);
							ops.setLocalVariable(y, "((plaid.fastruntime.PlaidLambda$" + yList.size() + ")" + functionExprVarName + ").invoke$plaid(" + makeSeperatedString(yList.map(fn (yItem) =>{ops.getLocalVariable(yItem)}), ",") + ")", sb);
						}
					}
				}
				case None {
					ERROR(functionExpr.token, "No symbol found for identifier. (Identifier named " + functionExpr.name + ")");
				}
			}
		}
		default {
			val functionExprVarName = idgen.getId();
            ops.createLocalVariable(functionExprVarName, sb, false);
            ops.codegenStmt(ops, functionExpr, sb, idgen, functionExprVarName, classNameCounter);
            ops.setLocalVariable(y, "((plaid.fastruntime.PlaidLambda$" + yList.size() + ")" + functionExprVarName + ").invoke$plaid(" + makeSeperatedString(yList.map(fn (yItem) =>{ops.getLocalVariable(yItem)}), ",") + ")", sb);
		}
	}
}

method codegenJavaStaticMethod(immutable CodeGenOps ops, immutable ParsedExpr classAST, 
                               immutable Symbol staticMethodSymbol, immutable List argNames, 
                               shared StringBuilder sb, immutable String y) {
    var left = match (classAST) { //get AST mapped to JavaClassSymbol
        case ParsedDereference { classAST.right }
        case ParsedIdentifier { classAST }
        default { ERROR(classAST.token, "Unexpected AST node at left of java constructor") }
    };
    val leftSymbol = symbolForAST(left).value; //if no symbol, something went wrong earlier
    match (leftSymbol) {
        case JavaClassSymbol {
            val javaClassFQN = leftSymbol.getFQN();
            //static methods/constructors found in plaid.generated.<ClassFQN>
            val ysb = java.lang.StringBuilder.new();
            ysb.append("plaid.generated." + javaClassFQN + "." + staticMethodSymbol.name + "(");
            ysb.append(makeSeperatedString(argNames.map(fn (argItem) =>{ops.getLocalVariable(argItem)}), ",")); //normal arguments
            ysb.append(")");
            ops.setLocalVariable(y, ysb.toString(), sb);
            
            //generate static methods for the JavaClassSymbol
            plaid.fastruntime.Util.JAVA_GEN.saveStaticJavaObject(javaClassFQN);
        }
        default {
            ERROR(classAST.token, "non-JavaClassSymbol found as target of java static method or constructor");
        }	
    }
}

method void codegenMain(immutable String methodName, unique StringBuilder sb) {
    sb.append("public static void main(String[] args) {\n");
    sb.append("" + methodName + "();\n");
    sb.append("}\n"); // end main method
}
