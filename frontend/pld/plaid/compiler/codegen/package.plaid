package plaid.compiler.codegen;

import java.lang.StringBuilder;
import java.lang.System;

import plaid.ast.parsed.*;

import plaid.compiler.COMPILER_CONFIGURATION;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_LOW;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.DEBUG_PRIO_HIGH;
import plaid.compiler.symbolForAST;

import plaid.compiler.symbol.*;

import plaid.collections.LinkedList;

import plaid.fastruntime.NamingConventions;
import plaid.fastruntime.CompilerUtil;
import plaid.fastruntime.util.FileGen;

method LOG (immutable String msg) {
	DEBUG(DEBUG_PRIO_LOW, "<CodeGenPass> " + msg);
}

method ERROR(immutable String msg) {
	plaid.compiler.ERROR("<CodeGenPass> INTERNAL ERROR: " + msg);
}

method codegenCU(immutable ParsedCompilationUnit node) {
	val idGen = new IdGen;
	LOG("generating code for ParsedCompilationUnit");
	val qiPackage = node.packageName.identifiers.map( fn(id) => { id.name } );
	val packageString = makeSeperatedString(qiPackage, ".");
	val stringbuilderlist = node.decls.map( fn(item) => {val result = StringBuilder.new(); result} );
	val declsSbList = node.decls.zip(stringbuilderlist);
	//first = decl, second = StringBuilder
	declsSbList.map( fn(item) => { codegenTopLevelDecl(item.first(), packageString, item.second(), idGen); } );
	stringbuilderlist.map( fn(item) => { DEBUG(DEBUG_PRIO_HIGH, item.toString()); } );
	
	//create directories and files for java source output
	declsSbList.map( fn(item) => {
		val declName = item.first().name.name;
		val sep = System.getProperty("file.separator");
		val qiDir = makeSeperatedString(qiPackage, sep);
		val outputDir = COMPILER_CONFIGURATION().tempDir;
		val codeString = item.second().toString();
		FileGen.createOutputFile(declName, outputDir, codeString, qiDir);
	} );
}

method codegenTopLevelDecl(immutable ParsedDecl node, immutable String packageName, shared StringBuilder sb, shared IdGen idgen) {
	LOG("generating code for Top Level Decl");
	match(node) {
		case ParsedConcreteMethodDecl {
			LOG("generating code for top-level concrete method decl");
			sb.append("package " + packageName + ";\n");
			sb.append("public class " + node.name.name + "{\n");
			
			// begin invoke method
			sb.append("public static plaid.fastruntime.PlaidObject " + NamingConventions.GENERATED_METHOD_NAME + "(");
			
			val argStringList = node.arguments.map(fn(arg1) => {"plaid.fastruntime.PlaidObject " + arg1.name.name});
			sb.append(makeSeperatedString(argStringList, ","));
			sb.append(") {\n");
			
			//method body
			codegenMethodBody(node.body, sb, idgen);
			
			sb.append("}\n"); // end invoke method
			
			//begin main method
			if(node.arguments.size() == 0) {
				sb.append("public static void main(String[] args) {\n");
				sb.append("" + NamingConventions.GENERATED_METHOD_NAME + "();\n");
				sb.append("}\n"); // end main method
			};
			
			sb.append("}\n"); // end class
		}
		case ParsedConcreteFieldDecl {
			LOG("generating code for top-level concrete field decl");
		}
		case ParsedConcreteStateDecl {
			LOG("generating code for top-level concrete state decl");
			sb.append("package " + packageName + ";\n");
			sb.append("public class " + node.name.name + "{\n");
			
			val tag = java.util.UUID.randomUUID().toString();

			val fullyQualifiedClassName = packageName + "." + node.name.name;
			val sbStateInitializer = java.lang.StringBuilder.new();
			
			sbStateInitializer.append("plaid.fastruntime.reference.ObjectValueFactory ovf = ");
			sbStateInitializer.append("new plaid.fastruntime.reference.ObjectValueFactory();\n");
			sbStateInitializer.append("ovf.tag(\"" + tag + "\");\n");
			
			match(node.caseOf) {
				case ParsedEmptyQualifiedIdentifier {
					// no -op
				}
				case ParsedQualifiedIdentifier {
					val caseofSymbolOption = symbolForAST(node.caseOf);
					match(caseofSymbolOption) {
						case Some {
							val caseofSymbol = caseofSymbolOption.getValue();
							match(caseofSymbol) {
								case StateSymbol {
									val parent = caseofSymbol.owner;
									//TODO: this will throw an error if class has no parent package
									var packageQualifiedIdentifier = parent.getQualifiedIdentifier();
									val caseofPackageName = makeSeperatedString(packageQualifiedIdentifier.identifiers.map(fn(id) => {id.name}), ".");
									val ovId = idgen.getId();
									sbStateInitializer.append("plaid.fastruntime.ObjectValue " + ovId + " = ");
									val stateSimpleName = node.caseOf.identifiers.get(node.caseOf.identifiers.size() - 1).getValue().name;
									sbStateInitializer.append(caseofPackageName + "." + stateSimpleName + "." + NamingConventions.GENERATED_STATE_NAME + ".getObjectValue();\n");
									sbStateInitializer.append("ovf.parent(" + ovId + ");\n");
								}
								default{
									ERROR("Case of identifier symbol is unexpected value, " + caseOfSymbol.symbolType() + ".");
								}
							}
						} case None {
							ERROR("no symbol for case of identifier");
						}
					}
				}
			};
			
			//generate methods and field
			match(node.stateBinding) {
				
				case ParsedDeclList {
					node.stateBinding.decls.map( fn(innerDecl) => { 
						codegenInnerDecl(innerDecl, sb, idgen);
						match(innerDecl) {
							case ParsedConcreteMethodDecl {
								sbStateInitializer.append("ovf.mthd(\"" + innerDecl.name.name + "\"," 
									+ innerDecl.arguments.size() + ",\"" + fullyQualifiedClassName + "\");\n");
							}
							case ParsedConcreteFieldDecl {
								var settable = "";
								match(innerDecl.specifier) {
									case ParsedValSpecifier {
										settable = "false";
									}
									case ParsedVarSpecifier {
										settable = "true";
									}
								};
								sbStateInitializer.append("ovf.field(" + settable + ", \"" + innerDecl.name.name + "\"," 
									+ "\"" + fullyQualifiedClassName + "\");\n");
							}
							case ParsedAbstractFieldDecl {
								//no-op
							}
							case ParsedAbstractMethodDecl {
								//no-op
							}
							default {
								ERROR("Unsupported inner decl ast node. Node name is " + innerDecl.nodeName());
							}
						}
					} );
				}
				case ParsedWith {
					// add List
				}
				case ParsedFreeze {
					ERROR("Code generator does not support freeze yet. Please check back later.");
				}
				default {
					ERROR("Found unexpected state binding in concrete state declaration.");
				}
			};
			
			match(node.caseOf) {
				case ParsedEmptyQualifiedIdentifier {
					//do nothing
				}
				case ParsedQualifiedIdentifier {
					// add parent to object value
				}
				default {
					ERROR("Found unexpected case of statement in concrete state declaration.");
				}
			};
			
			sbStateInitializer.append("plaid.fastruntime.ObjectValue ov = ovf.value();\n");
			sbStateInitializer.append("" + NamingConventions.GENERATED_STATE_NAME + " = plaid.fastruntime.Util.DISPATCH_GEN.createStateInstance(ov);\n");
			
			//generate static field containing PlaidState
			sb.append("public static final plaid.fastruntime.PlaidState " + NamingConventions.GENERATED_STATE_NAME + ";\n");
			sb.append("static {\n");
			sb.append(sbStateInitializer.toString());
			sb.append("}\n");
			
			sb.append("}\n"); // end class
		}
		default {
			ERROR("Found unexpected node as top-level decl");
		}
	}
}



method codegenInnerDecl(immutable ParsedDecl node,  shared StringBuilder sb, shared IdGen idgen) {
	match (node) {
		case ParsedConcreteMethodDecl {
			// begin invoke method
			sb.append("public static plaid.fastruntime.PlaidObject " + node.name.name + "(");
		    
		    sb.append("plaid.fastruntime.PlaidObject " + NamingConventions.GENERATED_THIS);
		    if(node.arguments.size() > 0) {
		    	sb.append(",");
		    	val argsList = node.arguments.map(fn(arg1) => {" plaid.fastruntime.PlaidObject " + arg1.name.name});
				sb.append(makeSeperatedString(argsList,","));
		    };
		    
			sb.append(") {\n");
			
			//method body
			codegenMethodBody(node.body, sb, idgen);
			
			sb.append("}\n"); // end invoke method
		}
		case ParsedConcreteFieldDecl {
			// generate static field to contain initialization code for fields.
			// begin invoke method
			sb.append("public static plaid.fastruntime.PlaidFieldInitializer " + node.name.name + ";\n"); // field declaration
			
			//preliminiaries
			sb.append("static {\n");
			sb.append(node.name.name + " = new plaid.fastruntime.PlaidFieldInitializer() { \n");
			sb.append("@Override\n");
			sb.append("public plaid.fastruntime.PlaidObject invoke$plaid() {\n");
			
			//body of invoke, generate code for expression, return the value
			val exprVarName = idgen.getId();
			sb.append("plaid.fastruntime.PlaidObject " + exprVarName + ";\n");
			codegenStmt(node.expression, sb, idgen, exprVarName);
			sb.append("return " + exprVarName + ";\n");
			
			//finalize
			sb.append("}\n"); // end invoke$plaidmethod
			sb.append("};\n"); // end FieldInitializer anonymous class
			sb.append("}\n"); // end static
			
		}
		case ParsedAbstractFieldDecl {
			//no-op
		}
		case ParsedAbstractMethodDecl {
			//no-op
		}
		default {
			ERROR("Found unexpected node as inner decl");
		}
	}
}
	
method codegenMethodBody(immutable ParsedBlockExpr node, shared StringBuilder sb, shared IdGen idgen) {
	LOG("generating code for method body block expression");
	val y = idgen.getId();
	sb.append("plaid.fastruntime.PlaidObject " + y + ";\n");
	node.statements.map( fn(item) => { codegenStmt(item, sb, idgen, y); } );
	sb.append("return " + y + ";\n");
}

method codegenStmt(immutable Stmt node, shared StringBuilder sb, shared IdGen idgen, 
		immutable String y) {
	LOG("generating code for statement");
	match(node) {
		case ParsedDereference {
			LOG("generating code for dereference");
			val symbolLeftOption = symbolForAST(node.left);
			val symbolRightOption = symbolForAST(node.right);
			var symbolLeft = symbolLeftOption.getValue();
			match(symbolLeft) {
				case JavaClassSymbol {
					match(symbolRightOption) {
						case Some {
							match(symbolRightOption.getValue()) {
								case JavaStaticFieldSymbol  {
									val parent = symbolLeft.owner;
									
									//TODO: this will throw an error if class has no parent package
									var packageQualifiedIdentifier = parent.getQualifiedIdentifier();
									val packageName = makeSeperatedString(
										packageQualifiedIdentifier.identifiers.map(fn(id) => {id.name}), ".");
									sb.append(y + " = plaid.fastruntime.Util.javaToPlaid(" + 
										packageName +  "." + node.left.name + "." + node.right.name + ");\n");
								}
								default {
									ERROR("Unexpected symbol for the right side of a dereference of Java class");
								}
							}
						}
						default {
							ERROR("Found no symbol for the right side of a dereference of Java class.");
						}
					}
				}
				default {
					// generated code for receiver expression
					val receiverId = idgen.getId();
					sb.append("plaid.fastruntime.PlaidObject " + receiverId + ";\n");
					codegenStmt(node.left, sb, idgen, receiverId);
					
					//getter preliminaries
					val getterName = NamingConventions.getGetterName(node.right.name);
					plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(getterName, 0);
					val ifaceName = NamingConventions.getGeneratedInterfaceFullyQualifiedName(getterName, 0);
					
					//call getter and assign result to y
					sb.append(y + " = ");
					sb.append("("); // parentheses around casted object
					sb.append("(" + ifaceName + ")");
					sb.append("" + receiverId + ".getDispatch()");
					sb.append(")"); // end parentheses around casted object  
					sb.append("." + getterName + "(" + receiverId + ");\n");
				}
			}			
		}
		case ParsedAssignment {
			match(node.target) {
				case ParsedEmptyExpr { // assignment to local variable
				
				}
				default { // assignment to field of an object
					//TODO: deal with assignment to java static fields, very unimportant use case
					
					// generated code for receiver expression
					val receiverId = idgen.getId();
					sb.append("plaid.fastruntime.PlaidObject " + receiverId + ";\n");
					codegenStmt(node.target, sb, idgen, receiverId);
					
					//generate code for value to assign
					val valueId = idgen.getId();
					sb.append("plaid.fastruntime.PlaidObject " + valueId + ";\n");
					codegenStmt(node.value, sb, idgen, valueId);
					
					val setterName = NamingConventions.getSetterName(node.field.name);
					val ifaceName = NamingConventions.getGeneratedInterfaceFullyQualifiedName(setterName, 1);
					sb.append(y + " = ");
					sb.append("("); // paretheses around casted object
					sb.append("(" + ifaceName + ")");
					sb.append("" + receiverId + ".getDispatch()");
					sb.append(")"); // end parentheses around casted object  
					sb.append("." + setterName + "(" + receiverId + ", " + valueId +");\n");
				}
			}
		}
		case ParsedApplication {
			LOG("generating code for application");
			val argumentExpr = node.argument;
			match(argumentExpr) {
				case ParsedArgumentExpr {
					val yList = argumentExpr.args.map( fn(item) => { idgen.getId(); } );
					yList.map( fn(yItem) => { sb.append("plaid.fastruntime.PlaidObject " + yItem + ";\n"); } );
					val argsYs = argumentExpr.args.zip(yList);
					argsYs.map( fn(item) => { codegenStmt(item.first(), sb, idgen, item.second()); } );
					val functionExpr = node.function;
					match(functionExpr) {
						case ParsedDereference {
						
							//check if this is a java constructor or static method if so, it will have a symbol
							val rightSymbolOpt = symbolForAST(functionExpr.right);
							match (rightSymbolOpt) {
							    case Some {
							        val rightSymbol = rightSymbolOpt.value;
							        match (rightSymbol) {
                                        case JavaConstructorSymbol {  //For Java Constructor, just get QI of java class and use java syntax
                                            val leftSymbol = symbolForAST(functionExpr.left).value; //if no symbol, something went wrong earlier
                                            match (leftSymbol) {
                                                case JavaClassSymbol {
                                                    //call constructor and assign to y
                                                    sb.append(y + " = plaid.fastruntime.Util.javaToPlaid(new " + leftSymbol.getFQN());
                                                    //static arguments if appropriate
                                                    val numStaticArgs = leftSymbol.numStaticParams();
                                                    match (numStaticArgs > 0) {
                                                        case True {
                                                            sb.append("<");
                                                            var i = 0;
                                                            while { i < numStaticArgs - 1 } { 
                                                                sb.append("Object,");
                                                                i = i+1;
                                                            };
                                                            sb.append("Object>");
                                                        }
                                                        case False { /* no op */ }
                                                    };
                                                    
                                                    //parameters
                                                    sb.append("(");
                                                    sb.append(makeSeperatedString(yList, ",")); //normal arguments
                                                    sb.append("));\n");
                                                }
                                                default {
                                                    ERROR("<CodeGenPass> non-JavaClassSymbol found as target of java constructor");
                                                }
                                            
                                            }
                                            
                                        }
                                        case JavaStaticMethodSymbol {
                                            ERROR("<CodeGenPass> static java methods not implemented");
                                        }
                                        default {
                                            ERROR("<CodeGenPass> method id unexpectedly has a symbol");
                                        }
                                    }
							    }
							    case None {
							        //generate code for method call
                                    
                                    // preliminaries
                                    val receiverExpr = functionExpr.left;
                                    
                                    
                                    var receiverString = idgen.getId();
                                    sb.append("plaid.fastruntime.PlaidObject " + receiverString + ";\n");
                                    codegenStmt(receiverExpr, sb, idgen, receiverString);
                                    
                                    val methodId = functionExpr.right;
                                    
                                    //assign result to y
                                    sb.append(y + " = ");
                                    
                                    //generate interface
                                    plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(methodId.name, yList.size());
                                    
                                    //cast
                                    sb.append("(");
                                    sb.append("(" + NamingConventions.getGeneratedInterfaceName(methodId.name, yList.size()) + ")");
                                    sb.append(receiverString);
                                    sb.append(".getDispatch()");
                                    sb.append(")");
                                    //.<METHOD_NAME>(<RECEIVER>,<ARGS>)
                                    sb.append("." + methodId.name + "(");
                                    sb.append(receiverString ); // receiver
                                    if(yList.size() > 0) {
                                        sb.append(",");
                                    };
                                    sb.append(makeSeperatedString(yList, ",")); //normal arguments
                                    sb.append(");\n");
							    }
							}
						} 
						case ParsedIdentifier {
							//function application
							sb.append(y +  " = " + functionExpr.name + ".invoke$plaid(");
							sb.append(makeSeperatedString(yList, ","));
							sb.append(");\n");
						}
						default {
							ERROR("<CodeGenPass> Unexpected node type as function field of Application node");
						}
					}
				}
				default {
					ERROR("<CodeGenPass> Unexpected node type as argument field of Application node");
				}
			};
		}
		case ParsedStringLiteral {
			sb.append(y + " = plaid.fastruntime.Util.string(\"" + node.value + "\");\n");
		}
		case ParsedIntLiteral {
			sb.append(y + " = plaid.fastruntime.Util.integer(" + node.value + ");\n");
		}
		case ParsedInfixOperatorExpr {
			//preliminaries
			val op = node.operator;
			val methodName = convertOpStringToMethodName(op.name);
			
			// generate code for receiver
			val receiverString = idgen.getId();
			sb.append("plaid.fastruntime.PlaidObject " + receiverString + ";\n");
			codegenStmt(node.left, sb, idgen, receiverString);
			
			//generate code for argument
			val argId = idgen.getId();
			sb.append("plaid.fastruntime.PlaidObject " + argId + ";\n");
			codegenStmt(node.right, sb, idgen, argId);
			
			
			//assign result to y
			sb.append(y + " = ");
			//generate interface
			//plaid.fastruntime.Util.INTERFACE_GEN.saveInterfaceFile(methodId.name, yList.size());
							
			//cast
			sb.append("(");
			sb.append("(" + NamingConventions.getGeneratedInterfaceName(methodName, 1) + ")");
			sb.append(receiverString);
			sb.append(".getDispatch()");
			sb.append(")");
			//.<METHOD_NAME>(<ARGS>)
			sb.append("." + methodName + "(");
			sb.append(receiverString + ","); // receiver
			sb.append(argId); //normal arguments
			sb.append(");\n");
		}
		case ParsedVarDecl {
			val exprVarName = idgen.getId();
			sb.append("plaid.fastruntime.PlaidObject " + exprVarName + ";\n");
			codegenStmt(node.expr, sb, idgen, exprVarName);
			sb.append("final plaid.fastruntime.PlaidObject " + node.id.name + " = " + exprVarName + ";\n"); 
		}
		case ParsedIdentifier {
			// need to ensure that this is never called if ParsedIdentifier refers to a JavaClass
			// we cannot assign java class value to PlaidObject variable
			val symbolOption = symbolForAST(node);
			match(symbolOption) {
				case Some {
					val symbol = symbolOption.getValue();
					match(symbol) {
						case JavaClassSymbol {
							ERROR("Internal Error. Identifier cannot refer to Java class in ParsedIdentifier case of codegenStmt.");
						}
						case VariableSymbol {
							var varName = "";
							ifElse(node.name.equals("this")) {
								varName = NamingConventions.GENERATED_THIS;
							} 
							{
								varName = node.name;
							};
							sb.append(y + " = " + varName + ";\n");
						}
						default {
							ERROR("Internal Error. Identifier has unexpected symbol '" + symbol.symbolType() + "'.");
						}
					};
				} case None {
					ERROR("No symbol found for identifier. (Identifier named " + node.name + ")");
				}
			};
			
		}
		case ParsedNewInstance {
			val exprVarName = idgen.getId();
			sb.append("plaid.fastruntime.PlaidState " + exprVarName + ";\n");
			codegenStateExpr(node.stateExpr, sb, idgen, exprVarName);
			sb.append(y + " = " + exprVarName + ".instantiate();\n");
		}
		case ParsedMatch {
			val exprVarName = idgen.getId();
			sb.append("plaid.fastruntime.PlaidObject " + exprVarName + ";\n");
			codegenStmt(node.expression, sb, idgen, exprVarName);
			
			val caseStringList = new LinkedList;
			node.caseList.map(fn(c) => {
				match(c) {
					case ParsedPatternCase {
						val patternSymbolOption = symbolForAST(c.pattern);
						match(patternSymbolOption) {
							case Some {
								
								val patternSymbol = patternSymbolOption.getValue();
								match (patternSymbol) {
									case StateSymbol {
										val caseSB = StringBuilder.new();
										caseSB.append("if(" + exprVarName + ".getDispatch().matches(");
										caseSB.append(patternSymbol.getFQN() + "." + NamingConventions.GENERATED_STATE_NAME + ".getTopTag())) {\n");
										val bodyVarName = idgen.getId();
										sb.append("plaid.fastruntime.PlaidObject " + bodyVarName + ";\n");
										codegenStmt(c.body, caseSB, idgen, bodyVarName);
										caseSB.append(y + " = " + bodyVarName + ";\n");
										caseSB.append("}\n");
										caseStringList.add(caseSB.toString());
									}
									default {
										ERROR("Case pattern has unexpected symbol '" + patternSymbol.symbolType() + "'.");
									}
								}
							}
							case None {
								ERROR("No symbol found for pattern in case.")
							}			
						};
					}
					case ParsedDefaultCase {
						val caseSB = StringBuilder.new();
						val bodyVarName = idgen.getId();
						caseSB.append("else {\n");
						caseSB.append("plaid.fastruntime.PlaidObject " + bodyVarName + ";\n");
						codegenStmt(c.body, caseSB, idgen, bodyVarName);
						caseSB.append(y + " = " + bodyVarName + ";\n");
						caseSB.append("}\n");
						caseStringList.add(caseSB.toString());
					}
				};
			});
			val caseString = makeSeperatedString(caseStringList, "else ");
			sb.append(caseString);
			val lastCase = node.caseList.get(node.caseList.size() - 1).getValue();
			match (lastCase) {
				case ParsedPatternCase {
					sb.append("else {\n");
					sb.append("throw new plaid.fastruntime.errors.PlaidIllegalOperationException(\"Pattern match exausted.\");\n");
					sb.append("}");
				}
				case ParsedDefaultCase {
					//no-op
				}
			}
		}
		case ParsedBlockExpr {
			node.statements.map(fn(stmtNode) => {codegenStmt(stmtNode, sb, idgen, y)});
		}
		default {
			ERROR("Unexpected stmt node type,"+ node.nodeName() +" encountered.");
		}
	}
}

method codegenStateExpr(immutable Stmt node, shared StringBuilder sb, shared IdGen idgen, immutable String y) {
	match(node) {
		case ParsedStateRef {
			match(node.stateExpr) {
				case ParsedIdentifier {
					val symbolId = symbolForAST(node.stateExpr).getValue();
					match(symbolId) {
						case StateSymbol {
							val parent = symbolId.owner;
							//TODO: this will throw an error if class has no parent package
							var packageQualifiedIdentifier = parent.getQualifiedIdentifier();
							val packageName = makeSeperatedString(
										packageQualifiedIdentifier.identifiers.map(fn(id) => {id.name}), ".");
							sb.append(y + " = " + packageName + "." + node.stateExpr.name + "." + NamingConventions.GENERATED_STATE_NAME + ";\n");
						}
						default {
							ERROR("Unepected symbol type for state reference. Expected State Symbol, got " + symbolId.symbolType());
						}
					}
				}
				default {
					ERROR("Unepected node type for state state expression. Expected Identifier, got " + node.stateExpr.nodeName());
				}
			}
		}
		default {
			ERROR("Unepected node type for state state expression. Expected StateRef, got " + node.nodeName());
		}
	}
}

method convertOpStringToMethodName(immutable String op) {
	CompilerUtil.convertOpStringToMethodName(op);
}
	
method makeSeperatedString(immutable LinkedList<String> stringList, immutable String sep) {
	ifElse(stringList.size() > 0) {
		val addSep = fn(s1, s2) => {s1 + sep + s2};
		val toReturn = stringList.reduceLeft("", addSep);
		toReturn.substring(sep.length(),toReturn.length());
	}
	{ //
		"";
	}
}