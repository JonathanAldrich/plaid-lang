package plaid.compiler;

import plaid.compiler.types.*;

state Type {
    val immutable Permission permission;
    val immutable Structure structure;
    
    method immutable Boolean ==(immutable Type other)[immutable Type this] {
      this.permission == other.permission && this.structure == other.structure
    }
    
    method immutable String toString()[immutable Type this] {
      this.permission.toString() + " " + this.structure.toString()
    }
    
    method immutable Type downgrade()[immutable Type this] {
      match (this.permission.guaranteesState()) {
        case False {
          match (this.structure) {
            case DynamicStructure { this }
            case TopStructure { this }
            default { makeType(this.permission, TOPSTRUCT) }
          }
        }
        case True { this }
      }
    }
    
    /**
     * We get the leastUpperBound of a type by getting the strongest permission (greatest lower bound)
     *    and the least general type (least upper bound) between the two given types, if these two
     *    values exist.  Otherwise, none is returned.
     */
    method unique Option<immutable Type> leastUpperBound(immutable Type other)[immutable Type this] {
      val permissionLUB = this.permission.greatestLowerBound(other.permission);
      match (permissionLUB) {
        case Some { 
          val structureLUB = this.structure.leastUpperBound(other.structure);
          match (structureLUB) {
            case Some { makeSome(makeType(permissionLUB.value,structureLUB.value)) }
            case None { new None }
          }
        }
        case None { new None }
      }
    } 
}