package plaid.compiler.symbol;

import plaid.compiler.Symbol;
import plaid.compiler.DEBUG;
import plaid.compiler.DEBUG_PRIO_HIGH;
import plaid.compiler.DEBUG_PRIO_MEDIUM;
import plaid.compiler.DEBUG_PRIO_LOW;
import plaid.compiler.types.*;

import plaid.ast.parsed.ASTNode;
import plaid.ast.parsed.TypeDecl;
import plaid.ast.parsed.EmptyType;


state VariableSymbol case of Symbol {
    var immutable ASTNode declaration;
    var immutable Option typeOpt = NONE;

    method updateDeclaration(immutable ASTNode declaration) {
        delSymbolForAST(this.declaration);
        this.declaration = declaration;
        addSymbolForAST(this.declaration);
    }


    override method immutable Boolean ==(immutable Symbol other)[immutable VariableSymbol this] {
        match (other) {
          case VariableSymbol { this.name.equals(other.name) }
          default { false }
        }
    }

    method getStructure() {
        match (this.typeOpt) {
            case None {
                val immutable Type vt = computeStructure();
                this.typeOpt = makeSome(vt);
                vt
            }
            case Some {
                this.typeOpt.value
            }
        }
    }

    method immutable Type computeStructure(){
        match (declaration.varType) {
            case EmptyType {
                printLine("<VariableSymbol> variable declaration has no type information.");
                DYNAMICSTRUCT;
            }
            case TypeDecl {
                DEBUG(DEBUG_PRIO_LOW, "<VariableSymbol> variable declaration has type information.");
                DYNAMICSTRUCT;
            }
            default  {
                DYNAMICSTRUCT;
            }
        }
    }
}