package plaid.compiler.symbol;

import plaid.compiler.Symbol;
import plaid.ast.parsed.ASTNode;
import plaid.compiler.util.*;
import plaid.compiler.types.makeArgSpec;
import plaid.compiler.types.VOID;

import plaid.collections.makeLinkedList;

state MethodSymbol case of DeclSymbol {
    var immutable Option<immutable MethodSignature> methodSigOption = NONE;
    var immutable Symbol thisSymOpt = NONE; 

    /**
     *  returns the symbol mapped to occurrences of this in the body
     *  of the declaration
     *  TODO : update implementation
     */ 
    method immutable Symbol getThisSymbol() { 
        match (this.thisSymOpt) {
            case Some {
                this.thisSymOpt.value
            }
            case None {
                // use dummy symbol for 
                this.thisSymOpt = makeSome(new VariableSymbol { //**** DUMMY this symbol **** Change 
                    val name = "this";
                });
                // try to find this reference in environment
                this.declaration.environment.do(fn (arg) => {
                    val immutable Boolean isThis = arg.name.name.equals("this");
                    match (isThis)  {
                      case True  { 
                          DEBUG(DEBUG_PRIO_MEDIUM, "<MethodSymbol> create 'this' symbol from environment");
                          this.thisSymOpt = symbolForAST(arg);
                      }
                      case False { }
                    }
                });
                
                this.thisSymOpt.value
            }
        } 
    }

    override method immutable Boolean ==(immutable Symbol other)[immutable MethodSymbol this] {
        match (other) {
            case MethodSymbol { this.name.equals(other.name) && this.owner == other.owner }
            default { false }
        }
    }

    method immutable MethodType getSignature() {
        match (this.methodSigOption)  {
            case Some {
                this.methodSigOption.value
            }
            case None {
                val unique SymbolFactory symFac = new SymbolFactory;
                val name = this.name;
                val returnType     = makeTypeFromAST(this.declaration.returnType);
                val staticArgsSpec = makeLinkedList(); //TODO - don't know how these work yet
                val environment    = java.util.HashMap.new();
                
                // translate environment into a map
                // pick out this if it is there
                var receiverSpecOption = new None;
                this.declaration.environment.do(fn (arg) => {
                    val immutable ArgSpec spec = makeArgSpecFromAST(arg.argSpec);
                    val immutable Boolean isThis = arg.name.name.equals("this");
                    val unique Option<immutable Symbol> varSymbolOption = symbolForAST(arg.name);
                    val immutable Symbol varSymbol = match (varSymbolOption) {
                      case Some { varSymbolOption.value }
                      case None { 
                        val newVarSymbol = ifElse (isThis) 
                          { symFac.makeVariableSymbol("this", arg.name) }//TODO: what if not in a method (owner won't be state symbol)
                          { symFac.makeVariableSymbol(arg.name.name,arg.name) };
                        addSymbolForAST(arg.name, newVarSymbol);
                        newVarSymbol  
                      }
                    };
                    ifElse (isThis) 
                      { receiverSpecOption = makeSome(spec) }
                      { environment.put(varSymbol, spec) }
                 });
                                     
                //receiver ArgSpec
                val receiverSpec = match (receiverSpecOption) {
                  case Some { receiverSpecOption.value }
                  case None {
                    match (this.owner) {
                      case PackageSymbol { makeArgSpec(VOID,VOID) } //TODO: receiver type for package methods...
                      case TopSymbol { makeArgSpec(VOID,VOID) }
                      case StateSymbol { 
                        val defaultType = this.owner.defaultStateType();
                        makeArgSpec(defaultType,defaultType);
                      }
                      default { ABORT("Unexpected Symbol type for owner of method Symbol " + this.toString())}
                    }
                  }
                };
                
                //get arguments
                val arguments      = this.declaration.arguments.map(fn (arg) => {
                    val immutable ArgSpec argSpec = makeArgSpecFromAST(arg.argSpec);
                    val unique Option<immutable Symbol> varSymbolOption = symbolForAST(arg.name);
                    val immutable Symbol varSymbol = match (varSymbolOption) {
                      case Some { varSymbolOption.value }
                      case None { 
                        val newVarSymbol = symFac.makeVariableSymbol(arg.name.name,arg.name);
                        addSymbolForAST(arg.name, newVarSymbol);
                        newVarSymbol
                      }
                    };
                    makePair(varSymbol,argSpec);
                });
                val immutable MethodSignature newMethodSig = 
                  makeMethodSignature(returnType, name, arguments, receiverSpec, environment, staticArgsSpec);
                this.methodSigOption = makeSome(newMethodSig);
                newMethodSig 
            }
        }
    }
}