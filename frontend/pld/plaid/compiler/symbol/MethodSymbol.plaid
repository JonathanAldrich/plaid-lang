package plaid.compiler.symbol;

import plaid.compiler.Symbol;
import plaid.ast.parsed.ASTNode;
import plaid.compiler.util.*;
import plaid.compiler.types.makeArgSpec;
import plaid.compiler.types.VOID;

import plaid.collections.makeLinkedList;

state MethodSymbol case of DeclSymbol {
    var immutable ASTNode declaration;
    val immutable Symbol owner;
    val immutable Option<immutable MethodSignature> methodSigOption = NONE;

    method void updateDeclaration(immutable MethodDecl declaration) {
        delSymbolForAST(this.declaration);
        delSymbolForAST(this.declaration.name);
        this.declaration = declaration;
        addSymbolForAST(this.declaration, this);
        addSymbolForAST(this.declaration.name, this);
    }


    override method immutable Boolean ==(immutable Symbol other)[immutable MethodSymbol this] {
        match (other) {
            case MethodSymbol { this.name.equals(other.name) && this.owner == other.owner }
            default { false }
        }
    }

    method immutable MethodType getSignature() {
        match (this.methodSigOption)  {
            case Some {
                this.methodSigOption.value
            }
            case None {
                val name = this.name;
                val returnType     = makeTypeFromAST(this.declaration.returnType);
                val staticArgsSpec = makeLinkedList(); //TODO - don't know how these work yet
                val arguments      = this.declaration.arguments.map(fn (arg) => makeArgSpecFromAST(arg.argSpec)); 
                val environment    = java.util.HashMap.new();
                
                // translate environment into a map
                this.declaration.environment.do(fn (arg) => {
                                        val spec = makeArgSpecFromAST(arg.argSpec);
                                        val name = arg.name.name;
                                        environment.put(name,spec);
                                     });
                                     
               //TODO: clean this up with parser
                val receiverSpec = match (environment.containsKey("this")) {
                  case True { environment.remove("this") }
                  case False {
                    match (this.owner) {
                      case PackageSymbol { makeArgSpec(VOID,VOID) } //TODO: receiver type for package methods...
                      case TopSymbol { makeArgSpec(VOID,VOID) }
                      case StateSymbol { 
                        val defaultType = this.owner.defaultStateType();
                        makeArgSpec(defaultType,defaultType);
                      }
                      //default { makeArgSpec(VOID,VOID) }
                    }
                  }
                }; 
                
                val immutable MethodSignature newMethodSig = 
                  makeMethodSignature(returnType, name, arguments, receiverSpec, environment, staticArgsSpec);
                this.methodSigOption = makeSome(newMethodSig);
                newMethodSig 
            }
        }
    }
}