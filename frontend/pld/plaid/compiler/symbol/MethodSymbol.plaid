package plaid.compiler.symbol;

import plaid.compiler.Symbol;
import plaid.ast.parsed.ASTNode;
import plaid.compiler.util.*;
import plaid.compiler.types.makeArgSpec;
import plaid.compiler.types.VOID;

import plaid.collections.makeLinkedList;

state MethodSymbol case of DeclSymbol {
    var immutable ASTNode declaration;
    val immutable Symbol owner;
    var immutable Option<immutable MethodSignature> methodSigOption = NONE;

    method void updateDeclaration(immutable MethodDecl declaration) {
        //delSymbolForAST(this.declaration);
        //delSymbolForAST(this.declaration.name);
        this.declaration = declaration;
        addSymbolForAST(this.declaration, this);
        addSymbolForAST(this.declaration.name, this);
    }


    override method immutable Boolean ==(immutable Symbol other)[immutable MethodSymbol this] {
        match (other) {
            case MethodSymbol { this.name.equals(other.name) && this.owner == other.owner }
            default { false }
        }
    }

    method immutable MethodType getSignature() {
        match (this.methodSigOption)  {
            case Some {
                this.methodSigOption.value
            }
            case None {
                val unique SymbolFactory symFac = new SymbolFactory;
                val name = this.name;
                val returnType     = makeTypeFromAST(this.declaration.returnType);
                val staticArgsSpec = makeLinkedList(); //TODO - don't know how these work yet
                val environment    = java.util.HashMap.new();
                
                // translate environment into a map
                // pick out this if it is there
                var receiverSpecOption = new None;
                this.declaration.environment.do(fn (arg) => {
                    val immutable ArgSpec spec = makeArgSpecFromAST(arg.argSpec);
                    val immutable Boolean isThis = arg.name.name.equals("this");
                    val unique Option<immutable Symbol> varSymbolOption = symbolForAST(arg.name);
                    val immutable Symbol varSymbol = match (varSymbolOption) {
                      case Some { varSymbolOption.value }
                      case None { 
                        val newVarSymbol = ifElse (isThis) 
                          { symFac.makeVariableSymbol("this", arg.name) }//TODO: what if not in a method (owner won't be state symbol)
                          { symFac.makeVariableSymbol(arg.name.name,arg.name) };
                        addSymbolForAST(arg.name, newVarSymbol);
                        newVarSymbol  
                      }
                    };
                    ifElse (isThis) 
                      { receiverSpecOption = makeSome(spec) }
                      { environment.put(varSymbol, spec) }
                 });
                                     
                //receiver ArgSpec
                val receiverSpec = match (receiverSpecOption) {
                  case Some { receiverSpecOption.value }
                  case None {
                    match (this.owner) {
                      case PackageSymbol { makeArgSpec(VOID,VOID) } //TODO: receiver type for package methods...
                      case TopSymbol { makeArgSpec(VOID,VOID) }
                      case StateSymbol { 
                        val defaultType = this.owner.defaultStateType();
                        makeArgSpec(defaultType,defaultType);
                      }
                      default { ABORT("Unexpected Symbol type for owner of method Symbol " + this.toString())}
                    }
                  }
                };
                
                //get arguments
                val arguments      = this.declaration.arguments.map(fn (arg) => {
                    val immutable ArgSpec argSpec = makeArgSpecFromAST(arg.argSpec);
                    val unique Option<immutable Symbol> varSymbolOption = symbolForAST(arg.name);
                    val immutable Symbol varSymbol = match (varSymbolOption) {
                      case Some { varSymbolOption.value }
                      case None { 
                        val newVarSymbol = symFac.makeVariableSymbol(arg.name.name,arg.name);
                        addSymbolForAST(arg.name, newVarSymbol);
                        newVarSymbol
                      }
                    };
                    makePair(varSymbol,argSpec);
                });
                val immutable MethodSignature newMethodSig = 
                  makeMethodSignature(returnType, name, arguments, receiverSpec, environment, staticArgsSpec);
                this.methodSigOption = makeSome(newMethodSig);
                newMethodSig 
            }
        }
    }
}