package plaid.compiler.typechecker;

import plaid.compiler.*;
import plaid.compiler.types.*;
import plaid.compiler.permissions.*;
import plaid.compiler.util.makeTypeFromAST;
import plaid.compiler.util.makePermissionFromAST;
import plaid.ast.util.makeStringFromQualifiedIdentifier;
import plaid.ast.parsed.*;
import plaid.compiler.aeminium.*;
import plaid.compiler.util.*;
import plaid.compiler.symbol.*;


import plaid.collections.makeLinkedList;
import plaid.collections.LinkedList;

/**
 * To typecheck an expression, we attempt to give the Expression exp the permission needed Perm
 * given the context ctx.
 *
 * If there are no errors, we return an updated linear context along with the type
 * of the expression and an expression list
 *
 * NOTE: the linear context is treated imperatively and so is destructively updated
 *       during each typechecking case.  However, in the case of match we may
 *       need to merge multiple contexts together.  In this case, the returned
 *       context is a new context.  Thus, we cannot assume that the returned
 *       context is the same object as the incoming context.
 *
 */
method unique ?TypecheckResult typecheckExpression(unique LinearContext ctx, 
                                                   immutable Permission neededPerm, 
                                                   immutable ParsedExpression exp) 
{
  //DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check '" + exp.nodeName() + "' with ctx =\n" + ctx.toString());
  match (exp) {
    /*case ParsedApplication {
      ABORT("Lambdas not implemented in typechecker");
    }*/
    case ParsedAssignment {
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedAssignment");
      match (neededPerm) {
        case NonePermission {
          match (exp.target) {
            case ParsedEmptyExpr { //local-assign
              val unique Option<immutable VariableSymbol> localVarSymbolOption = symbolForAST(exp.field);
              match (localVarSymbolOption) {
                case Some {
                  match ( localVarSymbolOption.value.isVar() ) {
                      case True {
                        match (ctx.containsSymbol(localVarSymbolOption.value)) {
                          case True {
                            val immutable Type neededType = localVarSymbolOption.value.getDeclaredType();
                            val unique ?TypecheckResult valueResult = typecheckExpression(ctx, neededType.permission, exp.value);
                            match (valueResult) {
                              case TypecheckResult {
                                match (valueResult.expType.isSubTypeOf(neededType)) {
                                  case True { 
                                    val unique LinearContext newCtx = valueResult.ctxResult;
                                    newCtx.update(localVarSymbolOption.value, neededType);
                                    makeTypecheckResult(VOID, newCtx, valueResult.sourceLocList) 
                                  }
                                  case False { 
                                      report_ERROR(exp.token, 
                                          "T_ASSIGN_WRONG_TYPE", "need " + neededType.toString() + ", got " +
                                          valueResult.expType.toString(), "typecheckAssignment");
                                      unit;
                                  }
                                }
                              }
                              default { unit }
                            }
                          }
                          case False {
                            report_ERROR(exp.token, "T_NOT_IN_SCOPE", localVarSymbolOption.value.name, "typecheckAssignment");
                            unit;
                          }
                        }
                      }
                      case False { 
                      	report_ERROR(exp.token, 
                      				"T_ASSIGN_LOCAL_VAL", localVarSymbolOption.value.name, 
                      				"typecheckAssignment");
                      	unit;
                      }
                  };
                }
                case None {
                  report_ERROR(exp.field.token, "SYM_NOT_FOUND", "", "typecheckAssignment");
                  unit;
                }
              }
            }
            case ParsedIdentifier { //field-Assign
              val unique Option<immutable VariableSymbol> targetVarSymbolOption = symbolForAST(exp.target);
              match (targetVarSymbolOption) {
                case Some {
                  match (ctx.containsSymbol(targetVarSymbolOption.value)) {
                    case True {
                      val immutable Type targetType = ctx.get(targetVarSymbolOption.value);
                      val immutable Boolean assignablePermission = match ( targetType.permission ) {
                          case SharedPermission { true }
                          case UniquePermission { true }
                          case UnsplitablePermission { 
                              match ( targetType.permission.thePerm ) {
                                  case SharedPermission { true }
                                  case UniquePermission { true }
                                  default { false }
                              }
                          }
                          default { false }
                      };
                      //match (targetType.permission.isSubPermOf(LOCALSHARED)) { //need at least local shared to assign to a field
                      match ( assignablePermission ) {  
                        case True {
                          // check for proper synronization of shared permission
                          var datagroupDepInfo = unit;
                          var datagroupSymbol = unit;
                          val checkFn = fn (expr) => {
                               if ( AEMINIUM_MODE() ) {
                                   match ( expr ) {
                                       case AbstractEmptyExpression { DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> Do not compute dependencies for global data group.") }
                                       default {
                                           datagroupSymbol = getSymbolForAbstractExpression(expr);
                                           match ( datagroupSymbol ) {
                                               case Symbol {
                                                   val depInfoOpt = depInfoForSymbol(datagroupSymbol);
                                                   match ( depInfoOpt ) {
                                                       case Some { datagroupDepInfo = depInfoOpt.value  }
                                                       default { ABORT("<typecheckExpression> Cannot find dependency information for " + expr.toString()) } 
                                                   }
                                               }
                                               default { ABORT("Cannot find symbol for abstract expression.") }
                                            };
                                       } 
                                   }
                               };
                               val gp = ctx.getDatagroupPermission(expr);
                               match ( gp ) {
                                   case ProtectedGroupPermission { true }
                                   case ExclusiveGroupPermission { true }
                                   case SharedGroupPermission { ABORT("Cannot use shared group permission to write field") } 
                                   default { ABORT("Cannot find group permission for '" + expr.toString() + "'") }
                               };
                          };
                          val immutable Boolean assignOk = match (targetType.permission) {
                              case SharedPermission { checkFn( targetType.permission.groupExpr ) } 
                              case LocalPermission {
                                  match (targetType.permission.thePerm) {
                                      case SharedPermission { checkFn( targetType.permission.thePerm.groupExpr ) } 
                                      default { true }
                                  }
                              }
                              case UnsplitablePermission {
                                  match (targetType.permission.thePerm) {
                                      case SharedPermission { checkFn( targetType.permission.thePerm.groupExpr ) } 
                                      default { true }
                                  }
                              }
                              case UniquePermission { true } 
                              default { false }
                          };
                          
                          match (assignOk) {
                            case True {
                              match(targetType.structure) {
                                case ObjectStructure {
                                  val unique Option<immutable Signature> fieldSigOption = targetType.structure.getMember(exp.field.name);
                                  match (fieldSigOption) {
                                    case Some {
                                      val substMap = targetType.structure.getSubstitutionMap();
                                      val substFieldSig = substituteSignature(fieldSigOption.value, substMap);
                                      match (substFieldSig) {
                                        case FieldSignature {
                                          val immutable Type neededType = substFieldSig.getDeclaredType();
                                          val unique ?TypecheckResult valueResult = typecheckExpression(ctx, neededType.permission, exp.value);
                                          match (valueResult) {
                                            case TypecheckResult {
                                              match (valueResult.expType.isSubTypeOf(neededType)) {
                                                case True { 
                                                  val immutable ?ObjectStructure newStructure = targetType.structure.assignToField(exp.field.name, exp.token); //SUBROUTINE
                                                  match (newStructure) {
                                                    case ObjectStructure {
                                                      val unique LinearContext newCtx = valueResult.ctxResult;
                                                      newCtx.update(targetVarSymbolOption.value, makeType(targetType.permission, newStructure));
                                                      
                                                      var immutable Boolean dependencyOk = true;
                                                      
                                                      if ( AEMINIUM_MODE() ) {
                                                          val shared DependencyInformation assignInfo = makeASTInformation(exp);
                                                          val shared ?DependencyInformation targetInfo = match (depInfoForSymbol(targetVarSymbolOption.value)) {
                                                              case Some { depInfoForSymbol(targetVarSymbolOption.value).value }
                                                              case None { 
                                                                dependencyOk = false;
                                                                report_ERROR(exp.target.token, "A_DEPENDENCY_MISSING", " for " + targetVarSymbolOption.value.name, "typecheckAssignment");
                                                                unit;
                                                              }
                                                          };
                                                          val shared ?DependencyInformation valueInfo = match ( depInfoForAST(exp.value) ) {
                                                              case Some { depInfoForAST(exp.value).value }
                                                              case None { 
                                                                dependencyOk = false;
                                                                report_ERROR(exp.value.token, "A_DEPENDENCY_MISSING", " for assigned value", "typecheckAssignment");
                                                                unit;
                                                              } 
                                                          };
                                                          match (valueInfo) { case DependencyInformation { addDependency(assignInfo, valueInfo); } default { /*no op*/ } };
                                                          match (targetInfo) { case DependencyInformation { addDependency(assignInfo, targetInfo); } default { /*no op*/ } };
                                                          match (datagroupDepInfo) { case DependencyInformation { 
                                                            addDependency(assignInfo, datagroupDepInfo);
                                                            setDepInfoForSymbol(datagroupSymbol, assignInfo);
                                                          } default { /* nop */ }};
                                                          setDepInfoForSymbol(targetVarSymbolOption.value, assignInfo);
                                                          addDepInfoForAST(exp, assignInfo);
                                                          
                                                      };
                                                      
                                                      match (dependencyOk) {
                                                        case True { makeTypecheckResult(VOID, newCtx, makeLinkedList()) }
                                                        case False { unit }
                                                      }
                                                    }
                                                    default { unit }
                                                  }
                                                }
                                                case False { 
                                                    report_ERROR(exp.token, "T_ASSIGN_WRONG_TYPE", "need " + neededType.toString() + ", got " +
                      				                    valueResult.expType.toString(), "typecheckAssignment");
                      				                unit;
                                                }
                                              }
                                            }
                                            default { unit }
                                          }
                                        }
                                        case MethodSignature {
                                          report_ERROR(exp.field.token, "T_ASSIGN_FIELD_METHOD", targetType.structure.toString() + "." + exp.field.name, "typecheckAssignment");
                      				      unit;
                                        }
                                        default {
                                          report_ERROR(exp.field.token, "T_ASSIGN_FIELD_OTHER", targetType.structure.toString() + "." + exp.field.name, "typecheckAssignment");
                      				      unit;
                                        }
                                      }
                                    }
                                    case None { 
                                      report_ERROR(exp.field.token, "T_ASSIGN_FIELD_MISSING", targetType.structure.toString() + "." + exp.field.name, "typecheckAssignment");
                      				  unit;
                                    }
                                  } 
                                }
                                default { 
                                    report_ERROR(exp.target.token, "T_ASSIGN_FIELD_NON_OBJECT_STRUCTURE", targetType.structure.toString(), "typecheckAssignment");
                                    unit;
                                }
                              }
                            }
                            case False { unit }
                          }
                        }
                        case False { 
                            report_ERROR(exp.target.token, "T_ASSIGN_FIELD_NOT_ENOUGH_PERMISSION", targetType.permission.toString(), "typecheckAssignment");
                            unit;
                        }
                      }
                    }
                    case False { 
                        report_ERROR(exp.target.token, "T_NOT_IN_SCOPE", targetVarSymbolOption.value.name, "typecheckAssignment" ); 
                        unit;
                    }
                  }
                }
                case None { 
                  report_ERROR(exp.field.token, "SYM_NOT_FOUND", "", "typecheckAssignment");
                  unit;
                }
              }
            }
            default { 
                report_ERROR(exp.target.token, "T_ASSIGN_FIELD_WRONG_TARGET", "", "typecheckAssignment");
                unit
            }
          }  
        }
        default {
            report_ERROR(exp.target.token, "T_ASSIGN_PERM", "none => " + neededPerm.toString() + " x ???", "typecheckAssignment");
            unit
        }
      }
    }
    case ParsedAtomicBlock {
        DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedAtomicBlock");
        val shared DependencyInformation atomicEnter = makeAtomicEnterInformation(exp);
        
        // create group expressions
        val groupExprs = exp.datagroups.map( fn (grp) => {
            val exp = makeAbstractExpressionFromAST(grp);
            match ( exp ) {
                case AbstractExpression { exp }
                default { ABORT("Cannot convert AtomicBlock argument to abstract exression.") }
            }
        });
        
        if ( groupExprs.size() == 0 ) {
            val absExpr = makeAbstractExpressionFromAST(new ParsedEmptyExpr{ val token = EMPTY_TOKEN; });
            match (absExpr) {
                case AbstractExpression { groupExprs.add(absExpr) }
                default { ABORT("Cannot create empty expression for global data group.") } 
            };
        };
        
        // check correct type
        groupExprs.do(fn (exp) => {
            match (exp.getStructure()  == DATAGROUPSTRUCT ) {
                case True { /* nop */ }
                default { ABORT("Atomic block argument '" + exp.toString() + "' has wrong type : "  + exp.getStructure() ) }
            }
        });
        
        // check if have a nested block
        var nested = false;
        groupExprs.do(fn (exp) =>{
            val gp = ctx.getDatagroupPermission(exp);
            match (gp) {
                case ProtectedGroupPermission { nested = true }
                case GroupPermission { /* noop */ }
                default { ABORT("Cannot find group permission for '" + exp.toString() + "'") } 
            }
        });

        
        match (nested) {
            case True {
                report_ERROR(exp.target.token, "A_NESTED_ATOMIC", "", "typecheckAtomicBlock");
                unit;
            }
            case False { 
            
                // fix linear context
                groupExprs.do( fn (grp) => {
                    val gp = ctx.getDatagroupPermission(grp);
                    match (gp) {
                        case SharedGroupPermission { 
                            // update 
                            ctx.updateDatagroupPermission(grp, PROTECTEDGP);
                        }
                        default { 
                            ABORT("Cannot split '" + gp.toString() + "' to 'protected'");
                        }
                    }
                });
            
                
                val symbols = new SymbolCollector;
                exp.body.accept(symbols); 
                     
                var immutable Boolean dependencyOk = true;    
                     
                if ( AEMINIUM_MODE() ) {
                    // attach to static expressions
                    exp.datagroups.do(fn (grp) =>{
                        val symbol = match ( makeAbstractExpressionFromAST(grp) ) {
                            case AbstractExpression { getSymbolForAbstractExpression(makeAbstractExpressionFromAST(grp)); }
                            default { ABORT("Cannot get symbol for abstract expression.") }
                        };
                        match (symbol) {
                            case Symbol {
                                DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> make atomic block depend on " + symbol.name);
                                val depInfo = match ( depInfoForSymbol(symbol) ) {
                                    case Some { depInfoForSymbol(symbol).value }
                                    default { ABORT("Cannot find dependency information for symbol " + symbol.name) }
                                };
                                addDependency(atomicEnter, depInfo);
                                setDepInfoForSymbol(symbol, atomicEnter);
                            }
                            default {
                                report_ERROR(grp.token, "", "Cannot find symbol for static argument.", "typecheckAtomicBlock");
                            }
                        }
                    });
                    // attached to used symbols
                    val it = symbols.externalSymbols.iterator();
                    while { it.hasNext() }{
                        val shared Symbol nextSym = it.next();
                        val shared ?DependencyInformation nextInfo = match (depInfoForSymbol(nextSym)) {
                            case Some { depInfoForSymbol(nextSym).value }
                            case None { 
                                dependencyOk = false;
                                report_ERROR(exp.target.token, "A_DEPENDENCY_MISSING", " for " + tnextSym.name, "typecheckAtomicBlock");
                                unit;
                            }
                        };
                        match (nextInfo) { case DependencyInformation { addDependency(atomicEnter, nextInfo); } default { /* no op */ } };
                        setDepInfoForSymbol(nextSym, atomicEnter);
                    };
                };
        
                ctx.incInAtomic();
                val unique ?TypecheckResult typecheckResult = typecheckExpression(ctx, neededPerm, exp.body);
                
                match (typecheckResult) {
                    case TypecheckResult {
                        if ( AEMINIUM_MODE() ) {
                             val shared DependencyInformation atomicLeave = makeAtomicLeaveInformation(atomicEnter);
                             val it = symbols.externalSymbols.iterator();
                             while { it.hasNext() }{
                                val shared Symbol nextSym = it.next();
                                val shared ?DependencyInformation nextInfo = match (depInfoForSymbol(nextSym)) {
                                    case Some { depInfoForSymbol(nextSym).value }
                                    case None { 
                                        dependencyOk = false;
                                        report_ERROR(exp.target.token, "A_DEPENDENCY_MISSING", " for " + nextSym.name, "typecheckAtomicBlock");
                                    }
                                };
                                match (nextInfo) { case DependencyInformation { addDependency(atomicLeave, nextInfo); } default { /* no op */ } };
                                setDepInfoForSymbol(nextSym, atomicLeave);
                             };
                             
                             val shared ?DependencyInformation bodyInfo = match (depInfoForAST(exp.body) ) {
                                case Some { depInfoForAST(exp.body).value }
                                case None { 
                                    dependencyOk = false;
                                    report_ERROR(exp.target.token, "A_DEPENDENCY_MISSING", " for atomic block body", "typecheckAtomicBlock");
                                    unit
                                }
                             };
                             match (bodyInfo) { case DependencyInformation { addDependency(atomicLeave, bodyInfo); } default { /* no op */ } };
                             addDependency(atomicLeave, atomicEnter);
                             addDepInfoForAST(exp, atomicLeave);
                             
                             exp.datagroups.do(fn (grp) =>{
                                val symbol = match ( makeAbstractExpressionFromAST(grp) ) {
                                    case AbstractExpression { getSymbolForAbstractExpression(makeAbstractExpressionFromAST(grp)); }
                                    default { ABORT("Cannot get symbol for abstract expression.") }
                                };
                                match (symbol) {
                                    case Symbol {
                                        DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> make atomic block depend on " + symbol.name);
                                        val depInfo = match ( depInfoForSymbol(symbol) ) {
                                            case Some { depInfoForSymbol(symbol).value }
                                            default { ABORT("Cannot find dependency information for symbol " + symbol.name) }
                                        };
                                        addDependency(atomicLeave, depInfo);
                                        setDepInfoForSymbol(symbol, atomicLeave);
                                    }
                                    default {
                                        report_ERROR(grp.token, "", "Cannot find symbol for static argument.", "typecheckAtomicBlock");
                                    }
                                }
                            });
                        };
                        
                        match (dependencyOk) {
                            case True {
                                typecheckResult.ctxResult.decInAtomic();
                                groupExprs.do( fn (grp) => { ctx.updateDatagroupPermission(grp, SHAREDGP) });   
                                typecheckResult
                            }
                            case False { unit }
                        }
                    }
                    default {
                        unit;
                    }
                };
            }
        };
        
    }
    case ParsedBlockExpr {
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedBlockExpr");
      val immutable Integer blockSize = exp.statements.size();
      var immutable Integer count = 1;
      val /*unique LinkedList<immutable Pair<immutable Symbol, immutable LinkedList<immutable SourceLocation>>>*/ introducedLocalVars = makeLinkedList();
      val unique TypecheckResult seedResult = makeTypecheckResult(VOID, ctx, makeLinkedList());
      var immutable Boolean dependencyOk = true;
      
      val immutable Boolean methodBlock = ctx.methodBlock;
      ctx.methodBlock = false;
      val shared DependencyInformation blockInfo = makeASTInformation(exp);
      if ( AEMINIUM_MODE() ) {
          addDepInfoForAST(exp, blockInfo);
      };
      
      val unique ?TypecheckResult blockResult = exp.statements.reduce(seedResult,fn (prevResult,stmt)
                           [immutable Integer count, immutable Permission neededPerm, unique LinkedList/*<...>*/ introducedLocalVars] => {
        match (prevResult) {
          case TypecheckResult {
			val immutable Permission stmtNeededPerm = match (count == blockSize) {
			  case True { neededPerm } //last statement in list gets neededPerm
			  case False { NONEP }  // all others get NONEP
			};
			count = count+1;
			
			val unique ?TypecheckResult stmtResult = typecheckExpression(prevResult.ctxResult,stmtNeededPerm,stmt);
			
			match (stmtResult) {
			  case TypecheckResult {
				

				
				match (dependencyOk) {
				  case True {  
                    match (stmt) {
                      case ParsedVarDecl { //this should be removed from scope and permissions returned at the end of the block
                        match (haveSymbolForAST(stmt)) {
                          case True {
                            introducedLocalVars.addFirst(makePair(symbolForAST(stmt).value,stmtResult.sourceLocList));                
                            makeTypecheckResult(VOID, stmtResult.ctxResult, makeLinkedList());  //take source locations out
                          }
                          case False { 
                            report_ERROR(stmt.token, "SYM_NOT_FOUND", "", "typecheckBlockExpr");
                            unit;
                          }
                        }
                      }
                      default { stmtResult }
                    };
                  }
                  case False { unit; }
                }
			  }
			  default { unit } //stop typechecking the block once we found an error
			}
		  }
		  default { unit }  //stop typechecking the block once we found an error
		}
      });
      
      match (blockResult) {
      	case TypecheckResult {
		  //remove introduced variables from scope, returning to their source locations,
		  //this updates blockResult.ctxResult, which gets returned  (will never create a new context - no merging) 
		  val unique ?TypecheckResult afterReturns = introducedLocalVars.reduce(blockResult, fn (returningResult, pairToRet) => {
			val immutable Symbol symLeavingScope = pairToRet.fst;
			match (returningResult) {
				case TypecheckResult {
					val unique ?LinearContext updatedCtx = match (returningResult.ctxResult.containsSymbol(symLeavingScope)) {
					  case True {
						val immutable Type restoreType = returningResult.ctxResult.remove(symLeavingScope);
						
						val immutable Boolean returnsOk = pairToRet.snd.reduceLeft(true, fn (ok, sourceLoc) => { 
							val immutable Boolean restored = match (sourceLoc.restoreToLoc(restoreType, returningResult.ctxResult)) {
								case True { true }
								case False { //can we do better for this error message, esp on token.
									val immutable ?Type badReturnTypeOpt = sourceLoc.locationType(returningResult.ctxResult);
									val immutable String badReturnTypeString = match (badReturnTypeOpt) {
										case Type { badReturnTypeOpt.toString(); }
										default { "UNKNOWN" }
									};
									
									report_ERROR(exp.token,""," return of type " + restoreType.toString() +
										" to variable " + symLeavingScope.name.toString() + "'s location " + 
										sourceLoc.toString() + " of type " + badReturnTypeString + " failed",
										"typecheckBlockExpression");
									false
								}
							};
							restored && ok;
						});
						match (returnsOk) {
							case True { returningResult.ctxResult }
							case False { unit }
						}
					  }
					  case False {  
						report_ERROR(exp.token, "SCOPING_ERROR", "", "typecheckBlockExpression"); 
						unit
					  }
					};
					//also remove variables going out of scope from SLL
					match (updatedCtx) {
						case LinearContext {
							val immutable LinkedList updatedSLL = returningResult.sourceLocList.reject(fn (loc) => {
									match (loc) {
										case VarSourceLocation {
											match (loc.varSymbol == symLeavingScope) {
												case True { true }
												case False { false }
											}
										}
										case FieldSourceLocation {
											match (loc.objectVarSymbol == symLeavingScope) {
												case True { true }
												case False { false }
											}
										}
									}
								
							});
							makeTypecheckResult(returningResult.expType, updatedCtx, updatedSLL);
						}
						default { unit }
					}
				}
				default { unit }
			}
		  });
		  
		  if ( AEMINIUM_MODE() ) {
		      count = 1;
		      exp.statements.do ( fn (stmt) => {
		            count = count + 1;
					match (count == (blockSize+1)) {
						case True {
						    val dependOnLastStmt = match (methodBlock) {
						        case True {
						            match (neededPerm) {
						                case NonePermission {
						                    DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> do not depend on last statement of method because we do not require its return value.");
						                    false;
						                }
						                default { true } 
						            }
						        }
						        default { true } 
						    };
						    if ( dependOnLastStmt ) {
                                val shared ?DependencyInformation stmtInfo = match (depInfoForAST(stmt)) {
                                    case Some { depInfoForAST(stmt).value }
                                    case None { 
                                        dependencyOk = false;
                                        report_ERROR(stmt.token, "A_DEPENDENCY_MISSING", " for statement " + count + " in block " + stmt.nodeName() , "typecheckBlockExpr");
                                        unit
                                    }
                                };
                                match (stmtInfo) { case DependencyInformation { addDependency(blockInfo, stmtInfo); } default { /* no op */ } };
						    };
						}
						case False {
							if ( methodBlock == false ) {
								val shared DependencyInformation stmtInfo = match (depInfoForAST(stmt)) {
									case Some { depInfoForAST(stmt).value }
									case None { 
                                        dependencyOk = false;
                                        report_ERROR(exp.target.token, "A_DEPENDENCY_MISSING", " for last statement in block", "typecheckBlockExpr");
                                        unit
                                    }
								};
								match (stmtInfo) { case DependencyInformation { addDependency(blockInfo, stmtInfo); } default { /* no op */ } };                  
							}
						}
					};      
		      });
		  };
		  match (dependencyOk) {
		    case True {
		    	match (afterReturns) {
		    		case TypecheckResult {
		    			afterReturns.ctxResult.methodBlock = methodBlock;  
		    			afterReturns;
		    		}
		    		default { unit }	
		    	}
	    	}
	    	case False {
	    	  unit
	    	}
	      }
		}
		default { unit }
	  }
      
    }
    case ParsedCast { // Cast requires dynamic permission - may want to generalize this later - probably could also grab none?
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>(ParsedCast) check ParsedCast");
      val unique ?TypecheckResult castExpResult = typecheckExpression(ctx, DYNAMICP, exp.expression);
      match (castExpResult) {
      	case TypecheckResult {  
	      makeTypecheckResult(makeTypeFromAST(exp.targetType), castExpResult.resultCtx, makeLinkedList());
	    }
	    default { unit }
	  }
    }
    case ParsedDereference { /* Chained Dereferences not implemented currently */
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>(ParsedDereference) check ParsedDereference");
      match (exp.left) {
        case ParsedIdentifier {
          val unique Option<immutable Symbol> targetSymbolOption = symbolForAST(exp.left);
          match (targetSymbolOption) {
            case Some {
              val immutable Symbol targetSymbol = targetSymbolOption.value;
              match (ctx.containsSymbol(targetSymbol)) {
                case True {
                  val immutable Type targetType = ctx.get(targetSymbol);
                  val immutable Option<immutable Signature> fieldSigOption = targetType.structure.getMember(exp.right.name);
                  match ( fieldSigOption ) {
                      case Some { /* nop */ } 
                      default { ABORT("Cannot find field signature.") }
                  };
                  
                  // check for constant access with symmetric permission
                  val accessSymConstant = fieldSigOption.value.getIsVar() == false;// && fieldSigOption.value.hasSymmetricPermission();

                  // check for proper synronization of shared 
                  var datagroupDepInfo = unit;
                  var datagroupSymbol = unit;
                  val checkFn = fn (expr) => {
                       if ( AEMINIUM_MODE() ) {
                           match ( expr ) {
                               case AbstractEmptyExpression { DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> skip global data group dependency") }
                               default {
                                    datagroupSymbol = getSymbolForAbstractExpression(expr);
                                    match ( datagroupSymbol ) {
                                        case Symbol {
                                            val depInfoOpt = depInfoForSymbol(datagroupSymbol);
                                            match ( depInfoOpt ) {
                                                case Some { datagroupDepInfo = depInfoOpt.value }
                                                default { ABORT("<typecheckExpression> Cannnot find dependency information for " + expr.toString()) }
                                            };
                                        }
                                        default { ABORT("Cannot find symbol for abstract expression.") }
                                    }
                               }
                           };
                       };
                       val gp = ctx.getDatagroupPermission(expr);
                       DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>     found " + gp.toString() + " for " + expr.toString());
                       match ( gp ) {
                           case ProtectedGroupPermission { true }
                           case ExclusiveGroupPermission { true }
                           case SharedGroupPermission { ABORT("Cannot use shared group permission to read field") } 
                           default { ABORT("Cannot find group permission for '" + expr.toString() + "'") }
                       };
                  };
                  
                  val immutable Boolean allowAccess = ifElse ( accessSymConstant == false  ) {
                      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>   do not access a contant field");
                      match (neededPerm) {
                          case NonePermission { true } 
                          default { 
                              DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>    check receiver permission " + targetType.permission.toString());
                              match (targetType.permission) {
                                  case SharedPermission { checkFn( targetType.permission.groupExpr ) } 
                                  case LocalPermission {
                                      match (targetType.permission.thePerm) {
                                          case SharedPermission { checkFn( targetType.permission.thePerm.groupExpr ) } 
                                          case UniquePermission { true } 
                                          default { false }
                                      }
                                  }
                                  case UniquePermission { true }
                                  case UnsplitablePermission {
                                      match ( targetType.permission.thePerm ) {
                                          case SharedPermission { checkFn( targetType.permission.thePerm.groupExpr ) } 
                                          case LocalPermission {
                                              match (targetType.permission.thePerm.thePerm) {
                                                  case SharedPermission { checkFn( targetType.permission.thePerm.thePerm.groupExpr ) } 
                                                  case UniquePermission { true } 
                                                  default { false }
                                              }
                                          }
                                          case UniquePermission { true }
                                          default{ false } 
                                      }
                                  }
                                  default { false }
                              };
                          }
                      };
                  }{
                      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>   access a contant field");
                      // call checkFn to compute target data group depInfo/symbol 
                      match (targetType.permission) {
                         case SharedPermission {
                              if ( AEMINIUM_MODE() ) {
                                   match ( targetType.permission.groupExpr ) {
                                       case AbstractEmptyExpression { DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> skip global data group dependency") }
                                       default {
                                            datagroupSymbol = getSymbolForAbstractExpression(targetType.permission.groupExpr);
                                            match ( datagroupSymbol ) {
                                                case Symbol {
                                                    val depInfoOpt = depInfoForSymbol(datagroupSymbol);
                                                    match ( depInfoOpt ) {
                                                        case Some { datagroupDepInfo = depInfoOpt.value }
                                                        default { ABORT("<typecheckExpression> Cannnot find dependency information for " + expr.toString()) }
                                                    };
                                                }
                                                default { ABORT("Cannot find symbol for abstract expression.") }
                                            }
                                       }
                                   };
                              };                         
                         } 
                         default { unit }   
                      };
                      true
                  };                  
                  
                  match ( AEMINIUM_MODE() && (allowAccess == false) ) {
                    case True {
                      report_ERROR(exp.token, "A_ASSIGN_SHARED_OBJECT_FIELD", "Access to field no permitted.",  "TypecheckDereference");
                      unit
                    }
                    case False {
                      match (fieldSigOption) {
                        case Some {
                          val immutable Signature fieldSig = if ( true )  {
                            val substMap = getSubstitutionMap(targetType.structure);
                            substituteSignature(fieldSigOption.value, substMap);
                          };
                          match (fieldSig) {
                            case FieldSignature {
                              val immutable Option<immutable FieldSignature> newFieldSigOption = fieldSig.splitPermFromField(neededPerm, targetType.permission);
                              match (newFieldSigOption) {
                                case Some {
                                  val immutable FieldSignature newFieldSig = newFieldSigOption.value;
                                  val immutable LinkedList<immutable FieldSourceLocation> sourceLocList = makeLinkedList(); 
                                  val immutable Boolean updateOk = match (newFieldSig == fieldSig) {
                                    case True { true; /* no op - no updates made, no returns needed */ }
                                    case False { 
                                      val immutable ?Structure updatedTargetStruct = targetType.structure.unpackField(newFieldSig, exp.token);
                                      match (updatedTargetStruct) {
                                        case Structure {									  
                                          ctx.update(targetSymbol, makeType(targetType.permission, updatedTargetStruct));
                                          //note will not typecheck - need to check that newFieldSig is an unpackedFieldSig
                                          //must be because if it is different than the old fieldSig, it must be unpacked
                                          sourceLocList.addFirst(makeFieldSourceLoc(targetSymbol, newFieldSig));                                                                
                                          true;
                                        }
                                        default { false } // errors throw in Structure.unpackField
                                      }
                                    }
                                  };
                                  
                                  var immutable Boolean dependencyOk = true;
                                  if (AEMINIUM_MODE()) {                              
                                      val shared DependencyInformation drefInfo = makeASTInformation(exp);
                                      val shared ?DependencyInformation targetInfo = match (depInfoForSymbol(targetSymbol)) {
                                          case Some { 
                                            depInfoForSymbol(targetSymbol).value 
                                          }
                                            
                                          case None { 
                                            dependencyOk = false;
                                            report_ERROR(exp.left.token, "A_DEPENDENCY_MISSING" , "for " + targetSymbol.name, "TypecheckDereference");
                                            unit;
                                          }
                                      };
                                      
                                      val shared DependencyInformation splitInfo = makeSplitInformation(targetSymbol, targetType.permission, targetType.permission);
                                      val shared DependencyInformation joinInfo = makeJoinInformation(targetSymbol, targetType.permission, targetType.permission);
                                      
                                      match (targetInfo) { case DependencyInformation { addDependency(splitInfo, targetInfo); } default { /* no op */ } };
                                      match (datagroupDepInfo) { case DependencyInformation { 
                                          addDependency(drefInfo, datagroupDepInfo); 
                                          setDepInfoForSymbol(datagroupSymbol, drefInfo);
                                      } default { /* no op */ } };
                                      addDependency(drefInfo, splitInfo);
                                      addDependency(joinInfo, drefInfo);
                                      addDependency(joinInfo, splitInfo);
                                      addDepInfoForAST(exp, drefInfo);
                                      setDepInfoForSymbol(targetSymbol, joinInfo);
                                      
                                      if ( sourceLocList.size() > 0 ) {
                                          match (targetType.permission) {
                                              case LocalPermission { }
                                              default { addDepInfoForSLoc(sourceLocList.get(0).value, drefInfo); }
                                          }
                                      };
                                  };
                                  
                                  match (updateOk && dependencyOk) {
                                    case True { makeTypecheckResult(makeType(neededPerm, fieldSig.getCurrentType().structure), ctx, sourceLocList); }
                                    case False { unit }
                                  };
                                } 
                                case None {
                                  report_ERROR(exp.token, "P_SPLIT_FAIL", fieldSig.getCurrentType().permission.toString() + " => " + neededPerm.toString() + " x ???", "typecheckDereference");
                                  unit
                                }
                              }
                            }
                            case DatagroupSignature {
                                makeTypecheckResult(DATAGROUPTYPE, ctx, makeLinkedList() )
                            }
                            case MethodSignature {
                              report_ERROR(exp.token, "T_DEREF_METHOD", targetType.structure.toString() + "." + exp.right.name, "typecheckDereference");
                              unit;
                            }
                          }
                        }
                        case None { 
                          report_ERROR(exp.token, "T_DEREF_MISSING", targetType.structure.toString() + "." + exp.right.name, "typecheckDereference");
                              unit; 
                        }
                      }
                    } /* error above */
                  }
                }
                case False { 
                    report_ERROR(exp.left.token, "T_NOT_IN_SCOPE", exp.left.name, "typecheckDereference");
                    unit;
                }
              }
            }
            case None { 
                report_ERROR(exp.left.token, "SYM_NOT_FOUND", "", "typecheckDereference");
                unit;
            }
          }     
        }
        default { 
            report_ERROR(exp.token, "CHAIN_DEREF", "", "typecheckBlockExpr");
            unit;
        }
      }
    }
    case ParsedDoubleLiteral {  
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedDoubleLiteral");
      match (IMMUTABLE.splitPerm(neededPerm)) {
        case Permission {
          val immutable Option<immutable Structure> doubleStructOption = structureForAST(exp);
          match (doubleStructOption) {
            case Some {
              match  ( AEMINIUM_MODE() ) {
                  case True {
                      DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(ParsedDoubleLiteral) " + exp.value);
                      val unique DependencyInformation depInfo = makeASTInformation(exp);
                      addDepInfoForAST(exp, depInfo);
                  }
                  case False {}
              };
              makeTypecheckResult(makeType(neededPerm, doubleStructOption.value), ctx, makeLinkedList());
            }
            case None {
              report_ERROR(exp.token, "STRUCT_NOT_FOUND", "", "typecheckDoubleLiteral");
              unit;
            }
          }
        }
        default { 
          report_ERROR(exp.token, "T_DOUBLE_PERM", "immutable => " + neededPerm.toString() + " x ???", "typecheckDoubleLiteral");
          unit;
        }
      }
    }
    case ParsedEmptyExpr { 
        report_ERROR(exp.token, "T_WRONG_AST", "Empty Expression", "typecheckEmptyExpr");
        unit; 
    }
    case ParsedIdentifier {
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedIdentifier '" + exp.name + "' " + exp.token.toString());
      val unique Option<immutable Symbol> idSymbolOption = symbolForAST(exp);
      match (idSymbolOption) {
        case Some {
          match (idSymbolOption.value) {
          	case VariableSymbol {
			  match (ctx.containsSymbol(idSymbolOption.value)) {
				case True {
				  val immutable Symbol idSymbol = idSymbolOption.value;
				  val immutable Type currentType = ctx.get(idSymbol);
				  val immutable ?Permission newPermission = currentType.permission.splitPerm(neededPerm);
				  match (newPermission) {
					case Permission {
					  ctx.update(idSymbol, makeType(newPermission,currentType.structure));
					  val slList = makeLinkedList();
					  val sloc = makeVarSourceLoc(idSymbol);
					  slList.addFirst(sloc);
					  
					  if ( AEMINIUM_MODE() ) {
						  // create split node
						  DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(Identifier) split permission of '" + exp.name + "' from " + currentType.permission + "=>" + neededPerm);
						  val shared DependencyInformation splitInfo = makeSplitInformation(idSymbol, currentType.permission, neededPerm);
						  splitInfo.inAtomic = ctx.isInAtomic();
						  val shared DependencyInformation oldDepInfo = depInfoForSymbol(idSymbol).value;
						  addDependency(splitInfo, oldDepInfo);
						  setDepInfoForSymbol(idSymbol, splitInfo);
						  
						  // create ASTNode 
						  DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(Identifier) create ASTInformation node for '" + exp.name + "'");
						  val unique DependencyInformation expInfo = makeASTInformation(exp);
						  addDependency(expInfo, splitInfo);
						  addDepInfoForAST(exp, expInfo);
						  
						  // add sloc mapping
						  addDepInfoForSLoc(sloc, splitInfo);
					  };
					  
					  makeTypecheckResult(makeType(neededPerm,currentType.structure), ctx, slList)
					}
					default { 
						report_ERROR(exp.token, "P_SPLIT_FAIL", currentType.permission.toString() + " => " + neededPerm.toString() + " x ???", "typecheckIdentifier"); 
						unit;
					}
				  }     
				}
				case False { 
					report_ERROR(exp.token, "T_NOT_IN_SCOPE", exp.name, "typecheckIdentifier"); 
					unit;
				}
			  }
			}
			case FieldSymbol {
				val fieldType = idSymbolOption.value.getSignature().getDeclaredType();
				val fieldPerm = fieldType.permission;
				val immutable ?Permission newPermission = fieldPerm.splitPerm(neededPerm);
				match (newPermission) {
					case Permission {
						match (newPermission == fieldPerm) {
							case True {
								makeTypecheckResult(makeType(neededPerm,fieldType.structure), ctx, makeLinkedList())
							}
							case False {
								report_ERROR(exp.token, "T_TOP_FIELD_PERM", fieldPerm.toString() + " => " + neededPerm.toString() + " x " +
												newPermission.toString(), "typecheckIdentifier"); 
								unit;
							}
						}
					}
					default {
						report_ERROR(exp.token, "P_SPLIT_FAIL", fieldPerm.toString() + " => " + neededPerm.toString() + " x ???", "typecheckIdentifier"); 
						unit;
					}
				}
				
			}
			default {
				ABORT("unexpected symbol type " + idSymbolOpt.symbolType() + " for identifier " + exp.name);
			}
		  }
        }
        case None {
            report_ERROR(exp.token, "SYM_NOT_FOUND", "", "typecheckIdentifier"); 
            unit;
        }
      }
    }
    case ParsedIntLiteral {  
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedIntLiteral");
      match (IMMUTABLE.splitPerm(neededPerm)) {
        case Permission {
          val immutable Option<immutable Structure> intStructOption = structureForAST(exp);
          match (intStructOption) {
            case Some {            
              match  ( AEMINIUM_MODE() ) {
                  case True {
                      DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(ParsedIntLiteral) " + exp.value);
                      val unique DependencyInformation depInfo = makeASTInformation(exp);
                      addDepInfoForAST(exp, depInfo);
                  }
                  case False {}
              };
                  
              makeTypecheckResult(makeType(neededPerm, intStructOption.value), ctx, makeLinkedList());
            }
            case None {
              report_ERROR(exp.token, "STRUCT_NOT_FOUND", "", "typecheckIntLiteral");
              unit;
            }
          }
        }
        default { 
          report_ERROR(exp.token, "T_INT_PERM", "immutable => " + neededPerm.toString() + " x ???", "typecheckIntLiteral");
          unit;
        }
      }
    }
    //case ParsedLambda { }
    case ParsedMatch { 
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedMatch");
      match (exp.expression) {
        case ParsedIdentifier {
          val unique Option<immutable Symbol> targetSymOption = symbolForAST(exp.expression);
          match (targetSymOption) {
            case Some {
              val immutable Symbol targetSym = targetSymOption.value;
              match (ctx.containsSymbol(targetSym)) {
                case True {
                  val shared DependencyInformation enterInfo = makeMatchEnterInformation(exp);
                  val shared DependencyInformation leaveInfo = makeMatchLeaveInformation(enterInfo);
                  val unique SymbolCollector symbols = new SymbolCollector;
                  val unique Map symbolsToSplit = java.util.IdentityHashMap.new();
                  val unique Map oldAbsExprDepInfo = java.util.IdentityHashMap.new();
                  val unique Map usedAbsExprs = java.util.HashSet.new();
                  
                  if ( AEMINIUM_MODE() ) {
                       val absExpIt = ctx.gpMap.keySet().iterator();
                       while { absExpIt.hasNext() }{
                           val absExp = absExpIt.next();
                           val absExpSym = getSymbolForAbstractExpression(absExp);
                           match ( absExpSym ) {
                               case Symbol {
                                   val depInfoOpt = depInfoForSymbol(absExpSym);
                                   match ( depInfoOpt ) {
                                       case Some { 
                                            oldAbsExprDepInfo.put(absExpSym, depInfoOpt.value);
                                       }
                                       default { ABORT("<typecheckExpression> Cannot find dependency information for " + absExp.toString()) } 
                                   }
                               }
                               default { ABORT("Cannot find symbol for abstract expression.") }
                            };
                       };
                  
                  
                       exp.accept(symbols);                       
                       val it = symbols.externalSymbols.iterator();
                       while { it.hasNext() }{
                           val next = it.next();
                           // attach match_enter info for all used symbols
                           val shared DependencyInformation symInfo = match (depInfoForSymbol(next)) {
                                case Some { depInfoForSymbol(next).value }
                                case None { ABORT("<typecheckExpression>(Match) cannot find dependency information for " + next.name ) }
                           };
                           val immutable Type nextType = ctx.get(next);
                           val shared DependencyInformation splitInfo = makeSplitInformation(next, nextType.permission, nextType.permission);
                           symbolsToSplit.put(next, splitInfo);
                           addDependency(splitInfo, symInfo);
                           addDependency(enterInfo, splitInfo);
                       }; 
                       
                       addDepInfoForAST(exp, leaveInfo);
                  };
                
                  val immutable Type targetType = ctx.get(targetSym);
                  val unique LinkedList<unique TypecheckResult> caseResults = exp.caseList.map(fn (/*immutable ParsedCase*/ theCase) => 
                  {  /***** for each case *****/
                    if ( AEMINIUM_MODE() ) {                                           
                         val itSymbols = symbols.externalSymbols.iterator();
                         while { itSymbols.hasNext() }{
                             val nextSym = itSymbols.next();
                             // attach match_enter info for all used symbols
                             val shared DependencyInformation symInfo = match (depInfoForSymbol(nextSym)) {
                                  case Some { depInfoForSymbol(nextSym).value }
                                  case None { ABORT("<typecheckExpression>(Match) cannot find dependency information for " + next.name ) }
                             };
                             setDepInfoForSymbol(nextSym, enterInfo);
                         };
                         
                         val absExpIt = oldAbsExprDepInfo.keySet().iterator();
                         while { absExpIt.hasNext() }{
                             val nextSym = absExpIt.next();
                             // attach match_enter info for all used symbols
                             val shared DependencyInformation symInfo = match (depInfoForSymbol(nextSym)) {
                                  case Some { depInfoForSymbol(nextSym).value }
                                  case None { ABORT("<typecheckExpression>(Match) cannot find dependency information for " + next.name ) }
                             };
                             setDepInfoForSymbol(nextSym, enterInfo);
                         }; 
                    };
                    match (theCase) {
                      case ParsedPatternCase {
                        /* check that the structure of the case is a substructure of the target type*/
                        val immutable Option<immutable Symbol> patternSymOption = symbolForAST(theCase.pattern);
                        match (patternSymOption) {
                          case Some {
                            val immutable Symbol patternSym = patternSymOption.value;
                            match (patternSym) {
                              case StateSymbol {
                                val patternStruct = match ( theCase.staticArgs.size() == 0 ) {
                                    case True { patternSym.getStructure() }
                                    default {
                                        val struct = patternSym.getStructure();
                                        val staticArgs = theCase.staticArgs.map( fn (arg) => makeAbstractExpressionFromAST(arg) );
                                        substituteStaticArgs(struct, staticArgs); 
                                    }
                                };
                                match (patternStruct.isSubStructureOf(targetType.structure)) {
                                  case True {
                                    /* copy and update linear context with info from case */
                                    val unique LinearContext caseContext = ctx.copy();
                                    caseContext.update(targetSym, makeType(targetType.permission, patternStruct));
                                    
                                    /* return result from typechecking the body */
                                    val unique ?TypecheckResult result = typecheckExpression(caseContext, neededPerm, theCase.body);
                                    DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> result type of case " + patternSym.name + " : " + result.expType.toString());
                                    
                                    if (AEMINIUM_MODE() ) {
                                        val shared DepenendencyInformation caseInfo = makeASTInformation(theCase);
                                        val shared DepenendencyInformation bodyInfo = match (depInfoForAST(theCase.body)) {
                                            case Some { depInfoForAST(theCase.body).value }
                                            case None { ABORT("<typecheckExpression>(Case) cannot find dependency information for case body") }
                                        };
                                        
                                        addDepInfoForAST(theCase, caseInfo);
                                        addDependency(caseInfo, bodyInfo);
                                        addDependency(leaveInfo, caseInfo);
                                        addDependency(bodyInfo, enterInfo);
                                        
                                        // compute used datagroups
                                        val usedIt = oldAbsExprDepInfo.keySet().iterator();
                                        while { usedIt.hasNext() }{
                                            val curSym = usedIt.next();
                                            val depInfo = match ( depInfoForSymbol(curSym) ) {
                                                case Some { depInfoForSymbol(curSym).value }
                                                default   { ABORT("Cannot find dep info for symbol " + curSym.toString()) }
                                            };
                                            
                                            match ( depInfo == enterInfo ) {
                                                case False {
                                                    DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>    case used data group " + curSym.toString());
                                                    usedAbsExprs.add(curSym)
                                                }
                                                default { /* nop */ }
                                            };
                                        }; 
                                    };
                                    
                                    result 
                                  }
                                  case False {
                                    report_ERROR(theCase.pattern.token, "T_CASE_NOT_SUBSTRUCT", 
                                        "found " + makeStringFromQualifiedIdentifier(theCase.pattern) + ", needed " + targetType.structure.toString(),
                                        "typecheckCase");
                                    unit;
                                  }
                                }
                              }
                              case JavaClassSymbol {
                              	val patternStruct = patternSym.getStructure();
                                match (patternStruct.isSubStructureOf(targetType.structure)) {
                                  case True {
                                    /* copy and update linear context with info from case */
                                    val unique LinearContext caseContext = ctx.copy();
                                    caseContext.update(targetSym, makeType(targetType.permission, patternStruct));
                                    
                                    /* return result from typechecking the body */
                                    val unique ?TypecheckResult result = typecheckExpression(caseContext, neededPerm, theCase.body);
                                    
                                    if (AEMINIUM_MODE() ) {
                                        val shared DepenendencyInformation caseInfo = makeASTInformation(theCase);
                                        val shared DepenendencyInformation bodyInfo = match (depInfoForAST(theCase.body)) {
                                            case Some { depInfoForAST(theCase.body).value }
                                            case None { ABORT("<typecheckExpression>(Case) cannot find dependency information for case body") }
                                        };
                                        
                                        addDepInfoForAST(theCase, caseInfo);
                                        addDependency(caseInfo, bodyInfo);
                                        addDependency(leaveInfo, caseInfo);
                                        addDependency(bodyInfo, enterInfo);
                                    };
                                    
                                    result 
                                  }
                                  case False {
                                    report_ERROR(theCase.pattern.token, "T_CASE_NOT_SUBSTRUCT", 
                                        "found " + makeStringFromQualifiedIdentifier(theCase.pattern) + ", needed " + targetType.structure.toString(),
                                        "typecheckCase");
                                    unit;
                                  }
                                }
                              }
                              default { 
                                report_ERROR(theCase.pattern.token, "T_CASE_NOT_STATE", 
                                        "found " + patternSym.symbolType(),
                                        "typecheckCase");
                                unit;
                              }
                            }
                          }
                          case None { 
                            report_ERROR(theCase.pattern.token, "SYM_NOT_FOUND", 
                                        "",
                                        "typecheckCase");
                            unit;
                          }
                        } 
                      }
                      case ParsedDefaultCase {
                        /* copy linear context */
                        val unique LinearContext defaultContext = ctx.copy();
                        
                        /* return result from typechecking the body */
                        val unique ?TypecheckResult result = typecheckExpression(defaultContext, neededPerm, theCase.body);
                        
                        if (AEMINIUM_MODE() ) {
                            val shared DepenendencyInformation caseInfo = makeASTInformation(theCase);
                            val shared DepenendencyInformation bodyInfo = match (depInfoForAST(theCase.body)) {
                                case Some { depInfoForAST(theCase.body).value }
                                case None { ABORT("<typecheckExpression>(Case) cannot find dependency information for case body") }
                            };
                            
                            addDepInfoForAST(theCase, caseInfo);
                            addDependency(caseInfo, bodyInfo);
                            addDependency(leaveInfo, caseInfo);
                            addDependency(bodyInfo, enterInfo);
                            
                            // compute used datagroups
                            val usedIt = oldAbsExprDepInfo.keySet().iterator();
                            while { usedIt.hasNext() }{
                                val curSym = usedIt.next();
                                val depInfo = match ( depInfoForSymbol(curSym) ) {
                                    case Some { depInfoForSymbol(curSym).value }
                                    default   { ABORT("Cannot find dep info for symbol " + curSym.toString()) }
                                };
                                
                                match ( depInfo == enterInfo ) {
                                    case False {
                                        DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>    case used data group " + curSym.toString());
                                        usedAbsExprs.add(curSym)
                                    }
                                    default { /* nop */ }
                                };
                            }; 
                        };
                        
                        result
                      }
                    }
                  }); /****** end for each case *****/
                  
                  match (caseResults.size() > 0) {
                    case True {
                      /* take lub of return types, merge of the contexts, and accumulation of the location lists */
                      
                      /* first element is the seed (has at least one) */
                      val unique ?TypecheckResult seedCaseResult = caseResults.get(0).value;
                      //DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> seed result " + seedCaseResult.expType.toString());
                      var immutable Boolean skippedFirst = false;
                      /* collect all but first element of the list */
                      val restCaseRes = caseResults.collect(fn (caseRes) => {
                        ifElse (!skippedFirst) 
                          { skippedFirst = true; false }
                          { true } 
                      });

                      if ( AEMINIUM_MODE() ) {
                         val itSymbols = symbols.externalSymbols.iterator();
                         while { itSymbols.hasNext() }{
                             val nextSym = itSymbols.next();
                             // attach match_enter info for all used symbols
                             val shared DependencyInformation symInfo = match (depInfoForSymbol(nextSym)) {
                                  case Some { depInfoForSymbol(nextSym).value }
                                  case None { ABORT("<typecheckExpression>(Match) cannot find dependency information for " + next.name ) }
                             };
                             
                             
                             val shared DependencyInformation splitInfo = symbolsToSplit.get(nextSym);
                             val shared DependencyInformation joinInfo = makeJoinInformation(nextSym, splitInfo.permIn, splitInfo.permOut);
                             addDependency(joinInfo, splitInfo);
                             addDependency(joinInfo, leaveInfo);
                             setDepInfoForSymbol(nextSym, joinInfo);
                         };   
                         
                         // connect match enter to used data group symbols and reset others
                         val fixupIt = oldAbsExprDepInfo.keySet().iterator();
                         while { fixupIt.hasNext() }{
                            val curSym = fixupIt.next();
                            val curDepInfo = match ( depInfoForSymbol(curSym) ) {
                                case Some { depInfoForSymbol(curSym).value }
                                default { ABORT("Cannot find dep info for symbol " + curSym.name) }
                            };
                            val originalDepInfo = oldAbsExprDepInfo.get(curSym);
                            match ( usedAbsExprs.contains(curSym) ) {
                                case True {
                                    // connect enter to orignal info and set leave to new value 
                                    DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>     fixup dependencies for " + curSym.name);
                                    addDependency(enterInfo, originalDepInfo);
                                    setDepInfoForSymbol(curSym, leaveInfo);
                                }
                                case False {
                                    // restore original            
                                    DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>     reset dependencies for " + curSym.name);
                                    setDepInfoForSymbol(curSym, originalDepInfo);
                                }
                            }
                         };                                  
                      };
                      
                      /* reduce rest of list starting with first element as seed */
                      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> reduce case results");
                      restCaseRes.reduce(seedCaseResult, fn (accResult, caseRes) => {
                      	match (accResult) {
                      	  case TypecheckResult {
                            DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> case result " + caseRes.expType.toString());
							val immutable Option<immutable Type> returnTypeLUBopt = 
											accResult.expType.leastUpperBound(caseRes.expType);
							match ( returnTypeLUBopt ) {
							  case Some {
							    DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>  returnTypeLUB " + returnTypeLUBopt.value.toString());
								val unique Option<unique LinearContext> mergedContextOpt = 
											accResult.ctxResult.merge(caseRes.ctxResult);
								match ( mergedContextOpt ) {
								  case Some {
									val combinedSLL = combineSLL(mergedContextOpt.value, neededPerm,
									                             accResult.ctxResult, accResult.sourceLocList,
									                             caseRes.ctxResult, caseRes.sourceLocList);
									match (combinedSLL) {
									    case LinkedList { 
									        makeTypecheckResult(returnTypeLUBopt.value, 
														mergedContextOpt.value, 
													    combinedSLL);
										}
										default {
										    report_ERROR(exp.token, "T_CONTEXT_MERGE_FAIL", 
                                                " from SLL combining",
                                                "typecheckMatch");
                                            unit;
										}
									};
									
								  }
								  case None {
									report_ERROR(exp.token, "T_CONTEXT_MERGE_FAIL", 
                                        " from match cases",
                                        "typecheckMatch");
                                    unit;
								  }
								}
							  }
							  case None { 
								report_ERROR(exp.token, "T_NO_RESULT_LUB", 
                                        " from match cases",
                                        "typecheckMatch");
                                    unit;
							  }
							}
						  }
						  default { unit }
						}
                      });
                    }
                    case False { 
                        report_ERROR(exp.token, "T_MATCH_NO_CASES", 
                                        "",
                                        "typecheckMatch");
                        unit;
                    }
                  }
                }
                case False { 
                    report_ERROR(exp.expression.token, "T_NOT_IN_SCOPE", 
                                exp.expression.name,       
                                "typecheckMatch");
                    unit;
                }
              }
            }
            case None { 
                report_ERROR(exp.expression.token, "SYM_NOT_FOUND", 
                                "",       
                                "typecheckMatch");
                unit; 
            }
          }
        }
        default { 
            report_ERROR(exp.expression.token, "MATCH_NON_ID", 
                                "",       
                                "typecheckMatch");
            unit; 
        }
      }
    }
    case ParsedMethodCall { 
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedMethodCall");
      /* receiver AST should be mapped to a type which gives us the signature of the method */
      val immutable Option<immutable Structure> receiverStructureOption = structureForAST(exp.receiver);
      var immutable ?MethodSignature methodSig = match(receiverStructureOption) {
        case Some {
          val immutable Structure receiverStructure = receiverStructureOption.value;
          match (receiverStructure) {
            case ObjectStructure {
              val immutable Option<immutable Signature> memberSigOption = 
                                    receiverStructure.getMember(exp.methodId.name);
              match (memberSigOption) {
                case Some {
                  val memberSig = memberSigOption.value;
                  match (memberSig) {
                    case MethodSignature {
                      memberSig
                    }
                    default {
                      report_ERROR(exp.methodId.token, "T_CALL_NOT_METHOD", receiverStructure.toString() + "." +
                        exp.methodId.name, "typecheckMethodCall");
                      unit
                    }
                  }
                }
                case None { 
                  report_ERROR(exp.methodId.token, "T_CALL_MISSING", receiverStructure.toString() + "." +
                        exp.methodId.name, "typecheckMethodCall");
                  unit
                }
              }
            }
            default { 
                report_ERROR(exp.receiver.token, "T_CALL_NON_OBJECT_STRUCTURE", receiverStructure.toString(),
                            "typecheckMethodCall");
                unit 
            }
          }
        }
        case None {
          match (exp.receiver) {
          	case ParsedEmptyExpr { //global method, get receiver from method symbol
          		val shared Symbol mSymOpt = symbolForAST(exp.methodId);
          		match (mSymOpt) {
          			case Some {
          				match (mSymOpt.value) {
          					case MethodSymbol {
          						mSymOpt.value.getSignature();
          					}
          					default {
								report_ERROR(exp.receiver.token, "STRUCT_NOT_FOUND", 
								" for method call receiver",       
								"typecheckMethodCall");
								unit
							}
          				}
          			}
          			case None{
          				report_ERROR(exp.receiver.token, "STRUCT_NOT_FOUND", 
						" for method call receiver",       
						"typecheckMethodCall");
						unit
          			}
          		}
          	
          	}
          	default {
          		report_ERROR(exp.receiver.token, "STRUCT_NOT_FOUND", 
                " for method call receiver",       
                "typecheckMethodCall");
          		unit
          	}
          }
        }
      };
      
      match (methodSig) {
        case MethodSignature {
          val substMap = getMethodCallMapping(methodSig, exp);
          methodSig = substituteSignature(methodSig, substMap);
          // check static args type
          exp.staticArgs.do( fn (staticArg) => {
              val absExpr = makeAbstractExpressionFromAST(staticArg);
              match ( absExpr ) {
                  case AbstractExpression {
                       match ( absExpr.getStructure() == DATAGROUPSTRUCT ) {
                           case True { /* nop */ }
                           default { ABORT("Static argument has wrong type " + absExpr.getStructure().toString()) }
                       };
                  }
                  default { 
                    report_ERROR(arg.token, "", "Cannot find type for static argument", "typecheckNewInstance");
                  }
              };        
          });
          // check for correct group permissions
          match ( methodSig.staticArgsSpec.size()  == exp.staticArgs.size() ) {
              case True {                  
                  val zips = methodSig.staticArgsSpec.zip(exp.staticArgs);
                  zips.do(fn (arg)  => {
                       val staticArgSpec = arg.fst;
                       val staticArg     = arg.snd;
                       val absExpr = makeAbstractExpressionFromAST(staticArg);
                       match ( absExpr ) {
                           case AbstractExpression {
                               val gp = ctx.getDatagroupPermission(absExpr);
                               match ( gp ) {
                                   case GroupPermission { 
                                       DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression> Found static argument permission '" + gp.toString() + "' in context.");
                                       if ( (gp == staticArgSpec.gpermission) == false ){
                                           ABORT("<typecheckExpression>(MethodCall) Need '" + staticArgSpec.gpermission + "' group permission for '" + absExpr.toString() + "' but found '" + gp.toString() + "'");
                                       }
                                   }
                                   default { ABORT("<typecheckExpression>(MethodCall) Cannot find '" + absExpr.toString() + "' in context."); }
                               };
                            }
                            default { ABORT("Cannot translate AST to AbstractExpression.") }
                       }
                  });
              }
              default { report_ERROR(exp.token, "", "Provided static arguments do not match declared paramater count.", "typecheckMethodCall");} 
          };
          /* check that the neededPerm can be split from the return permission of the method */
          match (methodSig.returnType.permission.splitPerm(neededPerm)) {
            case Permission {
              /* use method signature to find the permissions needed for the receiver and the arguments */
          
          	  val immutable Boolean noReceiver = methodSig.receiverSpec == makeArgSpec(VOID,VOID);
          	  
          
              //build list of (argSpec, expression) with receiver followed by arguments
              val unique LinkedList<immutable ArgSpec> argSpecs = makeLinkedList();
              match (noReceiver) { case True { /* no op */ } case False { argSpecs.add(methodSig.receiverSpec); } };
              argSpecs.append(methodSig.arguments.map(fn (arg) => arg.snd));
              
              val unique LinkedList<immutable ParsedASTNode> inputExprs = makeLinkedList();
              match (noReceiver) { case True { /* no op */ } case False { inputExprs.add(exp.receiver); } };
              
              match (exp.argument) {
                case ParsedArgumentExpr { inputExprs.append(exp.argument.args.map(fn (arg) => arg)) }
                default { inputExprs.addLast(exp.argument) }
              };
              
              match ( argSpecs.size() == inputExprs.size() ) {
                case True {
                  val /*immutable LinkedList<immutable Pair<immutable ParsedASTNode, immutable ArgSpec>>*/
                      inputArgSpecList = inputExprs.zip(argSpecs); 
                  
                  var unique ?LinearContext currentContext = ctx;
                  var immutable Integer inputCount = 0;
                  
                  //go through list in order typechecking each expression with the input permission
                  val unique LinkedList<unique TypecheckResult> returnLocations = 
                    inputArgSpecList.map(fn (ias) => {
                      match (currentContext) {
                        case LinearContext {
                          val immutable ParsedASTNode inputAST = ias.fst;
                          val immutable ArgSpec inputSpec = ias.snd;
                          
                          val unique ?TypecheckResult inputResult = 
                            typecheckExpression(currentContext, inputSpec.inputType.permission, inputAST);
                          //once we have exceptions, catch errors here
                          
                          match (inputResult) {
                            case TypecheckResult {
                          
                              //check returned structure
                              match (inputResult.expType.structure.isSubStructureOf(inputSpec.inputType.structure)) {
                                case True {
                                    inputCount = inputCount + 1;
                                    currentContext = inputResult.ctxResult;
                                    inputResult.sourceLocList;
                                }
                                case False {
                                    val immutable String inputName = match (noReceiver) {
                                    	case True { "argument " + (inputCount + 1) } 
                                    	case False {
                                    		match (inputCount == 0) {
                                        		case True { "receiver" }
		                                        case False { "argument " + inputCount }
		                                    }
		                                }
                                    };
                                    report_ERROR(inputAST.token, "T_CALL_WRONG_ARG_STRUCT",
                                        "for " + inputName + " expected " + inputSpec.inputType.structure.toString() + ", got " + inputResult.expType.structure.toString(),
                                        "typecheckMethodCall");
                                    currentContext = unit;
                                    makeLinkedList();
                                }
                              };
                            }
                            default { makeLinkedList(); } //error typechecking argument
                          }
                          
                        }
                        default { makeLinkedList(); } //previous argument error
                      }
                  });
                    
                  match (currentContext)  {
                    case LinearContext { //no errors in arguments
                      // connect to parameters/receiver
                      if ( AEMINIUM_MODE() ) {
                           // AEminium dependency information
                           val unique DependencyInformation mcallInfo = makeASTInformation(exp);
                           addDepInfoForAST(exp, mcallInfo);
                      
                           // add dependency to parameters
                           match ( exp.receiver ) {
                               case ParsedEmptyExpr { /* nop */ }
                               default {
                                   DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(MethodCall) let method call dependend on its receiver ");
                                   val receiverInfo = match (depInfoForAST(exp.receiver)) {
                                       case Some { depInfoForAST(exp.receiver).value}
                                       case None { ABORT("<typecheckExpression>(MethodCall) cannot find dependency information receiver ") }
                                   };
                                   addDependency(mcallInfo, receiverInfo);
                                }
                            };
                
                           DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(MethodCall) let method call dependend on its parameters ");
                           match (exp.argument) {
                               case ParsedArgumentExpr {
                                   exp.argument.args.do(fn (arg) => {
                                       val argInfo = match (depInfoForAST(arg)) {
                                           case Some { depInfoForAST(arg).value}
                                           case None { ABORT("<typecheckExpression>(MethodCall) cannot find dependency information receiver ") }
                                       };    
                                       addDependency(mcallInfo, argInfo);
                                   });
                               }
                               default {
                                   ABORT("<typecheckExpression>(MethodCall) cannot handle non ArgExpressions yet ");
                               }
                           };
                           
                           DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(MethodCall) let method call dependend on its static parameters ");
                           exp.staticArgs.do( fn (staticArg) => {
                               val absExpr = makeAbstractExpressionFromAST(staticArg);
                               match ( absExpr ) {
                                   case AbstractEmptyExpression { /* nop */ }
                                   case AbstractExpression {
                                        val symbol = getSymbolForAbstractExpression(absExpr);
                                        val depInfoOpt = depInfoForSymbol(symbol);
                                        match ( depInfoOpt ) {
                                            case Some {
                                                DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression>(MethodCall)     connect method call to static arg " + absExpr.toString());
                                                addDependency(mcallInfo, depInfoOpt.value);
                                                setDepInfoForSymbol(symbol, mcallInfo);
                                            }
                                            default { ABORT("<typecheckExpression>(MethodCall) Cannot find dependency information for abstract expression " + absExpr.toString()) }
                                        };
                                   }
                                   default { ABORT("<typecheckExpression>(MethodCall) Cannot convert AST to abstract expression.") }
                               };
                           });
                      };
                      
                      if ( AEMINIUM_MODE() == false ) {
                          //downgrade context
                          //currentContext.downgrade();
                      };
                      
                      //go through list in reverse order returning the output permission to generated sourceLocationList
                      val /*immutable LinkedList<immutable Pair<immutable LinkedList<immutable SourceLocation>, immutable ArgSpec>>*/
                          returnLocArgSpecList = returnLocations.zip(argSpecs); 
                      
                      inputCount = argSpecs.size() - 1;
                      val unique ?LinearContext outputContext = 
                        returnLocArgSpecList.reduceRight(fn (rlas, reducedContext) => {
                          match (reducedContext) {
                            case LinearContext {                      
                              val immutable LinkedList<immutable SourceLocaiton> returnList = rlas.fst;
                              val immutable ArgSpec inputSpec = rlas.snd;
                              
                              val immutable Boolean returnsOk = returnList.reduceLeft(true, fn (ok, sourceLoc) => { 
                                val immutable Boolean restored = match (sourceLoc.restoreToLoc(inputSpec.outputType, reducedContext)) {
                                    case True {
                                        true
                                    }
                                    case False { //can we do better for this error message, esp on token.
                                        val immutable String inputString = match (noReceiver) {
                                    	case True { "argument " + (inputCount + 1) } 
											case False {
												match (inputCount == 0) {
													case True { "receiver" }
													case False { "argument " + inputCount }
												}
											}
										};
                                        val immutable ?Type badReturnTypeOpt = sourceLoc.locationType(reducedContext);
                                        val immutable String badReturnTypeString = match (badReturnTypeOpt) {
                                            case Type { badReturnTypeOpt.toString(); }
                                            default { "UNKNOWN" }
                                        };
                                        
                                        report_ERROR(exp.token,""," return of type " + inputSpec.outputType.toString() +
                                            " to " + inputString + " location " + sourceLoc.toString() + " of type " + badReturnTypeString + " failed",
                                            "typecheckMethodCall");
                                        false
                                    }
                                };
                                restored && ok;
                              });
                              
                              inputCount = inputCount - 1;
                              
                              reducedContext
                            }
                            default { unit } //previous error
                          }
                        
                        }, currentContext);
                      
                      match (outputContext) {
                        case LinearContext {
                          /* return needed permission with structure of method return 
                           * (already checked return perm could be split)
                           * with outputContext and no return locations  */
                          makeTypecheckResult(makeType(neededPerm, methodSig.returnType.structure), outputContext, makeLinkedList());
                        }
                        default { unit } 
                      }
                    }
                    default { unit } //args didn't check out
                  }
                }
                case False {
                  report_ERROR(exp.token, "T_CALL_ARG_NUM", "expected " + argSpecs.size() + ", got " +
                    inputExprs.size(), "typecheckMethodCall");
                  unit;
                }
              };
              
            }
            default {
              report_ERROR(exp.token, "P_SPLIT_FAIL", methodSig.returnType.permission.toString() + " =>" + neededPerm.toString() +
                    " x ???", "typecheckMethodCall");
              unit
            }
          }; 
        }
        default { unit } //previous error
      }
    
    }
    default { 
        typecheckExpression2(ctx, neededPerm, exp);   
    }
  }
}