package plaid.compiler.typechecker;

import plaid.compiler.*;
import plaid.compiler.types.*;
import plaid.compiler.permissions.*;

import plaid.collections.makeLinkedList;

/**
 * To typecheck an expression, we attempt to give the Expression exp the permission needed Perm
 * given the context ctx.  We also take the pass to use for reporting errors.
 *
 * If there are no errors, we return an updated linear context along with the type
 * of the expression and an expression list
 */
method unique TypecheckResult typecheckExpression(unique LinearContext ctx, 
                          immutable Permission neededPerm, 
                          immutable ParsedExpression exp, 
                          shared TypeCheckPass typecheckPass) 
{

  match (exp) {
    case ParsedApplication {
      ABORT("Lambdas not implemented in typechecker");
    }
    case ParsedAssignment {
      match (neededPerm) {
        case NonePermission {
          match (exp.target) {
            case EmptyExpression { //local-assign
              val unique Option<immutable VariableSymbol> localVarSymbolOption = symbolForAST(exp.field);
              match (localVarSymbolOption) {
                case Some {
                  match (ctx.hasSymbol(localVarSymbolOption.value)) {
                    case True {
                      val immutable Type neededType = localVarSymbolOption.value.getDeclaredType();
                      val unique TypecheckResult valueResult = typecheckExpression(ctx, neededType.permission, exp.value, typecheckPass);
                      match (valueResult.expType.isSubTypeOf(neededType)) {
                        case True { 
                          val unique LinearContext ctxReturn = valueResult.ctxResult.copy();
                          ctxReturn.update(localVarSymbolOption.value, neededType);
                          makeTypecheckResult(VOID, ctxReturn, makeLinkedList()) 
                        }
                        case False { ABORT("<typecheckExpression>(Assignment) value has wrong structure") }
                      }
                    }
                    case False {
                      ABORT("<typecheckExpression>(Assignment) Variable '" + localVarSymbolOption.value.name + "' not found in the context")
                    }
                  }
                }
                case None {
                  match (exp.field) {
                    case ParsedIdentifier { ABORT("<typecheckExpression>(Assignment) No Symbol found for Variable '" + exp.target.name + "'") }
                    default { ABORT("<typecheckExpression>(Assignment) field not an identifier") }
                  }
                }
              }
            }
            case ParsedIdentifier { //field-Assign
              val unique Option<immutable VariableSymbol> targetVarSymbolOption = symbolForAST(exp.target);
              match (targetVarSymbolOption) {
                case Some {
                  match (ctx.hasSymbol(targetVarSymbolOption.value)) {
                    case True {
                      val immutable Type targetType = ctx.get(targetVarSymbolOption.value);
                      match (targetType.permission.isSubPermOf(LOCALSHARED)) {
                        case True {    
                          match(targetType.structure) {
                            case ObjectStructure {
                              val unique Option<immutable Signature> fieldSigOption = targetType.structure.getMember(exp.field.name);
                              match (fieldSigOption) {
                                case Some {
                                  match (fieldSigOption.value) {
                                    case FieldSignature {
                                      val immutable Type neededType = fieldSigOption.value.fieldType;
                                      val unique TypecheckResult valueResult = typecheckExpression(ctx, neededType.permission, exp.value, typecheckPass);
                                      match (valueResult.expType.isSubTypeOf(neededType)) {
                                        case True { 
                                          val immutable ObjectStructure newStructure = targetType.structure.packField(exp.field.name);
                                          val unique LinearContext ctxReturn = valueResult.ctxResult.copy();
                                          ctxReturn.update(localVarSymbolOption.value, makeType(targetType.permission, newStructure));
                                          makeTypecheckResult(VOID, ctxReturn, makeLinkedList()) 
                                        }
                                        case False { ABORT("<typecheckExpression>(Assignment) value has wrong structure") }
                                      }
                                    } 
                                    case MethodSignature {
                                      ABORT("<typecheckExpression>(Assignment) field '" + targetType.structure.name + "." + exp.field.name + "' is a method")
                                    }
                                    default {
                                      ABORT("<typecheckExpression>(Assignment) field '" + targetType.structure.name + "." + exp.field.name + "' has an unrecognized signature type") 
                                    }
                                  }
                                }
                                case None { ABORT("<typecheckExpression>(Assignment) field '" + targetType.structure.name + "." + exp.field.name + "' does not exist") }
                              } 
                            }
                            default { ABORT("<typecheckExpression>(Assignment) Target variable '" + targetVarSymbolOption.value.name + "' has a non-object structure") }
                          }
                        }
                        case False { ABORT("<typecheckExpression>(Assignment) Target variable '" + targetVarSymbolOption.value.name + 
                                           "' cannot be modified with permission '" + targetType.permission.toString() + "'")
                        }
                      }
                    }
                    case False { ABORT("<typecheckExpression>(Assignment) Target variable '" + targetVarSymbolOption.value.name + "' not found in the context") }
                  }
                }
                case None { ABORT("<typecheckExpression>(Assignment) not symbol found for target object '" + exp.target.name + "'") }
              }
            }
            default { ABORT("<typecheckExpression>(Assignment) target object must be an identifier") }
          }  
        }
        default { ABORT("<typecheckExpression>(Assignment) Assignments can only be given none permission; needed '" + neededPerm.toString()) } 
      }
    }
    default { ABORT("<typecheckExpression>(Assignment) Unexpected '" + exp.nodeName() + "' found during Expression typechecking") }
  }
}