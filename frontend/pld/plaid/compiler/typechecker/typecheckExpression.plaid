package plaid.compiler.typechecker;

import plaid.compiler.*;
import plaid.compiler.types.*;
import plaid.compiler.permissions.*;

import plaid.collections.makeLinkedList;

/**
 * To typecheck an expression, we attempt to give the Expression exp the permission needed Perm
 * given the context ctx.
 *
 * If there are no errors, we return an updated linear context along with the type
 * of the expression and an expression list
 */
method unique TypecheckResult typecheckExpression(unique LinearContext ctx, 
                          immutable Permission neededPerm, 
                          immutable ParsedExpression exp) 
{

  match (exp) {
    case ParsedApplication {
      ABORT("Lambdas not implemented in typechecker");
    }
    case ParsedAssignment {
      match (neededPerm) {
        case NonePermission {
          match (exp.target) {
            case ParsedEmptyExpr { //local-assign
              val unique Option<immutable VariableSymbol> localVarSymbolOption = symbolForAST(exp.field);
              match (localVarSymbolOption) {
                case Some {
                  match (ctx.containsSymbol(localVarSymbolOption.value)) {
                    case True {
                      val immutable Type neededType = localVarSymbolOption.value.getDeclaredType();
                      val unique TypecheckResult valueResult = typecheckExpression(ctx, neededType.permission, exp.value);
                      match (valueResult.expType.isSubTypeOf(neededType)) {
                        case True { 
                          val unique LinearContext newCtx = valueResult.ctxResult;
                          newCtx.update(localVarSymbolOption.value, neededType);
                          makeTypecheckResult(VOID, newCtx, valueResult.sourceLocList) 
                        }
                        case False { ABORT("<typecheckExpression>(Assignment) value has wrong structure") }
                      }
                    }
                    case False {
                      ABORT("<typecheckExpression>(Assignment) Variable '" + localVarSymbolOption.value.name + "' not found in the context")
                    }
                  }
                }
                case None {
                  match (exp.field) {
                    case ParsedIdentifier { ABORT("<typecheckExpression>(Assignment) No Symbol found for Variable '" + exp.target.name + "'") }
                    default { ABORT("<typecheckExpression>(Assignment) field not an identifier") }
                  }
                }
              }
            }
            case ParsedIdentifier { //field-Assign
              val unique Option<immutable VariableSymbol> targetVarSymbolOption = symbolForAST(exp.target);
              match (targetVarSymbolOption) {
                case Some {
                  match (ctx.containsSymbol(targetVarSymbolOption.value)) {
                    case True {
                      val immutable Type targetType = ctx.get(targetVarSymbolOption.value);
                      match (targetType.permission.isSubPermOf(LOCALSHARED)) {
                        case True {    
                          match(targetType.structure) {
                            case ObjectStructure {
                              val unique Option<immutable Signature> fieldSigOption = targetType.structure.getMember(exp.field.name);
                              match (fieldSigOption) {
                                case Some {
                                  match (fieldSigOption.value) {
                                    case FieldSignature {
                                      val immutable Type neededType = fieldSigOption.value.fieldType;
                                      val unique TypecheckResult valueResult = typecheckExpression(ctx, neededType.permission, exp.value);
                                      match (valueResult.expType.isSubTypeOf(neededType)) {
                                        case True { 
                                          val immutable ObjectStructure newStructure = targetType.structure.assignToField(exp.field.name);
                                          val unique LinearContext newCtx = valueResult.ctxResult;
                                          newCtx.update(targetVarSymbolOption.value, makeType(targetType.permission, newStructure));
                                          makeTypecheckResult(VOID, newCtx, makeLinkedList()) 
                                        }
                                        case False { ABORT("<typecheckExpression>(Assignment) value has wrong structure") }
                                      }
                                    }
                                    case UnpackedFieldSignature {
                                      val immutable Type neededType = fieldSigOption.value.packedSignature.fieldType;
                                      val unique TypecheckResult valueResult = typecheckExpression(ctx, neededType.permission, exp.value);
                                      match (valueResult.expType.isSubTypeOf(neededType)) {
                                        case True { 
                                          val immutable ObjectStructure newStructure = targetType.structure.assignToField(exp.field.name);
                                          val unique LinearContext newCtx = valueResult.ctxResult;
                                          newCtx.update(targetVarSymbolOption.value, makeType(targetType.permission, newStructure));
                                          makeTypecheckResult(VOID, newCtx, makeLinkedList()) 
                                        }
                                        case False { ABORT("<typecheckExpression>(Assignment) value has wrong structure") }
                                      }
                                    }  
                                    case MethodSignature {
                                      ABORT("<typecheckExpression>(Assignment) field '" + targetType.structure.toString() + "." + exp.field.name + "' is a method")
                                    }
                                    default {
                                      ABORT("<typecheckExpression>(Assignment) field '" + targetType.structure.toString() + "." + exp.field.name + "' has an unrecognized signature type") 
                                    }
                                  }
                                }
                                case None { ABORT("<typecheckExpression>(Assignment) field '" + targetType.structure.toString() + "." + exp.field.name + "' does not exist") }
                              } 
                            }
                            default { ABORT("<typecheckExpression>(Assignment) Target variable '" + targetVarSymbolOption.value.name + "' has a non-object structure") }
                          }
                        }
                        case False { ABORT("<typecheckExpression>(Assignment) Target variable '" + targetVarSymbolOption.value.name + 
                                           "' cannot be modified with permission '" + targetType.permission.toString() + "'")
                        }
                      }
                    }
                    case False { ABORT("<typecheckExpression>(Assignment) Target variable '" + targetVarSymbolOption.value.name + "' not found in the context") }
                  }
                }
                case None { ABORT("<typecheckExpression>(Assignment) no symbol found for target object '" + exp.target.name + "'") }
              }
            }
            default { ABORT("<typecheckExpression>(Assignment) target object must be an identifier") }
          }  
        }
        default { ABORT("<typecheckExpression>(Assignment) Assignments can only be given none permission; needed '" + neededPerm.toString()) } 
      }
    }
    case ParsedIdentifier {
      val unique Option<immutable Symbol> idSymbolOption = symbolForAST(exp);
      match (idSymbolOption) {
        case Some {
          match (ctx.containsSymbol(idSymbolOption.value)) {
            case True {
              val immutable Symbol idSymbol = idSymbolOption.value;
              val immutable Type currentType = ctx.get(idSymbol);
              val immutable Option<immutable Permission> newPermissionOption = currentType.permission.splitPerm(neededPerm);
              match (newPermissionOption) {
                case Some {
                  ctx.update(idSymbol, makeType(newPermissionOption.value,currentType.structure));
                  val slList = makeLinkedList();
                  slList.add(makeVarSourceLoc(idSymbol));
                  makeTypecheckResult(makeType(neededPerm,currentType.structure), ctx, slList)
                }
                case None {ABORT("<typecheckExpression>(Identifier) could not split permission '" + neededPerm.toString() + "' from permission '" + currentType.permission.toString() + "'") }
              }     
            }
            case False { ABORT("<typecheckExpression>(Identifier) ID '" + exp.name + "' not in the context") }
          }
        }
        case None { ABORT("<typecheckExpression>(Identifier) no symbol found for identifier '" + exp.name + "'") }
      }
    }
    default { ABORT("<typecheckExpression>(Assignment) Unexpected '" + exp.nodeName() + "' found during Expression typechecking") }
  }
}