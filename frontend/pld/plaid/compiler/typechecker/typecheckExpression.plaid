package plaid.compiler.typechecker;

import plaid.compiler.*;
import plaid.compiler.types.*;
import plaid.compiler.permissions.*;
import plaid.compiler.util.makeTypeFromAST;
import plaid.compiler.util.makePermissionFromAST;
import plaid.ast.util.makeStringFromQualifiedIdentifier;
import plaid.ast.parsed.*;
import plaid.compiler.aeminium.*;
import plaid.compiler.util.*;

import plaid.collections.makeLinkedList;

/**
 * To typecheck an expression, we attempt to give the Expression exp the permission needed Perm
 * given the context ctx.
 *
 * If there are no errors, we return an updated linear context along with the type
 * of the expression and an expression list
 *
 * NOTE: the linear context is treated imperatively and so is destructively updated
 *       during each typechecking case.  However, in the case of match we may
 *       need to merge multiple contexts together.  In this case, the returned
 *       context is a new context.  Thus, we cannot assume that the returned
 *       context is the same object as the incoming context.
 *
 */
method unique TypecheckResult typecheckExpression(unique LinearContext ctx, 
                          immutable Permission neededPerm, 
                          immutable ParsedExpression exp) 
{
  //DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check '" + exp.nodeName() + "' with ctx =\n" + ctx.toString());
  match (exp) {
    /*case ParsedApplication {
      ABORT("Lambdas not implemented in typechecker");
    }*/
    case ParsedAssignment {
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedAssignment");
      match (neededPerm) {
        case NonePermission {
          match (exp.target) {
            case ParsedEmptyExpr { //local-assign
              val unique Option<immutable VariableSymbol> localVarSymbolOption = symbolForAST(exp.field);
              match (localVarSymbolOption) {
                case Some {
                  match ( localVarSymbolOption.value.isVar() ) {
                      case True {}
                      case False { 
                      	report_ERROR(exp.token, 
                      				"T_ASSIGN_LOCAL_VAL", 
                      				"typecheckExpression");
                      	globalReporter.report();
                      	ABORT("assignment Failed");
                      	}
                  };
                  match (ctx.containsSymbol(localVarSymbolOption.value)) {
                    case True {
                      val immutable Type neededType = localVarSymbolOption.value.getDeclaredType();
                      val unique TypecheckResult valueResult = typecheckExpression(ctx, neededType.permission, exp.value);
                      match (valueResult.expType.isSubTypeOf(neededType)) {
                        case True { 
                          val unique LinearContext newCtx = valueResult.ctxResult;
                          newCtx.update(localVarSymbolOption.value, neededType);
                          makeTypecheckResult(VOID, newCtx, valueResult.sourceLocList) 
                        }
                        case False { ABORT("<typecheckExpression>(Assignment) value has wrong structure") }
                      }
                    }
                    case False {
                      ABORT("<typecheckExpression>(Assignment) Variable '" + localVarSymbolOption.value.name + "' not found in the context")
                    }
                  }
                }
                case None {
                  match (exp.field) {
                    case ParsedIdentifier { ABORT("<typecheckExpression>(Assignment) No Symbol found for Variable '" + exp.target.name + "'") }
                    default { ABORT("<typecheckExpression>(Assignment) field not an identifier") }
                  }
                }
              }
            }
            case ParsedIdentifier { //field-Assign
              val unique Option<immutable VariableSymbol> targetVarSymbolOption = symbolForAST(exp.target);
              match (targetVarSymbolOption) {
                case Some {
                  match (ctx.containsSymbol(targetVarSymbolOption.value)) {
                    case True {
                      val immutable Type targetType = ctx.get(targetVarSymbolOption.value);
                      match (targetType.permission.isSubPermOf(LOCALSHARED)) { //need at least local shared to assign to a field
                        case True {
                          // check for proper synronization of shared 
                          val immutable Boolean needsAtomic = match (targetType.permission) {
                              case SharedPermission { true } 
                              case LocalPermission {
                                  match (targetType.permission.thePerm) {
                                      case SharedPermission { true } 
                                      default { false }
                                  }
                              }
                              default { false }
                          };
                          match ( needsAtomic ) {
                              case True {
                                  match (ctx.inAtomic) {
                                       case True { /* noop */ }
                                       case False {
                                           report_ERROR(exp.target.token, "Assignment to fields of shared objects require protection of an atomic block.", "typecheckExpression");
                                       }
                                  }
                              }
                              case False { /* noop */ } 
                          };
                          
                          
                          match(targetType.structure) {
                            case ObjectStructure {
                              val unique Option<immutable Signature> fieldSigOption = targetType.structure.getMember(exp.field.name);
                              match (fieldSigOption) {
                                case Some {
                                  match (fieldSigOption.value) {
                                    case FieldSignature {
                                      val immutable Type neededType = fieldSigOption.value.getDeclaredType();
                                      val unique TypecheckResult valueResult = typecheckExpression(ctx, neededType.permission, exp.value);
                                      match (valueResult.expType.isSubTypeOf(neededType)) {
                                        case True { 
                                          val immutable ObjectStructure newStructure = targetType.structure.assignToField(exp.field.name, exp.token);
                                          val unique LinearContext newCtx = valueResult.ctxResult;
                                          newCtx.update(targetVarSymbolOption.value, makeType(targetType.permission, newStructure));
                                          
                                          if ( AEMINIUM_MODE() ) {
                                              val shared DependencyInformation assignInfo = makeASTInformation(exp);
                                              val shared DependencyInformation targetInfo = match (depInfoForSymbol(targetVarSymbolOption.value)) {
                                                  case Some { depInfoForSymbol(targetVarSymbolOption.value).value }
                                                  case None { ABORT("<typecheckExpression>(Assignment) cannot find dependency information for " + targetVarSymbolOption.value.name ) }
                                              };
                                              val shared DependencyInformation valueInfo = match ( depInfoForAST(exp.value) ) {
                                                  case Some { depInfoForAST(exp.value).value }
                                                  case None { ABORT("<typecheckExpression>(Assignment) cannot find dependency information for value") }                                       
                                              };
                                              addDependency(assignInfo, valueInfo);
                                              addDependency(assignInfo, targetInfo);
                                              setDepInfoForSymbol(targetVarSymbolOption.value, assignInfo);
                                              addDepInfoForAST(exp, assignInfo);
                                          };
                                          
                                          makeTypecheckResult(VOID, newCtx, makeLinkedList()) 
                                        }
                                        case False { ABORT("<typecheckExpression>(Assignment) value has wrong structure") }
                                      }
                                    }
                                    case MethodSignature {
                                      ABORT("<typecheckExpression>(Assignment) field '" + targetType.structure.toString() + "." + exp.field.name + "' is a method")
                                    }
                                    default {
                                      ABORT("<typecheckExpression>(Assignment) field '" + targetType.structure.toString() + "." + exp.field.name + "' has an unrecognized signature type") 
                                    }
                                  }
                                }
                                case None { ABORT("<typecheckExpression>(Assignment) field '" + targetType.structure.toString() + "." + exp.field.name + "' does not exist") }
                              } 
                            }
                            default { 
                                report_ERROR(exp.token, "(Assignment) Target variable '" + targetVarSymbolOption.value.name + "' has a non-object structure", "typecheckExpression");
                                globalReporter.report();
                      			ABORT("assignment Failed");
                            }
                          }
                        }
                        case False { ABORT("<typecheckExpression>(Assignment) Target variable '" + targetVarSymbolOption.value.name + 
                                           "' cannot be modified with permission '" + targetType.permission.toString() + "'")
                        }
                      }
                    }
                    case False { ABORT("<typecheckExpression>(Assignment) Target variable '" + targetVarSymbolOption.value.name + "' not found in the context") }
                  }
                }
                case None { ABORT("<typecheckExpression>(Assignment) no symbol found for target object '" + exp.target.name + "'") }
              }
            }
            default { ABORT("<typecheckExpression>(Assignment) target object must be an identifier") }
          }  
        }
        default { ABORT("<typecheckExpression>(Assignment) Assignments can only be given none permission; needed '" + neededPerm.toString()) } 
      }
    }
    case ParsedAtomicBlock {
        DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedAtomicBlock");
        
        match (ctx.inAtomic) {
            case True {
                report_ERROR(exp.token, "Nested atomic blocks detected", "typecheckExpression"); 
                globalReporter.report();
                ABORT("Nested atomic blocks detected");
            }
            case False { ctx.inAtomic = true }
        };
        
        val shared DependencyInformation atomicEnter = makeAtomicEnterInformation(exp);
        val symbols = new SymbolCollector;
        exp.body.accept(symbols); 
                 
        if ( AEMINIUM_MODE() ) {
            val it = symbols.externalSymbols.iterator();
            while { it.hasNext() }{
                val shared Symbol nextSym = it.next();
                val shared DependencyInformation nextInfo = match (depInfoForSymbol(nextSym)) {
                    case Some { depInfoForSymbol(nextSym).value }
                    case None { ABORT("<typecheckExpression>(AtomicBlock) cannot find dependency information for '" + nextSym.name + "'")  }
                };
                addDependency(atomicEnter, nextInfo);
                setDepInfoForSymbol(nextSym, atomicEnter);
            };
        };

        val typecheckResult = typecheckExpression(ctx, neededPerm, exp.body);
        
        if ( AEMINIUM_MODE() ) {
             val shared DependencyInformation atomicLeave = makeAtomicLeaveInformation(atomicEnter);
             val it = symbols.externalSymbols.iterator();
             while { it.hasNext() }{
                val shared Symbol nextSym = it.next();
                val shared DependencyInformation nextInfo = match (depInfoForSymbol(nextSym)) {
                    case Some { depInfoForSymbol(nextSym).value }
                    case None { ABORT("<typecheckExpression>(AtomicBlock) cannot find dependency information for '" + nextSym.name + "'")  }
                };
                addDependency(atomicLeave, nextInfo);
                setDepInfoForSymbol(nextSym, atomicLeave);
             };
             
             val shared DependencyInformation bodyInfo = match (depInfoForAST(exp.body) ) {
                case Some { depInfoForAST(exp.body).value }
                case None { ABORT("<typecheckExpression>(AtomicBlock) cannot find dependency information for body") } 
             };
             addDependency(atomicLeave, bodyInfo);
             addDependency(atomicLeave, atomicEnter);
             addDepInfoForAST(exp, atomicLeave);
        };
        
        // reset inAtomic
        ctx.inAtomic = false;
        
        typecheckResult
    }
    case ParsedBlockExpr {
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedBlockExpr");
      val immutable Integer blockSize = exp.statements.size();
      var immutable Integer count = 1;
      val /*unique LinkedList<immutable Pair<immutable Symbol, immutable LinkedList<immutable SourceLocation>>>*/ introducedLocalVars = makeLinkedList();
      val unique TypecheckResult seedResult = makeTypecheckResult(VOID, ctx, makeLinkedList());
      
      val immutable Boolean methodBlock = ctx.methodBlock;
      ctx.methodBlock = false;
      val shared DependencyInformation blockInfo = makeASTInformation(exp);
      if ( AEMINIUM_MODE() ) {
          addDepInfoForAST(exp, blockInfo);
      };
      
      val unique TypecheckResult blockResult = exp.statements.reduce(seedResult,fn (prevResult,stmt)
                           [immutable Integer count, immutable Permission neededPerm, unique LinkedList/*<...>*/ introducedLocalVars] => {
        val immutable Permission stmtNeededPerm = match (count == blockSize) {
          case True { neededPerm } //last statement in list gets neededPerm
          case False { NONEP }  // all others get NONEP
        };
        count = count+1;
        
        val unique TypecheckResult stmtResult = typecheckExpression(prevResult.ctxResult,stmtNeededPerm,stmt);
        
        if ( AEMINIUM_MODE() ) {
            match (count == (blockSize+1)) {
                case True {
                    val shared DependencyInformation stmtInfo = match (depInfoForAST(stmt)) {
                        case Some { depInfoForAST(stmt).value }
                        case None { 
                            report_ERROR(stmt.token, "(BlockExpr) cannot find dependency information for last stmt ","typecheckExpression");
                            globalReporter.report();
                			ABORT("dependency info not found");
                        }
                    };
                    addDependency(blockInfo, stmtInfo);
                }
                case False {
                    if ( methodBlock == false ) {
                        val shared DependencyInformation stmtInfo = match (depInfoForAST(stmt)) {
                            case Some { depInfoForAST(stmt).value }
                            case None { 
                                report_ERROR(stmt.token, "(BlockExpr) cannot find dependency information for last stmt ", "typecheckExpression");
                                globalReporter.report();
                				ABORT("dependency info not found");
                            }
                        };
                        addDependency(blockInfo, stmtInfo);                    
                    }
                }
            };
        };
        
        match (stmt) {
          case ParsedVarDecl { //this should be removed from scope and permissions returned at the end of the block
            match (haveSymbolForAST(stmt)) {
              case True {
                introducedLocalVars.addFirst(makePair(symbolForAST(stmt).value,stmtResult.sourceLocList));                
                makeTypecheckResult(VOID, stmtResult.ctxResult, makeLinkedList());  //take source locations out
              }
              case False { ABORT("<typecheckExpression>(implementation error) Symbol not found for '" + stmt.nodeName() + "' during block expr typechecking") }
            }
          }
          default { stmtResult }
        };
      });
      
      //remove introduced variables from scope, returning to their source locations,
      //this updates blockResult.ctxResult, which gets returned  (will never create a new context - no merging) 
      introducedLocalVars.do(fn (pairToRet) => {
        val immutable Symbol symLeavingScope = pairToRet.fst;
        match (blockResult.ctxResult.containsSymbol(symLeavingScope)) {
          case True {
            val immutable Type restoreType = blockResult.ctxResult.remove(symLeavingScope);
            listRestore(pairToRet.snd, restoreType, blockResult.ctxResult)
          }
          case False { ABORT("<typecheckExpression>(implementation error) variable '" + symLeavingScope.name + "' leaving scope is already gone in block expr typechecking") }
        }
      });
      
      if ( AEMINIUM_MODE() ) {
          val symbols = new SymbolCollector;
          exp.accept(symbols);
          
          val itSymbols = symbols.externalSymbols.iterator();
          while { itSymbols.hasNext() }{
              val nextSymbol = itSymbols.next();
              val symInfo = match (depInfoForSymbol(nextSymbol)) {
                  case Some { depInfoForSymbol(nextSymbol).value }
                  case None { report_ERROR(exp.token, "cannot find symbol for symbol '" + nextSymbol.name + "'" , "typecheckExpression"); }
              };
              addDependency(blockInfo, symInfo);
          };
      };
      
      blockResult.ctxResult.methodBlock = methodBlock;
      
      blockResult;
      
    }
    case ParsedCast { // Cast requires dynamic permission - may want to generalize this later - probably could also grab none?
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedCast");
      val unique TypecheckResult castExpResult = typecheckExpression(ctx, DYNAMICP, exp.expression);
      makeTypecheckResult(makeTypeFromAST(exp.targetType), castExpResult.resultCtx, makeLinkedList());
    }
    case ParsedDereference { /* Chained Dereferences not implemented currently */
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedDereference");
      match (exp.left) {
        case ParsedIdentifier {
          val unique Option<immutable Symbol> targetSymbolOption = symbolForAST(exp.left);
          match (targetSymbolOption) {
            case Some {
              val immutable Symbol targetSymbol = targetSymbolOption.value;
              match (ctx.containsSymbol(targetSymbol)) {
                case True {
                  val immutable Type targetType = ctx.get(targetSymbol);
                  val immutable Option<immutable Signature> fieldSigOption = targetType.structure.getMember(exp.right.name);
                  
                  // check for proper synronization of shared 
                  val immutable Boolean needsAtomic = match (targetType.permission) {
                      case SharedPermission { true } 
                      case LocalPermission {
                          match (targetType.permission.thePerm) {
                              case SharedPermission { true } 
                              default { false }
                          }
                      }
                      default { false }
                  };
                  match ( AEMINIUM_MODE() && needsAtomic ) {
                      case True {
                          match (ctx.inAtomic) {
                               case True { /* noop */ }
                               case False {
                                   report_ERROR(exp.left.token, "Reading fields of shared objects require protection of an atomic block.",  "typecheckExpression");
                                   globalReporter.report();
                                   ABORT("");
                               }
                          }
                      }
                      case False { /* noop */ } 
                  };
                     
                  match (fieldSigOption) {
                    case Some {
                      val immutable Signature fieldSig = fieldSigOption.value;
                      match (fieldSig) {
                        case FieldSignature {
                          val immutable Option<immutable FieldSignature> newFieldSigOption = fieldSig.splitPermFromField(neededPerm, targetType.permission);
                          match (newFieldSigOption) {
                            case Some {
                              val immutable FieldSignature newFieldSig = newFieldSigOption.value;
                              val immutable LinkedList<immutable FieldSourceLocation> sourceLocList = makeLinkedList(); 
                              match (newFieldSig == fieldSig) {
                                case True { /* no op - no updates made, no returns needed */ }
                                case False { 
                                  val immutable Structure updatedTargetStruct = targetType.structure.unpackField(newFieldSig, exp.token);
                                  ctx.update(targetSymbol, makeType(targetType.permission, updatedTargetStruct));
                                  //note will not typecheck - need to check that newFieldSig is an unpackedFieldSig
                                  //must be because if it is different than the old fieldSig, it must be unpacked
                                  sourceLocList.addFirst(makeFieldSourceLoc(targetSymbol, newFieldSig));                                                                
                                }
                              };
                              
                              if (AEMINIUM_MODE()) {                              
                                  val shared DependencyInformation drefInfo = makeASTInformation(exp);
                                  val shared DependencyInformation targetInfo = match (depInfoForSymbol(targetSymbol)) {
                                      case Some { depInfoForSymbol(targetSymbol).value }
                                      case None { ABORT("<typecheckExpression> cannot find dependency information for Symbol " + targetSymbol.name) }
                                  };
                                  
                                  val shared DependencyInformation splitInfo = makeSplitInformation(targetSymbol, targetType.permission, targetType.permission);
                                  val shared DependencyInformation joinInfo = makeJoinInformation(targetSymbol, targetType.permission, targetType.permission);
                                  
                                  addDependency(splitInfo, targetInfo);
                                  addDependency(drefInfo, splitInfo);
                                  addDependency(joinInfo, drefInfo);
                                  addDependency(joinInfo, splitInfo);
                                  addDepInfoForAST(exp, drefInfo);
                                  setDepInfoForSymbol(targetSymbol, joinInfo);
                                  
                                  if ( sourceLocList.size() > 0 ) {
                                      match (targetType.permission) {
                                          case LocalPermission { }
                                          default { addDepInfoForSLoc(sourceLocList.get(0).value, drefInfo); }
                                      }
                                  };
                              };
                              
                              makeTypecheckResult(makeType(neededPerm, fieldSig.getCurrentType().structure), ctx, sourceLocList);
                            } 
                            case None {
                              report_ERROR(exp.right.token, "(Deref) Permission '" + neededPerm.toString() + "' could not be split from field '" + exp.left.name + "." +
                                    exp.right.name + "' with permission '" + fieldSig.getCurrentType().permission.toString() + "' when target has permission '" +
                                    targetType.permission.toString() + "'", "typecheckExpression");
                            }
                          }
                        }
                        case MethodSignature {
                          ABORT("<typecheckExpression>(Deref) Deref target '" + exp.left.name + "' has structure '" + targetType.structure.toString() + 
                                "' in which member '" + exp.right.name + "' is a method, not a field") 
                        }
                      }
                    }
                    case None { 
                      ABORT("<typecheckExpression>(Deref) Deref target '" + exp.left.name + "' has structure '" + targetType.structure.toString() + 
                            "' which does not contain member '" + exp.right.name + "'") 
                    }
                  }
                }
                case False { ABORT("<typecheckExpression>(Deref) Deref target '" + exp.left.name + "' not in the context") }
              }
            }
            case None { ABORT("<typecheckExpression>(Deref) no symbol found for target identifier '" + exp.left.name + "'") }
          }     
        }
        default { ABORT("<typecheckExpression>(implementation error) chained dereferences not yet implemented") }
      }
    }
    case ParsedDoubleLiteral {  
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedDoubleLiteral");
      match (IMMUTABLE.splitPerm(neededPerm)) {
        case Some {
          val immutable Option<immutable Structure> doubleStructOption = structureForAST(exp);
          match (doubleStructOption) {
            case Some {
              match  ( AEMINIUM_MODE() ) {
                  case True {
                      DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(ParsedDoubleLiteral) " + exp.value);
                      val unique DependencyInformation depInfo = makeASTInformation(exp);
                      addDepInfoForAST(exp, depInfo);
                  }
                  case False {}
              };
              makeTypecheckResult(makeType(neededPerm, doubleStructOption.value), ctx, makeLinkedList());
            }
            case None {
              ABORT("<typecheckExpression>(implementation error) Double structure not found")
            }
          }
        }
        case None {
          ABORT("<typecheckExpression>(ParsedDoubleLiteral) Doubles can only be given immutable or less permission")
        }
      }
    }
    case ParsedEmptyExpr { ABORT("<typecheckExpression>(implementation error) Encountered EmptyExpression") }
    case ParsedIdentifier {
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedIdentifier");
      val unique Option<immutable Symbol> idSymbolOption = symbolForAST(exp);
      match (idSymbolOption) {
        case Some {
          match (ctx.containsSymbol(idSymbolOption.value)) {
            case True {
              val immutable Symbol idSymbol = idSymbolOption.value;
              val immutable Type currentType = ctx.get(idSymbol);
              val immutable Option<immutable Permission> newPermissionOption = currentType.permission.splitPerm(neededPerm);
              match (newPermissionOption) {
                case Some {
                  ctx.update(idSymbol, makeType(newPermissionOption.value,currentType.structure));
                  val slList = makeLinkedList();
                  val sloc = makeVarSourceLoc(idSymbol);
                  slList.addFirst(sloc);
                  
                  if ( AEMINIUM_MODE() ) {
                      // create split node
                      DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(Identifier) split permission of '" + exp.name + "' from " + currentType.permission + "=>" + neededPerm);
                      val shared DependencyInformation splitInfo = makeSplitInformation(idSymbol, currentType.permission, neededPerm);
                      splitInfo.inAtomic = ctx.inAtomic;
                      val shared DependencyInformation oldDepInfo = depInfoForSymbol(idSymbol).value;
                      addDependency(splitInfo, oldDepInfo);
                      setDepInfoForSymbol(idSymbol, splitInfo);
                      
                      // create ASTNode 
                      DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(Identifier) create ASTInformation node for '" + exp.name + "'");
                      val unique DependencyInformation expInfo = makeASTInformation(exp);
                      addDependency(expInfo, splitInfo);
                      addDepInfoForAST(exp, expInfo);
                      
                      // add sloc mapping
                      addDepInfoForSLoc(sloc, splitInfo);
                  };
                  
                  makeTypecheckResult(makeType(neededPerm,currentType.structure), ctx, slList)
                }
                case None { report_ERROR(exp.token, "(Identifier) could not split permission '" + neededPerm.toString() + "' from permission '" + currentType.permission.toString() + "'", "typecheckExpression"); }
              }     
            }
            case False { ABORT("<typecheckExpression>(Identifier) ID '" + exp.name + "' not in the context") }
          }
        }
        case None { ABORT("<typecheckExpression>(Identifier) no symbol found for identifier '" + exp.name + "'") }
      }
    }
    case ParsedIntLiteral {  
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedIntLiteral");
      match (IMMUTABLE.splitPerm(neededPerm)) {
        case Some {
          val immutable Option<immutable Structure> intStructOption = structureForAST(exp);
          match (intStructOption) {
            case Some {            
              match  ( AEMINIUM_MODE() ) {
                  case True {
                      DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(ParsedIntLiteral) " + exp.value);
                      val unique DependencyInformation depInfo = makeASTInformation(exp);
                      addDepInfoForAST(exp, depInfo);
                  }
                  case False {}
              };
                  
              makeTypecheckResult(makeType(neededPerm, intStructOption.value), ctx, makeLinkedList());
            }
            case None {
              ABORT("<typecheckExpression>(implementation error) Integer structure not found")
            }
          }
        }
        case None {
          ABORT("<typecheckExpression>(IntLiteral) Integers can only be given immutable or less permission")
        }
      }
    }
    //case ParsedLambda { }
    case ParsedMatch { 
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedMatch");
      match (exp.expression) {
        case ParsedIdentifier {
          val unique Option<immutable Symbol> targetSymOption = symbolForAST(exp.expression);
          match (targetSymOption) {
            case Some {
              val immutable Symbol targetSym = targetSymOption.value;
              match (ctx.containsSymbol(targetSym)) {
                case True {
                  val shared DependencyInformation enterInfo = makeMatchEnterInformation(exp);
                  val shared DependencyInformation leaveInfo = makeMatchLeaveInformation(enterInfo);
                  val unique SymbolCollector symbols = new SymbolCollector;
                  val unique Map symbolsToSplit = java.util.IdentityHashMap.new();
                  
                  if ( AEMINIUM_MODE() ) {
                       exp.accept(symbols);
                       
                       val it = symbols.externalSymbols.iterator();
                       while { it.hasNext() }{
                           val next = it.next();
                           // attach match_enter info for all used symbols
                           val shared DependencyInformation symInfo = match (depInfoForSymbol(next)) {
                                case Some { depInfoForSymbol(next).value }
                                case None { ABORT("<typecheckExpression>(Match) cannot find dependency information for " + next.name ) }
                           };
                           val immutable Type nextType = ctx.get(next);
                           val shared DependencyInformation splitInfo = makeSplitInformation(next, nextType.permission, nextType.permission);
                           symbolsToSplit.put(next, splitInfo);
                           addDependency(splitInfo, symInfo);
                           addDependency(enterInfo, splitInfo);
                       }; 
                       
                       addDepInfoForAST(exp, leaveInfo);
                  };
                
                  val immutable Type targetType = ctx.get(targetSym);
                  val unique LinkedList<unique TypecheckResult> caseResults = exp.caseList.map(fn (/*immutable ParsedCase*/ theCase) => 
                  {  /***** for each case *****/
                    if ( AEMINIUM_MODE() ) {                                           
                         val itSymbols = symbols.externalSymbols.iterator();
                         while { itSymbols.hasNext() }{
                             val nextSym = itSymbols.next();
                             // attach match_enter info for all used symbols
                             val shared DependencyInformation symInfo = match (depInfoForSymbol(nextSym)) {
                                  case Some { depInfoForSymbol(nextSym).value }
                                  case None { ABORT("<typecheckExpression>(Match) cannot find dependency information for " + next.name ) }
                             };
                             setDepInfoForSymbol(nextSym, enterInfo);
                         }; 
                    };
                    match (theCase) {
                      case ParsedPatternCase {
                        /* check that the structure of the case is a substructure of the target type*/
                        val immutable Option<immutable Symbol> patternSymOption = symbolForAST(theCase.pattern);
                        match (patternSymOption) {
                          case Some {
                            val immutable Symbol patternSym = patternSymOption.value;
                            match (patternSym) {
                              case StateSymbol {
                                val patternStruct = patternSym.getStructure();
                                match (patternStruct.isSubStructureOf(targetType.structure)) {
                                  case True {
                                    /* copy and update linear context with info from case */
                                    val unique LinearContext caseContext = ctx.copy();
                                    caseContext.update(targetSym, makeType(targetType.permission, patternStruct));
                                    
                                    /* return result from typechecking the body */
                                    val result = typecheckExpression(caseContext, neededPerm, theCase.body);
                                    
                                    if (AEMINIUM_MODE() ) {
                                        val shared DepenendencyInformation caseInfo = makeASTInformation(theCase);
                                        val shared DepenendencyInformation bodyInfo = match (depInfoForAST(theCase.body)) {
                                            case Some { depInfoForAST(theCase.body).value }
                                            case None { ABORT("<typecheckExpression>(Case) cannot find dependency information for case body") }
                                        };
                                        
                                        addDepInfoForAST(theCase, caseInfo);
                                        addDependency(caseInfo, bodyInfo);
                                        addDependency(leaveInfo, caseInfo);
                                        addDependency(bodyInfo, enterInfo);
                                    };
                                    
                                    result 
                                  }
                                  case False {
                                    ABORT("<typecheckExpression>(Case) pattern '" + makeStringFromQualifiedIdentifier(theCase.pattern) 
                                           + "' is not a substructure of '" + targetType.structure.toString()) 
                                  }
                                }
                              }
                              default { 
                                ABORT("<typecheckExpression>(implementation error) patterns must be mapped to state symbols, '" + 
                                      makeStringFromQualifiedIdentifier(theCase.pattern) + "' is not") 
                              }
                            }
                          }
                          case None { 
                            ABORT("<typecheckExpression>(Case) no symbol found for case pattern '" + 
                                  makeStringFromQualifiedIdentifier(theCase.pattern) + "'") 
                          }
                        } 
                      }
                      case ParsedDefaultCase {
                        /* copy linear context */
                        val unique LinearContext defaultContext = ctx.copy();
                        
                        /* return result from typechecking the body */
                        val result = typecheckExpression(defaultContext, neededPerm, theCase.body);
                        
                        if (AEMINIUM_MODE() ) {
                            val shared DepenendencyInformation caseInfo = makeASTInformation(theCase);
                            val shared DepenendencyInformation bodyInfo = match (depInfoForAST(theCase.body)) {
                                case Some { depInfoForAST(theCase.body).value }
                                case None { ABORT("<typecheckExpression>(Case) cannot find dependency information for case body") }
                            };
                            
                            addDepInfoForAST(theCase, caseInfo);
                            addDependency(caseInfo, bodyInfo);
                            addDependency(leaveInfo, caseInfo);
                            addDependency(bodyInfo, enterInfo);
                        };
                        
                        result
                      }
                    }
                  }); /****** end for each case *****/
                  
                  match (caseResults.size() > 0) {
                    case True {
                      /* take lub of return types, merge of the contexts, and accumulation of the location lists */
                      
                      /* first element is the seed (has at least one) */
                      val unique TypecheckResult seedCaseResult = caseResults.get(0).value;
                      var immutable Boolean skippedFirst = false;
                      /* collect all but first element of the list */
                      val restCaseRes = caseResults.collect(fn (caseRes) => {
                        ifElse (!skippedFirst) 
                          { skippedFirst = true; false }
                          { true } 
                      });

                      if ( AEMINIUM_MODE() ) {
                         val itSymbols = symbols.externalSymbols.iterator();
                         while { itSymbols.hasNext() }{
                             val nextSym = itSymbols.next();
                             // attach match_enter info for all used symbols
                             val shared DependencyInformation symInfo = match (depInfoForSymbol(nextSym)) {
                                  case Some { depInfoForSymbol(nextSym).value }
                                  case None { ABORT("<typecheckExpression>(Match) cannot find dependency information for " + next.name ) }
                             };
                             
                             
                             val shared DependencyInformation splitInfo = symbolsToSplit.get(nextSym);
                             val shared DependencyInformation joinInfo = makeJoinInformation(nextSym, splitInfo.permIn, splitInfo.permOut);
                             addDependency(joinInfo, splitInfo);
                             addDependency(joinInfo, leaveInfo);
                             setDepInfoForSymbol(nextSym, joinInfo);
                         };                                     
                      };
                      
                      /* reduce rest of list starting with first element as seed */
                      restCaseRes.reduce(seedCaseResult, fn (accResult, caseRes) => {
                        val immutable Option<immutable Type> returnTypeLUBopt = 
                                        accResult.expType.leastUpperBound(caseRes.expType);
                        match ( returnTypeLUBopt ) {
                          case Some {
                            val unique Option<unique LinearContext> mergedContextOpt = 
                                        accResult.ctxResult.merge(caseRes.ctxResult);
                            match ( mergedContextOpt ) {
                              case Some {
                                accResult.sourceLocList.append(caseRes.sourceLocList); //append is in place
                                
                                makeTypecheckResult(returnTypeLUBopt.value, 
                                                    mergedContextOpt.value, 
                                                    accResult.sourceLocList);
                              }
                              case None {
                                ABORT("<typecheckExpression>(Match) cannot merge contexts " +
                                      " coming from different cases") 
                              }
                            }
                          }
                          case None { 
                            ABORT("<typecheckExpression>(Match) no least upper bound " +
                                  " for return type of different cases") 
                          }
                        }
                      });
                    }
                    case False { ABORT("<typecheckExpression>(Match) no cases found") }
                  }
                }
                case False { ABORT("<typecheckExpression>(Match) target ID '" + exp.expression.name + "' not in the context") }
              }
            }
            case None { ABORT("<typecheckExpression>(Match) no symbol found for match target '" + exp.expresssion.name + "'") }
          }
        }
        default { ABORT("<typecheckExpression>(implementation error) match target can only be an identifier for now") }
      }
    }
    case ParsedMethodCall { 
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedMethodCall");
      /* receiver AST should be mapped to a type which gives us the signature of the method */
      val immutable Option<immutable Structure> receiverStructureOption = structureForAST(exp.receiver);
      val immutable MethodSignature methodSig = match(receiverStructureOption) {
        case Some {
          val immutable Structure receiverStructure = receiverStructureOption.value;
          match (receiverStructure) {
            case ObjectStructure {
              val immutable Option<immutable Signature> memberSigOption = 
                                    receiverStructure.getMember(exp.methodId.name);
              match (memberSigOption) {
                case Some {
                  val memberSig = memberSigOption.value;
                  match (memberSig) {
                    case MethodSignature {
                      memberSig
                    }
                    default {
                      ABORT("<typecheckExpression>(MethodCall) '" + receiverStructure.getName() + "." +
                        exp.methodId.name + "' is not a method")
                    }
                  }
                }
                case None { 
                  ABORT("<typecheckExpression>(MethodCall) '" + receiverStructure.getName() + "." +
                        exp.methodId.name + "' does not exist")
                }
              }
            }
            default { ABORT("<typecheckExpression>(MethodCall) receiver is not an object" ) }
          }
        }
        case None {
          ABORT("<typecheckExpression>(implementation error) receiver structure not mapped - cannot get needed permission")
        }
      };
      
      /* check that the neededPerm can be split from the return permission of the method */
      match (methodSig.returnType.permission.splitPerm(neededPerm)) {
        case Some {/* no op - continue */}
        case None {
          ABORT("<typecheckExpression>(MethodCall) cannot split needed permission '" + neededPerm.toString() +
                "' from method return permission '" + methodSig.returnType.permission.toString() + "'")
        }
      };
      
      /* use method signature to find the permissions needed for the receiver and the arguments */
      
      //build list of (argSpec, expression) with receiver followed by arguments
      val unique LinkedList<immutable ArgSpec> argSpecs = makeLinkedList();
      argSpecs.add(methodSig.receiverSpec);
      argSpecs.append(methodSig.arguments.map(fn (arg) => arg.snd));
      
      val unique LinkedList<immutable ParsedASTNode> inputExprs = makeLinkedList();
      inputExprs.add(exp.receiver);
      match (exp.argument) {
        case ParsedArgumentExpr { inputExprs.append(exp.argument.args.map(fn (arg) => arg)) }
        default { inputExprs.addLast(exp.argument) }
      };
      
      if (!( argSpecs.size() == inputExprs.size()) ) {
        ABORT("<typecheckExpression>(MethodCall) wrong number of arguments provided")
      };
      
      val /*immutable LinkedList<immutable Pair<immutable ParsedASTNode, immutable ArgSpec>>*/
          inputArgSpecList = inputExprs.zip(argSpecs); 
      
      var unique LinearContext currentContext = ctx;
      var immutable Integer inputCount = 0;
      
      //go through list in order typechecking each expression with the input permission
      val unique LinkedList<unique TypecheckResult> returnLocations = 
        inputArgSpecList.map(fn (ias) => {
          val immutable ParsedASTNode inputAST = ias.fst;
          val immutable ArgSpec inputSpec = ias.snd;
          
          val unique TypecheckResult inputResult = 
            typecheckExpression(currentContext, inputSpec.inputType.permission, inputAST);
          //once we have exceptions, catch errors here

          
          //check returned structure
          if (!(inputResult.expType.structure.isSubStructureOf(inputSpec.inputType.structure))) {
            //ABORT("<typecheckExpression>(MethodCall) structure of argument " + inputCount +  
            //      " not a substructure of required type")
            report_ERROR(inputAST.token, "(MethodCall) structure of argument " + inputCount +  " not a substructure of required type", "typecheckExpression");
          };
          
          inputCount = inputCount + 1;
          currentContext = inputResult.ctxResult;
          inputResult.sourceLocList;
        });
        
        
      // connect to parameters/receiver
      if ( AEMINIUM_MODE() ) {
           // AEminium dependency information
           val unique DependencyInformation mcallInfo = makeASTInformation(exp);
           addDepInfoForAST(exp, mcallInfo);
      
           // add dependency to parameters
           DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(MethodCall) let method call dependend on its receiver ");
           val receiverInfo = match (depInfoForAST(exp.receiver)) {
               case Some { depInfoForAST(exp.receiver).value}
               case None { ABORT("<typecheckExpression>(MethodCall) cannot find dependency information receiver ") }
           };
           addDependency(mcallInfo, receiverInfo);

           DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(MethodCall) let method call dependend on its parameters ");
           match (exp.argument) {
               case ParsedArgumentExpr {
                   exp.argument.args.do(fn (arg) => {
                       val argInfo = match (depInfoForAST(arg)) {
                           case Some { depInfoForAST(arg).value}
                           case None { ABORT("<typecheckExpression>(MethodCall) cannot find dependency information receiver ") }
                       };    
                       addDependency(mcallInfo, argInfo);
                   });
               }
               default {
                   ABORT("<typecheckExpression>(MethodCall) cannot handle non ArgExpressions yet ");
               }
           };
      };
      
      if ( AEMINIUM_MODE() == false ) {
          //downgrade context
          currentContext.downgrade();
      };
      
      //go through list in reverse order returning the output permission to generated sourceLocationList
      val /*immutable LinkedList<immutable Pair<immutable LinkedList<immutable SourceLocation>, immutable ArgSpec>>*/
          returnLocArgSpecList = returnLocations.zip(argSpecs); 
          
      val unique LinearContext outputContext = 
        returnLocArgSpecList.reduceRight(fn (rlas, reducedContext) => {
          val immutable LinkedList<immutable SourceLocaiton> returnList = rlas.fst;
          val immutable ArgSpec inputSpec = rlas.snd;
          
          listRestore(returnList, inputSpec.outputType, reducedContext);
          reducedContext
        
        }, currentContext);
        
      /* return needed permission with structure of method return 
       * (already checked return perm could be split)
       * with outputContext and no return locations  */
      makeTypecheckResult(makeType(neededPerm, methodSig.returnType.structure), outputContext, makeLinkedList());
    
    }
    case ParsedNewInstance { 
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedNewInstance");
      match (exp.stateExpr) {
        case ParsedStateRef {
          match (exp.stateExpr.stateExpr) {
            case ParsedIdentifier { 
              val immutable Symbol stateSymOption = symbolForAST(exp.stateExpr.stateExpr);
              match (stateSymOption) {
                case Some {
                  val immutable Symbol stateSym = stateSymOption.value;
                  match (stateSym) {
                    case StateSymbol {
                      val immutable LinkedList<immutable DeclSymbol> abstractMembers = stateSym.getAbstractMembers();
                      abstractMembers.do(fn (abstractMemberSymbol) => {
                        //look for a concrete decl in the specializations
                        val immutable Option<immutable Signature> declOption = exp.stateExpr.specializations.find(fn (sp) => {
                          match (sp) {
                            case ParsedDecl {
                              sp.name.name.equals(abstractMemberSymbol.name)
                            }
                            default { false }
                          }
                        });
                        

                        val immutable Signature declSig = match (declOption) {
                          case Some { //if there is one, grab its signature
                            val decl = declOption.value;
                            match (decl) {
                              case ParsedConcreteFieldDecl {
                                val immutable Option<immutable Symbol> fieldSymOption = symbolForAST(decl);
                                match (fieldSymOption) {
                                  case Some {
                                    val immutable Symbol fieldSym = fieldSymOption.value;
                                    match (fieldSym) {
                                      case FieldSymbol {
                                        fieldSym.getSignature()
                                      }
                                      default { ABORT("(implementation error) unexpected symbol for field Decl specialization in new instance") }
                                    } 
                                  }
                                  case None { ABORT("(implementation error) no symbol for field Decl specialization in new instance") }
                                } 
                              }
                              case ParsedConcreteMethodDecl {
                                val immutable Option<immutable Symbol> methodSymOption = symbolForAST(sp);
                                match (methodSymOption) {
                                  case Some {
                                    val immutable Symbol methodSym = methodSymOption.value;
                                    match (methodSym) {
                                      case MethodSymbol {
                                        methodSym.getSignature();
                                      }
                                      default { ABORT("(implementation error) unexpected symbol for method Decl specialization in new instance") }
                                    } 
                                  }
                                  case None { ABORT("(implementation error) no symbol for method Decl specialization in new instance") }
                                } 
                              }
                              case ParsedConcreteStateDecl { ABORT("(implementation error) state decls not implemented in specializers") }
                              case ParsedAbstractStateDecl { ABORT("(implementation error) state decls not implemented in specializers") }
                              case ParsedAbstractMethodDecl {
                                ABORT("<typecheckExpression>(newInstance) abstract specialization declaration cannot implement abstract member '" +
                                      abstractMemberSymbol.name + "' when instantiating state '" + stateSym.name + "'")
                              }
                              case ParsedAbstractFieldDecl {
                                ABORT("<typecheckExpression>(newInstance) abstract specialization declaration cannot implement abstract member '" +
                                      abstractMemberSymbol.name + "' when instantiating state '" + stateSym.name + "'")
                              }
                            }
                          }
                          case None { //otherwise error - not all members of state concrete
                            ABORT("<typecheckExpression>(newInstance) no concrete declaration for abstract member '" +
                                  abstractMemberSymbol.name + "' when instantiating state '" + stateSym.name + "'")
                          }                       
                        };
                        
                        //check that the concrete signature is a subsignature of the abstract declaration
                        // error if not
                        if (!(declSig.isSubSignatureOf(abstractMemberSymbol.getSignature()))) {
                          ABORT("<typecheckExpression>(newInstance) concrete declaration for abstract member '" +
                                  abstractMemberSymbol.name + "' not a substate of original declaration when instantiating state '" 
                                  + stateSym.name + "'")
                        }
                        //otherwise, pass
                      });
                    
                      if ( AEMINIUM_MODE() ) {
                          val shared DependencyInformation newInfo = makeASTInformation(exp);
                          addDepInfoForAST(exp, newInfo);
                      };
                    
                      //if all abstract members were found (no errors), then create a nominal type from the state for the return structure
                      val immutable Structure stateStruct = makeNominalStructure(stateSym);
                      makeTypecheckResult(makeType(neededPerm,stateStruct),ctx,makeLinkedList());
                    }
                    default { ABORT("(implementation error) unexpected symbol found for state '" + stateSym.name + "'") } 
                  }
                }
                case None { ABORT("<typecheckExpression>(New) no symbol found for stateExpr '" + exp.stateExpr.name + "'") }
              }
            }
            default { ABORT("<typecheckExpression>(implementation error) non-ID state refs not yet implemented") } 
          }
        }
        case ParsedWith { ABORT("<typecheckExpression>(implementation error) composition not yet implemented") }
        default { ABORT("<typecheckExpression>(implementation error) unexpected state node '" + exp.stateExpr.nodeName() + "' when typechecking new instance") }
      }
    }
    case ParsedReplace { 
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedReplace");
      if ( AEMINIUM_MODE() ) {
          report_ERROR(exp.token, "State change is not supported in AEminium!",  "typecheckExpression"); 
      };
      match (neededPerm) {
        case NonePermission {
          typecheckStateChange(ctx, exp.expression, exp.stateExpr, true)
        }
        default { ABORT("<typecheckExpression>(StateChangeReplace) state change only provides permission NONE") }
      }  
    }
    case ParsedStateChange { 
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedStateChange");
      if ( AEMINIUM_MODE() ) {
          report_ERROR(exp.token, "State change is not supported in AEminium!", "typecheckExpression"); 
      };
      match (neededPerm) {
        case NonePermission {
          typecheckStateChange(ctx, exp.expression, exp.stateExpr, false)
        }
        default { ABORT("<typecheckExpression>(StateChange) state change only provides permission NONE") }
      }  
    }
    case ParsedStringLiteral {  
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedStringLiteral");
      match (IMMUTABLE.splitPerm(neededPerm)) {
        case Some {
          val immutable Option<immutable Structure> stringStructOption = structureForAST(exp);
          match (stringStructOption) {
            case Some {
              match  ( AEMINIUM_MODE() ) {
                  case True {
                      DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(ParsedIntLiteral) " + exp.value);
                      val unique DependencyInformation depInfo = makeASTInformation(exp);
                      addDepInfoForAST(exp, depInfo);
                  }
                  case False {}
              };
              makeTypecheckResult(makeType(neededPerm, stringStructOption.value), ctx, makeLinkedList());
            }
            case None {
              ABORT("<typecheckExpression>(implementation error) String structure not found")
            }
          }
        }
        case None {
          ABORT("<typecheckExpression>(StringLiteral) String can only be given immutable or less permission")
        }
      }
    }
    case ParsedUnitLiteral { 
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedUnitLiteral");
          makeTypecheckResult(makeType(neededPerm, UNITSTRUCT),ctx,makeLinkedList())
    }
    case ParsedVarDecl { 
      DEBUG(DEBUG_PRIO_LOW, "<typecheckExpression> check ParsedVarDecl");
      val immutable Option<immutable Symbol> idSymOption = symbolForAST(exp.id);
      match (idSymOption) {
        case Some {
          val immutable Symbol idSym = idSymOption.value;
          match (ctx.containsSymbol(idSym)) {
            case True { //TODO: scoping/shadowing of local variables/global fields, etc
              ABORT("<typecheckExpression>(VarDecl) id '" + exp.id.name + "' already in scope") 
            }
            case False {
              val immutable Type neededType = makeTypeFromAST(exp.varType);
              val unique TypecheckResult valueResult = typecheckExpression(ctx, neededType.permission, exp.expr);
              match (valueResult.expType.isSubTypeOf(neededType)) {
                case True {
                  valueResult.ctxResult.put(idSym,neededType);
                  
                  match  ( AEMINIUM_MODE() ) {
                      case True {
                          DEBUG(DEBUG_PRIO_MEDIUM, "<typecheckExpression>(ParsedVarDecl) add '" + idSym.name +"' as start marker for new variable");
                          val unique DependencyInformation depInfo = makeASTInformation(exp);
                          setDepInfoForSymbol(idSym, depInfo);
                          addDepInfoForAST(exp, depInfo);
                          
                          // add dependency to expr
                          val shared DependencyInformatio expInfo = match ( depInfoForAST(exp.expr) ) {
                              case Some { depInfoForAST(exp.expr).value }
                              case None { ABORT("<typecheckExpression>(VarDecl) cannot find dependency information for expression") }
                          };
                          addDependency(depInfo, expInfo);
                      }
                      case False {}
                  };
                  
                  makeTypecheckResult(VOID,valueResult.ctxResult, valueResult.sourceLocList);
                }
                case False {
                  ABORT("<typecheckExpression>(VarDecl) type '" + valueResult.expType.toString() +
                        "' not compatible with declared type of local variable '" + 
                        exp.id.name + "': '" + neededType.toString() + "'") 
                }
              }
            }
          }
        }
        case None { ABORT("<typecheckExpression>(VarDecl) no symbol found for var id '" + exp.id.nodeName() + "'") }
      }
    }
    default { ABORT("<typecheckExpression> Unexpected '" + exp.nodeName() + "' found during Expression typechecking") }
  }
}