package plaid.compiler.util;

import plaid.ast.parsed.*;
import plaid.compiler.*;
import plaid.compiler.types.*;
import plaid.compiler.permissions.*;

method immutable Type makeTypeFromAST(immutable ParsedType typeNode) {
  match(typeNode) {
    case ParsedEmptyType { //If we didn't get type information, put Dynamic
      DEBUG(DEBUG_PRIO_LOW, "<makeTypeFromAST> EmptyType -> dynamicPermission DynamicStructure");
      new Type {
        val permission = DYNP;
        val structure = new DynamicStructure; 
      }
    }
    case ParsedConcreteType { //If we did construct a type
      DEBUG(DEBUG_PRIO_LOW, "<makeTypeFromAST> transform ConcreteType");
      
      //determine the permission first - may update it later
      var thePermission = makePermissionFromAST(typeNode.permission);
      
      //get the structure by using the symbol to type map
      val theStructure = match (typeNode.structure) {
        case ParsedNominalStructure {
          val qiSymbol = symbolForAST(typeNode.structure.stateQi);
          match (qiSymbol) {
            case Some {
              DEBUG(DEBUG_PRIO_LOW, "<makeTypeFromAST> create structure for state '" + qiSymbol.value.getFQN() + "'");
              
              //if no permission information specified, check if the state is immutable
              if (thePermission == DYNAMICP && qiSymbol.value.isImmutableState()) { 
                thePermission = IMMUTABLE
              };
              
              //return the structure
              qiSymbol.value.getType().structure;
            }
            case None {
                ABORT("Cannot find symbol for '" + makeStringFromQualifiedIdentifier(typeNode.stateQi) + "'");
            }
          }
        }
        case ParsedLambdaStructure {
          ABORT("Cannot handle LambdaTypes yet");
        }
        default {
          ABORT("Type node has unknown structure: " + typeNode.structure.nodeName());
        }
      };
      
      //create type from the permission and structure
      new Type {
        val permission = thePermission;
        val structure = theStructure;
      }
    }
    default {
        ABORT("Cannot create type from ASTNode. " + typeNode.nodeName());
    }
  }
}