package plaid.compiler.aeminium.tasks;

import plaid.compiler.*;
import plaid.compiler.types.*;
import plaid.compiler.aeminium.*;
import plaid.ast.parsed.*;

import plaid.collections.makeLinkedList;

state Task {
    val immutable Integer id; 
    val unique Set/*<Task>*/ deps = java.util.HashSet.new();
    val unique Set/*<Task>*/ rdeps  = java.util.HashSet.new();
    val unique Set infos/*<DependencyInformation>*/ = java.util.HashSet.new();
    var unique Option weightOpt = new None;
    val shared Resolver resolver;

    method immutable Boolean ==(shared Task other) {
        this.id == other.id
    }

    method immutable Boolean !=(shared Task other) {
        !(this == other)
    }

    method immutable String getID() {
        "" + id;
    }
    
    method void reset() {
        this.deps.clear();
        this.rdeps.clear();
        this.infos.clear();
    }
    
    method immutable Boolean fastMethod(immutable Structure struct, immutable String name) {
        val fqn = struct.symbol.getFQN() + "."+name;
        DEBUG(DEBUG_PRIO_MEDIUM, "<Task> fast method call for '" + fqn + "'" );
        
        // check cache
        match ( fastMethodCacheContains(fqn) ) {
            case True  { true }
            case False {
                var result = false;
                
                // check for builtin types  
                val fastObjects = makeLinkedList();
                fastObjects.add("plaid.lang.Integer");
                fastObjects.add("plaid.lang.String");
                fastObjects.add("plaid.lang.Boolean");
                fastObjects.add("plaid.lang.Float64");
                fastObjects.do( fn (stateName) => {
                    val symOpt = this.resolver.lookup(stateName);
                    match ( symOpt ) {
                        case Some {
                            if (struct.symbol == symOpt.value ) {
                                fastMethodCacheAdd(fqn);
                                result = true;
                            }
                        }
                        case None {}
                    };
                });
                
                // TODO: check for annotations 
                
                result
            }
        }
    }
    
    method immutable Integer getWeight() {

        match ( this.weightOpt) {
            case Some { this.weightOpt.value }
            case None {
                var weight = 0;
                val it = this.infos.iterator();
                while {it.hasNext()}{
                    val nextInfo = it.next();
                    
                    val nodeWeight =  match (nextInfo) {
                         case ASTInformation {
                             match (nextInfo.node) {
                                case ParsedMethodCall  {
                                    val receiverStructure = match ( structureForAST(nextInfo.node.receiver) ) {
                                        case Some { structureForAST(nextInfo.node.receiver).value } 
                                        case None { ABORT("<Task> Cannot find structure for receiver") }
                                    };
                                    match (receiverStructure) {
                                        case NominalStructure {
                                            ifElse ( fastMethod(receiverStructure, nextInfo.node.methodId.name) ) {
                                                0
                                            }{
                                                10
                                            } 
                                        }
                                        default { 10 }
                                    }
                                }
                                case ParsedVarDecl     {  0 }
                                case ParsedIdentifier  {  0 }
                                case ParsedArg         {  0 }
                                case ParsedBlockExpr   {  0 }
                                case ParsedLiteral     {  2 }
                                case ParsedDereference {  5 }
                                case ParsedAssignment  {  0 }
                                case ParsedNewInstance { 10 }
                                default { ABORT("<Task>(getWeight) Unsupported AST node " + nextInfo.node.nodeName() ) }
                             }
                         }
                         case AtomicEnterInformation { 0 }
                         case AtomicLeaveInformation { 0 } 
                         case MatchEnterInformation  { 0 }
                         case MatchLeaveInformation  { 0 } 
                         default { ABORT("<Task>(getWeight) Support AST information only.") } 
                    };
                    
                    weight = weight + nodeWeight;
                };
                
                this.weightOpt = makeSome(weight);
                
                weight
            }
        }
    }
    
    method immutable String toString() {
        var sb = java.lang.StringBuilder.new();
        sb.append("[");
        
        val it = this.infos.iterator();
        while { it.hasNext() }{
            sb.append(it.next().getID() + ",");
        };
        
        if ( sb.length() > 1 ) {
            sb.deleteCharAt(sb.length() - 1);
        };
        sb.append("]<" +this.getWeight() + ">");
        
        sb.toString();
    }
}