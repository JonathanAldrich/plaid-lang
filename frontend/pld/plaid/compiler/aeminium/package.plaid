package plaid.compiler.aeminium;

import plaid.compiler.*;

/*****************************************************************************
 ** global type map Symbol -> DependecyInformation
 ****************************************************************************/
var shared Map aeminiumSymbolToDepsMap = java.util.IdentityHashMap.new();

method void setDepInfoForSymbol(immutable Symbol symbol, unique DependencyInformation info) {
     aeminiumSymbolToDepsMap.put(symbol, info);
}

method immutable Option depInfoForSymbol(immutable Symbol symbol) {
    ifElse (aeminiumSymbolToDepsMap.containsKey(symbol) ) {
        makeSome(aeminiumSymbolToDepsMap.get(symbol));
    }{
        NONE
    }
}


/*****************************************************************************
 ** global type map ASTNode -> DependecyInformation
 ****************************************************************************/
var shared Map aeminiumASTToDepsMap = java.util.IdentityHashMap.new();

method void addDepInfoForAST(immutable ASTNode node, unique DependencyInformation info) {
     aeminiumASTToDepsMap.put(node, info);
}

method immutable Option depInfoForAST(immutable ASTNode node) {
    ifElse (aeminiumASTToDepsMap.containsKey(node) ) {
        makeSome(aeminiumASTToDepsMap.get(node));
    }{
        NONE
    }
}


/*****************************************************************************
 ** global type map SourceLocation -> DependecyInformation
 ****************************************************************************/
var shared Map aeminiumSLocToDepInfo = java.util.IdentityHashMap.new();

method void addDepInfoForSLoc(immutable SourceLocaction sloc, unique DependencyInformation info) {
     aeminiumSLocToDepInfo.put(sloc, info);
}

method immutable Option depInfoForSLoc(immutable SourceLocation sloc) {
    ifElse (aeminiumSLocToDepInfo.containsKey(sloc) ) {
        makeSome(aeminiumSLocToDepInfo.get(sloc));
    }{
        NONE
    }
}


/*****************************************************************************
 ** helper functions
 ****************************************************************************/

method unique Set findLastDependentsForSymbol(shared DependencyInformation depInfo,
                                              shared Symbol symbol,
                                              immutable Boolean onlyAST) {
                                              
    DEBUG(DEBUG_PRIO_LOW, "<findLastDependents> for " + depInfo.toString() + " astOnly="+onlyAST);
    val set = java.util.HashSet.new();
    
    val immutable Boolean valid = match (depInfo) {
        case ASTInformation   { true }
        case JoinInformation  { depInfo.symbol == symbol }
        case SplitInformation { depInfo.symbol == symbol }
    };
    
    if ( valid ) {
        // try to find recursively find last dependent
        val it = depInfo.rdeps.iterator();
        while {it.hasNext()}{
            val recursiveSet = findLastDependentsForSymbol(it.next(), symbol, onlyAST);
            set.addAll(recursiveSet)
        };
        // add current node if recursive serach failed 
        if ( set.size() == 0 ) {
            match (onlyAST) {
                case True {
                    match (depInfo) {
                        case ASTInformation { set.add(depInfo) } 
                        default { }
                    }
                }
                case False {
                    set.add(depInfo);
                }
            }
            
        };
    };
     
    set
}

method void addDependency(shared DependencyInformation from,
                          shared DependencyInformation to) {
    DEBUG(DEBUG_PRIO_LOW, "<addDependency> " + from.toString() + " -> " + to.toString() );
    from.deps.add(to);
    to.rdeps.add(from);
}

method void dumpGraph(immutable ParsedDecl declNode) {
    val ggg = new GraphvizGraphGenerator { val declNode = declNode; };
    
    val immutable String dump = ggg.dump();

    // dump file 
    val file = java.io.File.new(ggg.getPath() +".dot");
    val fw = java.io.FileWriter.new(file);
    fw.write(dump);
    fw.flush();
    fw.close();
    
}




/*****************************************************************************
 ** factory methods
 ****************************************************************************/
 
 var immutable Integer depInfoIdCounter = 0;
 
 method immutable Integer nextDepInfoId() {
     depInfoIdCounter = depInfoIdCounter + 1;
     depInfoIdCounter
 }
 
 method unique ASTInformation makeASTInformation(immutable ASTNode node) {
    new ASTInformation {
        val id    = nextDepInfoId();
        val deps  = java.util.HashSet.new();
        val rdeps = java.util.HashSet.new();
        val node  = node;
    }
 }
 
 method unique SpitInformation makeSplitInformation(shared Symbol symbol,
                                                    immutable Permission permIn,
                                                    immutable Permission permOut) {
    new SplitInformation {
        val id      = nextDepInfoId();
        val deps    = java.util.HashSet.new();
        val rdeps   = java.util.HashSet.new();
        val symbol  = symbol;
        val permIn  = permIn;
        val permOut = permOut;
    }
}

method unique JoinInformation makeJoinInformation(shared Symbol symbol,
                                                  immutable Permission permIn,
                                                  immutable Permission permOut) {
    new JoinInformation {
        val id      = nextDepInfoId();
        val deps    = java.util.HashSet.new(); 
        val rdeps   = java.util.HashSet.new();
        val symbol  = symbol;
        val permIn  = permIn;
        val permOut = permOut;
    }
}