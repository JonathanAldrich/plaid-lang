/**
 * Copyright (c) 2010 The Plaid Group (see AUTHORS file)
 * 
 * This file is part of Plaid Programming Language.
 *
 * Plaid Programming Language is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 *  Plaid Programming Language is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Plaid Programming Language.  If not, see <http://www.gnu.org/licenses/>.
 */

package plaid.compiler;

// TODO (2) make import X.* work if an element in X is used more than once (dynamically)
//import java.lang.*;
//import java.lang.System;
//import java.io.PrintWriter;
//import java.io.File;
//import javax.tools.ToolProvider;
//import java.util.ArrayList;

state Null {
}


state Link {
	var value;
	var next;

	method do(Function f) {
		//System.out.println("visiting");
		f(this.value);
		this.next.do(f);
	}
	
	method fold(Alpha unitObject, Function f) 
	{
		n = this.next;
	    //match n {
	    //	case EmptyLink el => this.value;
	    //	case Link l => f (this.value) (l.fold(unitObject, f));
	    //}
	    n.nextFold(this.value, unitObject, f);
	}
	
	method nextFold(Alpha value, Alpha unitObject, Function f) {
		System.out.println("yay");
		f2 = f (value);
		f2 (this.fold(unitObject, f))
	}
	
	method collect(f, l) {
		System.out.println("collecting");
		result = f(this.value);
		newLink = l.append(result);
		this.next.do(f, newLink);
	}
	
}

state EmptyLink {
	method append(Object o) {

		break;
		newEmpty = new EmptyLink with { int x = o; };
		this <- Link with { value = o; next = newEmpty; };
		newEmpty;
	}
	
	method nextFold( value,  unitObject,  f) {
		value;
	}
	
	method do( f) { }
	method fold( unitObject, f) 
	{
	    unitObject;
	}
	method collect( f,  l) { }
}

state List {
	var first;
	var last;

	method init() {
		this.first = new EmptyLink{};
		this.last = this.first;
	}

	method do(f) {
		this.first.do(f);
	}
	
	method fold(unitObject, f) {
		this.first.fold(unitObject, f);
	}

	/*void foo(r, r2) {
		System.out.println("fooing");
	}*/
	
	method collect(Function f) {
		result = new EmptyLink{};
		//this.foo(result, result);
		this.first.collect(f, result);
		result
	}
	
	method append(o) {
		this.last = this.last.append(o);
		/*match this.first {
			case EmptyLink el =>
				System.out.println("adding to empty");
				el.
				link = new Link{};
				link.init(o, this.first);
				this.first = link;
				this.last = link;
			case Link l =>
				System.out.println("adding to existing list");
				link = new Link{};
				link.init(o, new EmptyLink{});
				this.last.setNext(link);
				this.last = link;				
		};*/
	}
}


state CompilationUnit {
	var decls;
	var packageName;

	method init() {
		this.decls = new List{};
		this.decls.init();
	}
	
	method setPackageName(List name) {
		this.packageName = name;
	}
	
	method getPackageName() { packageName }
	
	method addDecl(Decl d) {
		this.decls.append(d);
		//this.decls = new List { List next = this.decls; Object value = d; };
	}
	
	method getDecls() { this.decls }
	
	method toJavaAST() {
		System.out.println("converting to Java");
		decls.collect(fn (Declaration d) => {
			d.toTopLevelJavaAST(this)
		});
	}

	method removeApplications() {
		this.decls.do(fn (Declaration d) => {
			d.removeApplications()
		});
	}

	method codegen(PrintWriter out) {
	    //string pnString = packageName.fold("", 
	    //	fn(string s1) =>
	    //	(fn (string s2) => s1 + "." + s2));
	    //out.println(packageName.first.value);
	    //out.println(packageName.first.next.value);
		out.print("package ");
		StringBuilder sb = new java.lang.StringBuilder{};
		//packageName.do(fn (string s) => out.print(s + "."));
		packageName.do(fn (string s) => sb.append("." + s));
		sb.deleteCharAt(0);
		out.print(sb.toString() + ";\n");
		out.println("");
		
		this.decls.do(fn (Declaration d) =>
			{ d.codegen(out) }
		);
		
		/*out.println("class Output {");
		out.println("    public static void main(String args[]) {");
		out.println("        System.out.println(\"Hello, world!\");");
		out.println("    }");
		
		out.println("}");*/
		
		out.flush();
	}	
}

state Class {
	var decls;
	var name;

	method init() {
		this.decls = new List{};
		this.decls.init();
	}
	
	method setName(String name) {
		this.name = name;
	}
	
	method getPackageName() { name }
	
	method addDecl(Decl d) {
		this.decls.append(d);
	}
	
	method getDecls() { this.decls }
	
	method codegen(PrintWriter out) {		
		out.println("class " + name + " {");
		
		this.decls.do(fn (Declaration d) =>
			{ d.codegen(out) }
		);

		/*out.println("    public static method main(String args[]) {");
		out.println("        System.out.println(\"Hello, world!\");");
		out.println("    }");*/
		
		out.println("}");
	}	
}

state Method {
	var name;
	var exp;
	
	/*method init(String n) {
		this.name = n;
	}*/
	method setExp(Expression e) {
		System.out.println("setting");
		this.exp = e;
	}

	method removeApplications() {
		this.exp.removeApplications();
	}

	method toTopLevelJavaAST(CompilationUnit container) {
		// create a new CompilationUnit for this top-level main method
		cu = new CompilationUnit{};
		cu.init();
		cu.setPackageName(container.getPackageName());
		
		// create a class with the name of the method
		cls = new Class{};
		cls.init();		
		cls.setName(this.name);
		
		// create a method called Main with the right stuff
		mainName = "main"; // shouldn't have to create this temporary, but...
		meth = new Method{ String name = mainName; Expression exp = this.exp; };

		cls.addDecl(meth);
		cu.addDecl(cls);
		cu
	}
	
	method codegen(PrintWriter out) {
		out.println("    public static method " + name + "(String args[]) {");
		
		out.print("        ");
		this.exp.codegen(out);
		out.println(";");

		out.println("    }");
	}	
}

state ID {
	var name;
	
	method getName() { name }
	
	method codegen(PrintWriter out) {
		out.print(name);
	}
	method removeApplications() {
	}
}

state StringLiteral {
	var string;
	
	method codegen(PrintWriter out) {
		out.print("\"");
		out.print(string);
		out.print("\"");
	}
	method removeApplications() {
	}
}

state IntLiteral {
	var integer;
	
	method codegen(PrintWriter out) {
		out.print(integer.toString());
	}
	method removeApplications() {
	}
}

state Dereference {
	var left;
	var right;
	
	method setLeft(Expression e) {
		this.left = e;
	}

	method setRight(Expression e) {
		this.right = e;
	}

	method codegen(PrintWriter out) {
		this.left.codegen(out);
		out.print(".");
		this.right.codegen(out);
	}
	method removeApplications() {
		this.left.removeApplications();
		this.right.removeApplications();
	}
}

state MethodCall {
	var receiver;
	var argument;
	var methodName;
	
	method setReceiver(Expression e) {
		this.receiver = e;
	}

	method setArgument(Expression e) {
		this.argument = e;
	}

	method setMethodName(String n) {
		this.methodName = n;
	}

	method codegen(PrintWriter out) {
		this.receiver.codegen(out);
		out.print("." + methodName + "(");
		this.argument.codegen(out);
		// TODO: support ')'
		out.print(")");
	}
	method removeApplications() {
		this.receiver.removeApplications();
		this.argument.removeApplications();
	}
}

state Application {
	var function;
	var argument;
	
	method setFunction(Expression e) {
		this.function = e;
	}
	method setArgument(Expression e) {
		this.argument = e;
	}
	method removeApplications() {
		f = this.function;
		f.removeApplications();
		a = this.argument;
		a.removeApplications();
		match f {
			//case ID id =>
			case Dereference d =>
				l = d.left;
				r = d.right.getName();
				this <- MethodCall {
					Expression receiver = l;
					Expression argument = a;
					String methodName = r;
				}
		};
	}
}

state ASTFactory {
	FileInputStream inputStream;

	CompilationUnit makeCompilationUnit() { new CompilationUnit{}; }
	Method makeMethod(String n) { new Method{ String name = n; }; }
	ID makeID(String n) { new ID{ String name = n; }; }
	StringLiteral makeStringLiteral(String n) { new StringLiteral{ String string = n; }; }
	IntLiteral makeIntLiteral(Int i) {new IntLiteral{ Int integer = i; }; }
	Dereference makeDereference() { new Dereference{ }; }
	MethodCall makeMethodCall() { new MethodCall{ }; }
	Application makeApplication() { new Application{ }; }
	List makeList() { 
		List l = new List { }; 
		l.init();
		l;
	}
	FileInputStream getInputStream() { this.inputStream }
	method setInputStream(FileInputStream str) { this.inputStream = str }
}

state Compiler {
    // TODO (3): support static methods
    static Compiler create() {
    	new Compiler {};
    }
	method compile() {
		// open the file
		args = plaid.lang.System.getCommandLineArguments();
		filename = args.get(0);
		inputfile = new java.io.FileInputStream{ String name = filename; };
	
		// parse the code
		factory = new ASTFactory{};
		factory.setInputStream(inputfile);
		cu1 = plaid.compiler.Parser.parse(factory);
		
		// remove applications
		System.out.println("removing function applications");
		cu1.removeApplications();
		
		// transform to Java
		cu2s = cu1.toJavaAST();
		
		// create the output file
		tempfile = File.createTempFile("Output",".java");
		// useful later for directories and real temp files:
		// tempfile.delete();
		// tempfile.mkdir();
		tempfile.deleteOnExit();
		out = new PrintWriter { File file = tempfile; };
		
		// generate code
		System.out.println("GENERATING CODE");
		cu2s.do( fn(CompilationUnit cu) => {
			System.out.println("generating code for file " + tempfile.getAbsolutePath());
			cu.codegen(System.out);
			cu.codegen(out);
		});

		/*cu1.codegen(out);*/
		
		// create the list of files
		fileList = new ArrayList{};
		fileList.add(tempfile);

		null = new Null{};
		
		// convert filelist using StandardJavaFileManager
		compiler = ToolProvider.getSystemJavaCompiler();
        fileManager = compiler.getStandardFileManager(null, null, null);
		fileObjects = fileManager.getJavaFileObjectsFromFiles(fileList);
		
		// invoke the compiler
		task = compiler.getTask(null, null, null, null, null, fileObjects);
		resultCode = task.call();
		System.out.println("result = " + resultCode.toString());
    }
}

// TODO (3): allow calling this as the top-level function
method compile() {
	c = Compiler.create();
	c.compile();
}

// TODO (3): this should execute
var x = new Compiler{}.compile();

// TODO (2): allow calling compile from main
method main() {
	//compile();
	c = new Compiler { };
	c.compile();
}