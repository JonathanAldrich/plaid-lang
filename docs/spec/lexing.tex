\section{Lexical Structure}

The lexical structure of Plaid is largely borrowed from Java, but there are 
significant differences.  Specifically:

\begin{itemize}

\item Plaid uses the same definitions of line terminators as Java (JLS
  section 3.4), the same input elements and tokens (JLS section 3.5)
  except for a different keyword list, and the same definition of
  whitespace (JLS section 3.6).

\item Plaid uses the same definition of comments as Java (JLS section 3.7).

\item Plaid uses the same definition of identifiers as Java (JLS section 3.8).

\item Plaid literals are based on Java literals (JLS section
3.10), but there are several substantial differences. Plaid 
string literals are the same as Java string literals. 
Plaid integer literals are of arbitrary length. Plaid 
rational literals are like Java double literals but are of 
arbitrary length. Furthermore, Boolean objects named 
\texttt{true} and \texttt{false} exist in the standard library,
but unlike in Java these are not keywords in Plaid. No other 
Java literals are currently supported, but future versions 
of Plaid will support all Java literals except the null literal.
  
\item Plaid uses the same definition of Separators as Java (JLS section 3.11).

\end{itemize}


\subsection{Keywords}

The following character sequences, formed from ASCII letters, are reserved
for use as \textit{keywords} and cannot be used as identifiers:

\begin{quote}
\ntermdef{Keyword} \oneof 
\end{quote}
\[
  \begin{array}{cccccc}
  \keyw{atomic}
  & \keyw{callonce}
  & \keyw{case} 
  & \keyw{default}
  & \keyw{dyn} 
  \\ 
  \keyw{dynamic}
  & \keyw{exclusive} 
  & \keyw{fn}
  & \keyw{freeze}
  & \keyw{full} 
  \\
  \keyw{group}  
  &\keyw{immutable}
  & \keyw{import}
  & \keyw{local}
  & \keyw{match}
  \\
  \keyw{method}
  & \keyw{mutable}
  &\keyw{new}
  & \keyw{none}
  & \keyw{of}
  \\
  \keyw{override} 
  & \keyw{package}
  & \keyw{pure}
  & \keyw{readonly}
  & \keyw{remove}
  \\
  \keyw{rename}
  & \keyw{requires}
  &\keyw{shared}
  & \keyw{split}  
  & \keyw{state}
  \\
  \keyw{stateval}
  & \keyw{this}
  & \keyw{top}
  & \keyw{type} 
  & \keyw{unique} 
  \\ 
  \keyw{unpack}
  & \keyw{val}
  & \keyw{var}
  & \keyw{void}
  & \keyw{with}
  \end{array}
\]

%\TODO{The list above is only a current estimate, this will change as
%  we get the whole language defined.  Should also put the above into
%a nice table as in the JLS.}

%Note that \keyw{true} and \keyw{false} are actually boolean literals,
%as in Java.





\subsection{Operators}

We first define operator characters as follows:

\begin{quote}

\ntermdef{OperatorChar} \oneof

\defspace \texttt{= < > ! $\sim$ ? : \& | + - * / \^{} \%}

\end{quote}

Now an operator is a sequence of operator characters:

\begin{quote}

\ntermdef{Operator}

\defspace \nterm{OperatorChar}

\defspace \nterm{OperatorChar} \nterm{Operator}

\end{quote}

The exception to the grammar above is that the character sequences
\texttt{=}, \texttt{=>}, \texttt{<{}<-}, \texttt{>{}>} and \texttt{<-} have
other meanings in the language and may not be used as operators.
Furthermore, operators containing the comment sequences \texttt{/*}
or \texttt{//} may not be used as operators.
