\section{Types}

\begin{quote}

\ntermdef{Type}

\defspace \opt{\keyw{immutable}} \nterm{LambdaStructure}

\defspace \opt{\nterm{Permission}} \nterm{NominalStructure}

\defspace (\nterm{Type})

\ntermdef{Permission}

\defspace \keyw{none}

\defspace \keyw{unique}

\defspace \nterm{SymmetricPermission}

\defspace \nterm{LocalPermission}

\ntermdef{SymmetricPermission}

\defspace \keyw{shared} <\nterm{SimpleExpr1}>

\defspace \keyw{immutable}

\ntermdef{LocalPermission} 

\defspace \keyw{local} \nterm{SymmetricPermission}

\ntermdef{LambdaStructure} 

\defspace \opt{\nterm{MetaParams}} (\nterm{ArgSpecs}) \opt{[ \nterm{Args}]} -> \nterm{Type}

\ntermdef{NominalStructure} 

\defspace \nterm{QualifiedIdentifier} \opt{MetaArgs}

\ntermdef{ArgSpecs}

{\defspace \nterm{ArgSpec} \seq{ * \nterm{ArgSpec} }}



\end{quote}

Function types include optional arguments in brackets [] that specify
permissions to objects in scope, along with their state transitions.
\nterm{ArgSpecs} include just the permission and the state, while
\nterm{Args} includes the variable name as well (since for the optional
arguments we are naming variables currently in scope).

Formally, a function that accepts multiple arguments actually accepts an
argument tuple, which is written with a \code{*}-separated list.

Permission and state combinations include an optional permission kind,
which defaults to \keyw{immutable} if the state given is an \keyw{immutable}
state, or \keyw{dyn} otherwise.

