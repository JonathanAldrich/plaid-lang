package plaid.aeminium.codegen;

state DependencyAnalysis {
	method printDependencies(deps) {
		val it = deps.iterator();
		
		java.lang.System.out.println("Found dependencies:");
		while { it.hasNext(); } {
			val dep = it.next();
			
			java.lang.System.out.println("  " + dep.from.num + " -> " + dep.to.num + " with " + dep.variable.name);
		};
	}
	
	method createDependencyGraph(nodeList, deps) {
		var methodName = "";
		
		match (nodeList.head) {
			case Cons {
				methodName = nodeList.head.value.astRef.name;
			}
			default {}
		};
	
		val s = java.lang.StringBuilder.new();
		s.append("digraph G {\n\trankdir=BT;\n\n");
		
		nodeList.map(fn (node) => {
			s.append("\t" + node.num + " [label=\"" + node.toString() + "\"];\n");
		});
		
		val it = deps.iterator();
		while { it.hasNext(); } {
			val dep = it.next();
			s.append("\t" + dep.from.num + " -> " + dep.to.num);
			s.append("[label=\"" + dep.variable.name + "\"];\n");
		};
		s.append("}\n");
		
		val fw = java.io.FileWriter.new(methodName + ".dot");
		fw.write(s.toString());
		fw.close();
		java.lang.Runtime.getRuntime().exec("dot -Tpng -o " + methodName + ".png " + methodName + ".dot").waitFor();		
	}
	
	method makeDependency(f, t, v) {
		new Dependency {
			val from = f;
			val to = t;
			val variable = v;
		};
	}

	method computeDependencies(nodeList) {
		val writer = java.util.HashMap.new();
		val readers = java.util.HashMap.new();
		val deps = java.util.HashSet.new();
		
		nodeList.map(fn (aemNode) => {
			var it = aemNode.reads.iterator();
			while { it.hasNext(); } {
				val read = it.next();
				
				java.lang.System.out.println(read);
				
				if (writer.containsKey(read.name)) {
					val prevWriter = writer.get(read.name);
					
					deps.add(makeDependency(aemNode, prevWriter, read));
				};
				
				if (!readers.containsKey(read.name)) {
					readers.put(read.name, java.util.HashSet.new());
				};
				
				readers.get(read.name).add(aemNode);
			};
			
			it = aemNode.writes.iterator();
			while { it.hasNext(); } {
				val write = it.next();
				
				ifElse (readers.containsKey(write.name)) {
					val prevReaders = readers.get(write.name);
					val readIt = prevReaders.iterator();
					
					while { readIt.hasNext(); } {
						val prevReader = readIt.next();
						// TODO: Add inequality check.
						deps.add(makeDependency(aemNode, prevReader, write));
					};
				} {
					if (writer.containsKey(write.name)) {
						val prevWriter = writer.get(write.name);
						// TODO: Add inequality check.
						deps.add(makeDependency(aemNode, prevWriter, write));
					};
				};
				
				writer.put(write.name, aemNode);
				readers.remove(write.name);
			};
		});
		
		printDependencies(deps);
		createDependencyGraph(nodeList, deps);
		
		deps;
	}
}