package plaid.aeminium.codegen;

import plaid.ast.*;

state AeminiumNode {
	val /*Integer*/ num;
	val /*ASTNode*/ astRef;
	
	val /*Set<ID>*/ reads = java.util.HashSet.new();
	val /*Set<ID>*/ writes = java.util.HashSet.new();
	
	method astToString(astNode) {
		var ret = "";
		
		match (astNode) {
			case MethodDecl {
				ret = "method " + astNode.name + "(";
				var args = "";
				astNode.methodType.argNames.map(fn (id) => {
					args = args + id.name + ", ";
				});
				
				if (!args.isEmpty()) {
					args = args.substring(0, args.length() - 2);
					ret = ret + args + ")";
				};
			}
			
			case Split {
				ret = "split " + astNode.in.name + " => " + astNode.out1.name + "/" + astNode.out2.name;
			}
			
			case Join {
				ret = "join " + astNode.in1.name + "/" + astNode.in2.name + " => " + astNode.out.name;
			}
			
			case UnannotatedLetBinding {
				ret = "let " + astNode.x.name + " = " + astToString(astNode.exp);
			}
			
			case Application {
				ret = astNode.f.name + "(" + astToString(astNode.arg) + ")";
			}
			
			case ID {
				ret = astNode.name;
			}
			
			case IntLiteral {
				ret = astNode.integer;
			}
			
			case UnitLiteral {
				ret = "nop";
			}
			
			default {
				ret = "something";
			}
		};
		
		ret;
	}
	
	method toString() {
		astToString(this.astRef);
	}
}