package plaid.aeminium.codegen.testcases;

import plaid.ast.types.*;
import plaid.ast.*;

state Fibonacci case of TestCase {
	val methodTypes = java.util.HashMap.new();
	
	// method unique Integer fibonacci(immutable Integer n) {
	//   ifElse (n <= 2) {
	//     1;
	//   } {
	//     fibonacci(n - 1) + fibonacci(n - 2);
	//   };
	// }
	
	
	
	// $ifLambda:
	//   1;
	
	method makeIfLambda() {
		val argTypes = new List { var head = new Nil; };
		val argNames = new List { var head = new Nil; };
		
		val ifMethodType = new MethodTypeDecl {
			val token = new None;
			val name = "$IfLambda$";
			val retPermType = new Void;
			val argTypes = argTypes;
			val argNames = argNames;
		};
		
		val ifLambda = new Lambda {
			val token = new None;
			val x = makeID("unusedIfLambdaArgument");
			val body = new IntLiteral {
				val token = new None;
				val integer = 1;
			};
			val methodType = ifMethodType;
		};
		
		ifLambda;
	}
	
	
	// $elseLambda:
	//   Let u0 = invoke(n, -, 1) in
	//   Let u1 = apply(fibonacci, u0) in
	//   Let u2 = invoke(n, -, 2) in
	//   Let u3 = apply(fibonacci, u2) in
	//       invoke(u1, +, u3)
	
	method makeElseLambda() {
		val invoke2 = new MethodInvocation {
			val token = new None;
			val obj = makeID("u1");
			val function = makeID("+");
			val arg = makeID("u3");
		};
		
		val let3 = new UnannotatedLetBinding {
			val token = new None;
			val x = makeID("u3");
			val exp = new Application {
				val token = new None;
				val f = makeID("fibonacci");
				val arg = makeID("u2");
			};
			val body = invoke2;
			val mutable = false;
		};
		
		val let2 = new UnannotatedLetBinding {
			val token = new None;
			val x = makeID("u2");
			val exp = new MethodInvocation {
				val token = new None;
				val obj = makeID("n");
				val function = makeID("-");
				val arg = new IntLiteral {
					val token = new None;
					val integer = 2;
				};
			};
			val body = let3;
			val mutable = false;
		};
		
		val let1 = new UnannotatedLetBinding {
			val token = new None;
			val x = makeID("u1");
			val exp = new Application {
				val token = new None;
				val f = makeID("fibonacci");
				val arg = makeID("u0");
			};
			val body = let2;
			val mutable = false;
		};
		
		val let0 = new UnannotatedLetBinding {
			val token = new None;
			val x = makeID("u0");
			val exp = new MethodInvocation {
				val token = new None;
				val obj = makeID("n");
				val function = makeID("-");
				val arg = new IntLiteral {
					val token = new None;
					val integer = 1;
				};
			};
			val body = let1;
			val mutable = false;
		};
		
		val argTypes = new List { var head = new Nil; };
		val argNames = new List { var head = new Nil; };
		
		val elseMethodType = new MethodTypeDecl {
			val token = new None;
			val name = "$ElseLambda$";
			val retPermType = new Void;
			val argTypes = argTypes;
			val argNames = argNames;
		};
		
		val elseLambda = new Lambda {
			val token = new None;
			val x = makeID("unusedElseLambdaArgument");
			val body = let0;
			val methodType = elseMethodType;
		};
		
		elseLambda;
	}
	
	// method unique Integer fibonacci(immutable Integer n) {
	//   Let t0 = ifElse in
	//   Let t1 = invoke(n, <=, 2) in
	//   Let t2 = apply(t0, t1) in
	//   Let t3 = $ifLambda in
	//   Let t4 = apply(t2, t3) in
	//   Let t5 = $elseLambda in
	//       apply(t4, t5)
	// }
	
	method makeFibonacci() {
		val let5 = new UnannotatedLetBinding {
			val token = new None;
			val x = makeID("t5");
			val exp = makeElseLambda();
			val body = new Application {
				val token = new None;
				val f = makeID("t4");
				val arg = makeID("t5");
			};
			val mutable = false;
		};
		
		val let4 = new UnannotatedLetBinding {
			val token = new None;
			val x = makeID("t4");
			val exp = new Application {
				val token = new None;
				val f = makeID("t2");
				val arg = makeID("t3");
			};
			val body = let5;
			val mutable = false;
		};
		
		val let3 = new UnannotatedLetBinding {
			val token = new None;
			val x = makeID("t3");
			val exp = makeIfLambda();
			val body = let4;
			val mutable = false;
		};
		
		val let2 = new UnannotatedLetBinding {
			val token = new None;
			val x = makeID("t2");
			val exp = new Application {
				val token = new None;
				val f = makeID("t0");
				val arg = makeID("t1");
			};
			val body = let3;
			val mutable = false;
		};
		
		val let1 = new UnannotatedLetBinding {
			val token = new None;
			val x = makeID("t1");
			val exp = new MethodInvocation {
				val token = new None;
				val obj = makeID("n");
				val function = makeID("<=");
				val arg = new IntLiteral {
					val token = new None;
					val integer = 2;
				};
			};
			val body = let2;
			val mutable = false;
		};
		
		val let0 = new UnannotatedLetBinding {
			val token = new None;
			val x = makeID("t0");
			val exp = makeID("ifElse");
			val body = let1;
			val mutable = false;
		};
	
		val argTypes = new List { var head = new Nil; };
		argTypes.add(getImmutableIntegerPermType());
		val argNames = new List { var head = new Nil; };
		argNames.add(makeID("n"));
		
		val methodType = new MethodTypeDecl {
			val token = new None;
			val name = "fibonacci";
			val retPermType = getUniqueIntegerPermType();
			val argTypes = argTypes;
			val argNames = argNames;
		};
		
		new MethodDecl {
			val token = new None;
			val name = "fibonacci";
			val body = let0;
			val arg = new Some { val value = makeID("n"); };
			val abstractMethod = false;
			val methodType = methodType;
		};
	}
	
	method makeMain() {
		val mainBody = new Application {
			val token = new None;
			val f = new ID {
				val token = new None;
				val name = "fibonacci";
			};
			val arg = new IntLiteral {
				val token = new None;
				val integer = 7;
			};
		};
		
		val mainMethodType = new MethodTypeDecl {
			val token = new None;
			val name = "main";
			val retPermType = new Void;
			val argTypes = new List { var head = new Nil; };
			val argNames = new List { var head = new Nil; };
		};
		
		new MethodDecl {
			val token = new None;
			val name = "main";
			val body = mainBody;
			val arg = new None;
			val abstractMethod = false;
			val methodType = mainMethodType;
		};
	}
	
	method buildFibonacciExample() {
		val thePackageName = new List { var head = new Nil; };
		thePackageName.add("testInputs");
		thePackageName.add("Fibonacci");
		
		val theDecls = new List { var head = new Nil; };
		theDecls.add(makeMain());
		theDecls.add(makeFibonacci());
		
		theDecls.map(fn (m) => {
			this.methodTypes.put(m.name, m.methodType);
		});
		
		val theImports = new ImportList {
			val imports = new List { var head = new Nil; };
			val token = new None;
		};
	
		new CompilationUnit {
			val decls = theDecls;
			val packageName = thePackageName;
			val imports = theImports;
			val sourceFile = "Fibonacci.plaid";
		};
	}


	method getAST() {
		buildFibonacciExample();
	}
	
	method getMethodTypes() {
		this.methodTypes;
	}
}