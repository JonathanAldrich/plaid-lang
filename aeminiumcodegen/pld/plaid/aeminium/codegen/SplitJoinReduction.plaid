package plaid.aeminium.codegen;

state SplitJoinReduction {
	method reduceDependencies(astNode) {
		val newDeps = java.util.HashSet.new();
		val it = astNode.dependencies.value.iterator();
		
		while { it.hasNext(); } {
			// If astNode depends on a Split or Join, replace this dependency
			// by all dependencies of the Split/Join node in question.
			val dep = it.next();
			val depNode = dep.to;
			
			match (depNode) {
				case Split {
					val j = depNode.dependencies.value.iterator();
					while { j.hasNext(); } {
						val d = j.next();
						
						newDeps.add(new Dependency {
							val from = astNode;
							val to = d.to;
							val variable = d.variable;
						});
					};
				}
				
				case Join {
					val j = depNode.dependencies.value.iterator();
					while { j.hasNext(); } {
						val d = j.next();
						
						newDeps.add(new Dependency {
							val from = astNode;
							val to = d.to;
							val variable = d.variable;
						});
					};
				}
				
				default {
					newDeps.add(new Dependency {
						val from = astNode;
						val to = dep.to;
						val variable = dep.variable;
					});
				}
			};
			
			astNode.dependencies = new Some { val value = newDeps; };
		};
	}
}